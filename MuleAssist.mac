| MuleAssist is a KissAssist fork by EqMule and Lemons
| Redesigned to work with the lua MAUI
|See Changlog (No really, go look at it!)
|Will reset window title whenever you gain something (level, aa)
|Default ini file name will now be MuleAssist_${EverQuest.Server}_${Me.CleanName}.ini
|	This will stop the need to have a new ini created for every level
|	Change needed to support Next as the plugin was what created the new _level ini
|	Also, creating 115 inis per toon as you level was not so great.
| 	You can rename your current ini to, "MuleAssist_${EverQuest.Server}_${Me.CleanName}.ini" or keep it the same
|New inis are not populated when you level if you're still using the old _Level.ini format when not running MQ2 and MQ2Mule
|Updated targeting during rezzing
|Fixed a bug in buffing out of group Main Assists
|New [General] entry: OnStart
|	This command will execute once when the macro starts
|	Will default to MAUI if you have it installed and no other entry
|Edits to how item buffs are handled
|	Let me know if items aren't being cast correctly in buffs
|Hunter mode now uses nav if its loaded
|Backoff changed to a timer. Will back off for 3hours. Should improve performance of switchnow
|Will now target and kill pets, especially swarm pets
|By popular complaint, will no longer clear XTarget. If you start having issues, go check your XTarget window to see if stuff is broken. 
15.3.4
|DPS Debug will now appear in /writedebug all
|If on puller mode, won't try to return to camp unless ReturnToCamp is on
|OOG Buffs shouldn't cast if the person has the buff on them and it has >180s left on it
|Say goodbye to MQ2XAssist (I'll unload it for you)
|New Lua script: lemonassist.lua
|	Mimics functionality of MQ2Xassist
|	/lassist - This will set the character you're watching to your MainAssistID in MuleAssistVer
|	/lassist <ID> - This will set your watch to whatever ID you input
|This should greatly improve out of group functionality
|Do not use XTarget slot 1. If your XTargets is ever full and your MA's target isn't on there, we're going to use slot 1. So don't put heal targets etc there. 
|Invis will interrupt OOG buffing
|OnStart now accepts multiple commands
|	lua run ma\start|lua run boxhud
|Improved target choosing
|Various bug fixes
|15.5
|Aggro check now based on level instead of expansion
|TankAll Taunt fix



#turbo 120
#warning
#include custom.inc
#include ninjadvloot.inc
#include_optional generallive.inc

#chat tell
#chat group

|Lemons:Added Knightly v2 parser so we can pick and choose what to parse. This is needed to not parse OOG: lines so they can dynamically evaluate without reloading the macro
#engine parser 2


|****************GLOBAL CALLS **********************|
#DEFINE DEBUGN "/if (${Debug}) ${If[${WriteDebug.Equal[N]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGBUFF "/if (${DebugBuffs}) ${If[${WriteDebug.Find[buff]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGDPS "/if (${DebugDPS}) ${If[${WriteDebug.Find[dps]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGCAST "/if (${DebugCast}) ${If[${WriteDebug.Find[cast]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGCOMBAT "/if (${DebugCombat} || ${DebugDPS}) ${If[${WriteDebug.Find[combat]} || ${WriteDebug.Equal[All]} || ${WriteDebug.Find[dps]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGHEALS "/if (${DebugHeal}) ${If[${WriteDebug.Find[heal]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGMOVE "/if (${DebugMove}) ${If[${WriteDebug.Find[move]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGMEZ "/if (${DebugMez}) ${If[${WriteDebug.Find[mez]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGPET "/if (${DebugPet}) ${If[${WriteDebug.Find[pet]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGPULL "/if (${DebugPull}) ${If[${WriteDebug.Find[pull]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
#DEFINE DEBUGTARGETCHOICE "/if (${DebugTargetChoice}) ${If[${WriteDebug.Find[targetchoice]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
|#DEFINE DEBUGCHAINPULL "/if (${DebugChainP}) ${If[${WriteDebug.Find[chain]} || ${WriteDebug.Equal[All]},/ini ${WriteDebugINI},/echo \atDEBUG \agL:${Macro.CurLine} T:${Macro.RunTime} \aySub: \aw]}"
|Lemons: Things to use in statements
#DEFINE CANSTARTCOMBAT "(${MyTargetID} && (${Spawn[${MyTargetID}].Type.Equal[NPC]} || ${Spawn[${MyTargetID}].Type.Equal[PET]})  && ${Spawn[${MyTargetID}].PctHPs}<=${AssistAt} && (${Spawn[${MyTargetID}].Distance}<${MeleeDistance} || (${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius} && ${MainAssist.NotEqual[${Group.Puller.Name}]}) || (!${Spawn[${MyTargetID}].Speed} && ${Spawn[${MyTargetID}].Distance} <= ${Math.Calc[(${Spawn[${MyTargetID}].MaxRangeTo} + ${Spawn[${Spawn[${MyTargetID}].AssistName}].Distance}) *1.3]})))"
|What heading to face our current target
#DEFINE tHEAD "${Target.HeadingTo.DegreesCCW}"
|What heading is the target facing
#DEFINE tHEADING "${Target.Heading.DegreesCCW}"
|My heading
#DEFINE mHEAD "${Me.Heading.DegreesCCW}"
#DEFINE FACING "${Range.Between[-35,35:${Math.Calc[(((mHEAD - tHEAD) + 540)%360)-180]}]}"
#DEFINE FACINGEACHOTHER "${Range.Between[-60,60:${Math.Calc[(((mHEAD - tHEAD) + 540)%360)-180]}]} && ${Range.Between[-60,60:${Math.Calc[(((tHEADING - mHEAD) + 360)%360)-180]}]}"
#DEFINE TANKMOBS "${If[${ReturnToCamp},${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${CampRadius} targetable zradius 10]},${SpawnCount[npc radius ${CampRadius} targetable zradius 10]}]}"
#DEFINE WITHINCAMP "${If[${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]} < ${CampRadius},1,0]}"

|****************************************| GENERAL EVENTS |***********************************************|
#event ConCheck			 "#1# -#*#a rare creature#*#"
#Event TankTarget		 "<#1#>#*#TANKING-> #3# <- ID:#2#"
#Event TankTarget		 "#*# #1# is TANKING-> #3# <- ID:#2#"
#Event Camping           "#*#seconds to prepare your camp."
#Event EQBCIRC           "<#1#> #2#"
#Event FSEQBC            "#1# tells the fellowship, #2#"
#Event GUEQBC            "#1# tells the guild, #2#"
#Event GainSomething     "#*#You have gained|#1#|"
#Event GotHit            "#1# bashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# crushes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# hits YOU for #*# points of damage.#*#"
#Event GotHit            "#1# kicks YOU for #*# points of damage.#*#"
#Event GotHit            "#1# mauls YOU for #*# points of damage.#*#"
#Event GotHit            "#1# pierces YOU for #*# points of damage.#*#"
#Event GotHit            "#1# punches YOU for #*# points of damage.#*#"
#Event GotHit            "#1# slashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# bites YOU for #*# points of damage.#*#"
#Event GotHit            "#1# tries to #*# YOU, but #*#"
#event GotHit			 "#1#smashes YOU for#*#"
#event GotHit		 	 "#1#gores YOU for#*#"
#event GotHit			 "#1#rampages YOU for#*#" 
#Event Invised           "You Vanish #*#"
#Event Joined            "#1# has joined the group."
#Event KTDismount        "[MQ2] KTDismount#*#"
#Event KTDoorClick       "[MQ2] KTDoorClick #1#"
#Event KTDoorClick       "[MQ2] KTDoorClick#*#"
#Event KTHail            "[MQ2] KTHail #1#"
#Event KTInvite          "[MQ2] KTInvite #1#"
#Event KTSay             "[MQ2] KTSay #1#"
#Event KTTarget          "[MQ2] KTTarget #1#"
#Event LeftGroup         "#1# has left the group."
#Event MezBroke          "#1# has been awakened by #2#."
#Event Missing           "#*#You are missing some required components.#*#"
#Event PTaunt            "#*#Taunting attackers as normal, Master.#*#"
#Event PetSusStateAdd1   "#*# tells you, 'By your command, master.#*#"
#Event PetSusStateAdd2   "#*#You cannot have more than one pet at a time.#*#"    
#Event PetSusStateSub    "#*# tells you, 'I live again...'#*#"
#Event PetToysPlease     "#*#PetToysPlease #1#"
#Event TaskUpdate        "#*#Your task |#1#| has been updated#*#"
|Lemons: Wtf is this?
|#Event Timer             Timer1
#Event TooSteep          "The ground here is too steep to camp"  
#Event WornOff           "Your #1# spell has worn off of #2#."
#Event Zoned             "LOADING, PLEASE WAIT#*#"
#Event Zoned             "You have entered#*#"
#Event BagsFull			 "#*#There are no open slots for the held item in your inventory#*#"
#Event BagsFull			 "#*#You can't hold the book open with your hands full#*#"
|****************************************| COMBAT EVENTS |***********************************************|
#Event Banestrike        "Your Banestrike fails because you have not yet mastered slaying this race."
#Event CantHit           "You can't hit them from here."
#Event CantSee           "You cannot see your target."
#Event GoMOff            "The gift of magic fades."
#Event GoMOff            "Your#*#gift of#*#mana fades."
#Event GoMOn             "#*#granted#*#gift of#*#mana#*#"
#Event GoMOn             "You feel strengthened by a gift of magic."
#Event GoMOn             "You feel strengthened by magic."
#Event ImDead            "#*#Returning to Bind Location#*#"
#Event ImDead            "You died."
#Event ImDead            "You have been slain by#*#"
#Event SomeoneSays       "#1# says, #2#"
#Event SomeoneTells      "#1# tells you, '#2#'"
#Event TooClose          "Your target is too close to use a ranged weapon!!"
#Event TooFar            "Your target is too far away, get closer!"
#Event YouHit            "#1# has taken #2# damage from your #3#."
#Event YouHit            "#1# was hit by non-melee for #2# points of damage."
#Event YouHit            "You backstab #1# for #2# points of damage."
#Event YouHit            "You bash #1# for #2# points of damage."
#Event YouHit            "You bite #1# for #2# points of damage."
#Event YouHit            "You claw #1# for #2# points of damage."
#Event YouHit            "You crush #1# for #2# points of damage."
#Event YouHit            "You frenzy on #1# for #2# points of damage."
#Event YouHit            "You hit #1# for #2# points of damage."
#Event YouHit            "You kick #1# for #2# points of damage."
#Event YouHit            "You maul #1# for #2# points of damage."
#Event YouHit            "You pierce #1# for #2# points of damage."
#Event YouHit            "You punch #1# for #2# points of damage."
#Event YouHit            "You slash #1# for #2# points of damage."
#Event YouHit            "You slice #1# for #2# points of damage."
#Event YouHit            "You sting #1# for #2# points of damage."
#Event YouHit            "You strike #1# for #2# points of damage."
#Event YouHit            "You try to #*#, but miss"
#Event YouHit            "|${Me.Pet.CleanName}| backstabs #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| bashes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| bitess #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| claws #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| crushes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| frenzies on #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me.Pet.CleanName}| hits #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| kicks #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| mauls #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| pierces #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| punches #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| slashes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| slices #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| stings #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| strikes #1# for #2# points of damage."
#Event YouHit            "|${Me}| hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me}|`s pet backstabs #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet bashes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet bites #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet claws #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet crushes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet frenzies on #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me}|`s pet hits #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet kicks #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet mauls #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet pierces #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet punches #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet slashes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet slices #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet stings #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet strikes #1# for #2# points of damage."
#Event CastFailed        "Your #1# spell fizzles!"
#Event CastFailed        "Your spell fizzles!"
#Event CastInterrupted   "Your #1# spell is interrupted."
#Event CastResist		 "#2#resisted your #1#!"
#Event CastDistr         "You are too distracted to distracted to cast a spell now!"
#Event CastDistr		 "You cannot cast this spell on your pet"
#Event MeHidden          "#1# regards you indifferently #*#"
#Event Charmed			 "#1# has been charmed."
#Event CastMezImmune	 "Your target cannot be mesmerized."
#Event Cheerleader		 ": #1# has been defeated by a group of hary adventurers! Please join us in congratulating #2# along#*#"
#Event CannotCharm		 "This NPC cannot be charmed."
#Event FullInventory 	 "#*#Your inventory appears full!#*#"
#Event NotGold  	 	 "#*#you do not have at least a gold membership#*#"
#Event WrongDiety 		 "#*#You do not worship#*#"
#Event Appear	 		 "#*#You feel yourself starting to appear#*#"
#Event Appear	 		 "You appear"
#Event LockedDoor		 "It's locked and you're not holding the key."
#Event TooFarAbility	 "#*#You are too far away#*#"

| -------------------------------------------------------------------------------------
| New Binds to replace old Events
| -------------------------------------------------------------------------------------
#bind AddAFriend     /addfriend
#bind AddMezImmune   /addimmune
#bind AddToIgnore    /addignore
#bind AddToPull      /addpull
#bind AddFire		/addfire
#bind AddCold		/addcold
#bind AddSlow		/addslow
#bind AddDisease	/adddisease
#bind AddMagic		/addmagic
#bind AddPoison		/addpoison
#bind BackOff        /backoff
#bind BuffGroup      /buffgroup
#bind Burn           /burn
#bind Campfire       /campfire
#bind ChangeVarInt   /changevarint
#bind DebugAll       /debugall
#bind IniWrite       /iniwrite
#bind LocKill		/lockill
#bind MassPull       /masspull
#bind MuleCheck      /Mulecheck
#bind MuleE          /Muleedit
#bind MemMySpells    /memmyspells
#bind Parse          /parse
#bind SetPullArc     /SetPullArc
#bind Switch         /switchnow
#bind ToggleVariable /togglevariable
#bind TrackMeDown    /trackmedown
#bind WriteMySpells  /writespells
#bind ZoneInfo       /zoneinfo
#bind IVU            /ivu
#bind RootAll        /rootall
#bind SOW            /sow
#bind DoHalfCircle   /halfmoon
#bind DoFullCircle   /fullmoon
#Bind SheepMove	     /sheepmove
#Bind AssignMainAssist /changema
#Bind GoBackToCamp   /goback
#Bind CustomCall     /customcall
#Bind MuleHide       /mulehide
#Bind Pull           /pull
#Bind CharmThis		 /charmthis	
#Bind BuffMode		 /buffmode
#Bind RGRez			 /rgrez
#Bind ShareIni		/shareini
#Bind Zombie		/zombiemode
#Bind MuleDebug		/muledebug
#Bind CastDebug		/debugcast
#Bind ScribeStuff	/scribestuff
#Bind BardInvis		/bardinvis
#Bind WriteDebug	/writedebug
#Bind DoEvac		/evac
#Bind Foreground	/showwindow
#Bind Raidinvites	/lemonraid
#Bind GroupInvites	/lemongroup
#Bind GroupCheck	/groupcheck
#Bind GiveItem		/giveitem
#Bind LemonDebug	/lemondebug
#Bind ClearDebug	/cleardebug
#Bind Collectibles  /lemoncollect
#Bind MapTheZone	/lemonmap
#Bind WatchMob		/watchmob

Sub CheckAllPlugins
	/if (${Bool[${Plugin[MQ2XAssist]}]}) /plugin mq2xassist unload
	/call CheckPlugin MQ2DamageParser
	/call CheckPlugin MQ2Cast
	/call CheckPlugin MQ2Exchange
	/call CheckPlugin MQ2Moveutils
	/if (${UseMQ2Melee}) /call CheckPlugin MQ2Melee
	/call CheckPlugin MQ2Posse
	/call CheckPlugin MQ2Rez
	/call CheckPlugin MQ2AdvPath
	/call CheckPlugin MQ2Nav
	/if (${IAmABard}) /call CheckPlugin MQ2Twist
	/call CheckPlugin MQ2EQBC
/return

| -------------------------------------------------------------------------------------
| Sub Main
| -------------------------------------------------------------------------------------
| If we dont put this here, there is a chance it will fail due to a chat event which trigger the undeclared variables check
#Event Burn              "[MQ2] |${BurnText}|"
Sub Main
	/declare AssistID				int			outer		0
	/declare n int local
	/declare LemonsFlag int outer 0
	/declare SoWID int outer 0
	/declare RootString string outer NULL
	/declare CachedBuffTimer timer outer 0
	/declare CallCustomFunc int outer 0
	/declare CustomFuncParam string outer
	/declare CustomFuncName string outer
	/declare bCallCustom int outer 0
	/declare OldCampfireX float outer 0
	/declare OldCampfireY float outer 0
	/declare OldCampfireZ float outer 0
	/varset OldCampfireX ${Me.Fellowship.CampfireX}
	/varset OldCampfireY ${Me.Fellowship.CampfireY}
	/varset OldCampfireZ ${Me.Fellowship.CampfireZ}
	|new variable to keep status if we are being hit
	/declare MeleeHit int outer 0
	|new variable to be used for outside group assisting
	/declare AssistOutside int outer 0
	/declare UseNav	bool outer TRUE
    |lets check a few plugins
	/declare mq2navloaded int outer 0
    /if (${Bool[${Plugin[MQ2Nav]}]}) {
		/varset mq2navloaded 1
    }
	/declare mq2advpathloaded int outer 0
    /if (${Bool[${Plugin[MQ2AdvPath]}]}) {
		/varset mq2advpathloaded 1
    }
    /if (!${Bool[${Plugin[MQ2Twist]}]}) {
		|Macro refer to "${Twist}" all over the place and its not a tlo that exist if the plugin is not loaded
		/declare Twist int outer 0
    }


    /doevents flush
    | Define debug variables before everything else
	/declare MuleDebug              int         outer       0
    /declare Debug                  int         outer       0
    /declare DebugAllOn             int         outer       0
    /declare DebugBuffs             int         outer       0
    /declare DebugDPS               int         outer       0
    /declare DebugCombat            int         outer       0
    /declare DebugHeal              int         outer       0
    /declare DebugMez               int         outer       0
    /declare DebugMove              int         outer       0
    /declare DebugPet               int         outer       0
    /declare DebugPull              int         outer       0
    /declare DebugRK                int         outer       0
	/declare DebugCast				int 		outer		0
	/declare DebugTargetChoice		int 		outer		0
	/declare WriteDebug 			string 		outer 		
	/declare WriteDebugTimer 		timer 		outer 		
	/noparse /declare WriteDebugINI			string		outer		"MuleAssistDebug_${Me.CleanName}.ini" "${WriteDebug}" "${EverQuest.Running} T:${Macro.RunTime} Line:${Macro.CurLine}" "Sub:
    | Need to check for plugin MQ2Bucles and unload it. Do this ASAP so can use /while commands from the start
    /if (${Bool[${Plugin[MQ2Bucles]}]}) {
        /squelch /plugin MQ2Bucles unload noauto
        /echo MQ2Bucles detected! This macro doesn't like it! Unloading ...
    }
    | ini file fix for zones with commas in them
    /declare ZoneName string outer ${Zone}
    /if (${ZoneName.Find[,]} || ${ZoneName.Find[']} ) {
        /echo ${ZoneName} has a comma or apostrophe in the name, setting Zone Short Name ...
        /varset ZoneName ${Zone.ShortName}
    }
    /declare MacroName              string      outer       MuleAssist
	|Hi Lemons, pls set LastModBy to Lemons whenever u make changes. -eqmule
	/declare LastModBy              string      outer       Lemons
    /declare MacroVer               string      outer       15.4
    /declare IniFileName            string      outer         
    /declare InfoFileName           string      outer       KissAssist_Info.ini
    /declare ConditionsFileName     string      outer       
    /declare BuffFileName           string      outer       KissAssist_Buffs.ini
    /declare PIniSet                int         outer       0
    /declare pi                     int         local       0
    /declare NumParams              int         local       0
	/declare startLine				string		outer		
	/declare paramStartCheck		string		outer
    /declare GemStuckTimer          timer       outer       0
	/declare customMaxRadius		int			outer
    /declare GoMTimer               timer       outer       0
	/declare FullIniLine			string		outer	
	/declare z						int 		local		0
	/declare inistart				int			outer		
	/declare iniend					int			outer		
    | Check for command line variables
    /if (${Macro.Params}) {
		/varset NumParams ${Math.Calc[${Macro.Params}-1]}
    }
	/if (${Macro.Params}) {
		/for pi 0 to ${NumParams}
			|/echo LemonsDebug: NumParams ${NumParams} |  Param${pi} is: ${Param${pi}} on #${pi}
			|/echo ${Param0} ${Param1} ${Param2}
			/if (${Defined[Param${pi}]}) {
				/declare PParam${pi} string outer ${Param${pi}}
				/varset paramStartCheck ${paramStartCheck} ${Param${pi}}
				/if (${Int[${Param${pi}}]}) {
					/if (${pi} > 0) {
						/echo \agpi:${pi} Param: ${Param${pi}} | ${Param${Math.Calc[${pi}-1].Int}} (${Select[${Param${Math.Calc[${pi}-1].Int}},puller,pullertank,pullerpettank,hunter,hunterpettank]})
						/if (${Select[${Param${Math.Calc[${pi}-1].Int}},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
							/echo The current entry is a number and the last entry was a puller or hunter role. This must be the custom radius
							/varset customMaxRadius ${Param${pi}}
						}
					}
				}
				/if (${Spawn[${Param${pi}}].ID}) {
					/varset startLine ${startLine} ${Spawn[${Param${pi}}].Class.ShortName}
				} else {
					/varset startLine ${startLine} ${Param${pi}}
				}
				|Lemons: To handle ini being sent in with spaces from server shortname
				|/echo LemonsDebug: #${pi} Does it have ini in it? Does it equal ini: ${Param${pi}.Equal["ini"]} 
				/if (${Param${pi}.Equal["ini"]}) {
					/varset inistart ${Math.Calc[${pi}+1]}
					|/echo inistart is set to ${inistart}, which is the first part of the parameter where the ini location is
					|Now to add everything after ini and up to .ini. Iterate through the params until you find one that contains .ini  so we know when to stop adding. 
					/for z ${Math.Calc[${pi} + 1]} to ${NumParams}
						/if (!${Defined[Param${Math.Calc[${z}+1]}]}) {
							|/echo On ${z}, the next Param isn't defined. ${Math.Calc[${z}+1].Int}
							/if (!${Defined[Param${Math.Calc[${z}+1].Int}]}) /declare Param${Math.Calc[${z}+1].Int} string local
							}
						|Removed due to #Warning trigger || ${Select[${Param${Math.Calc[${z}+1].Int}},assist,tank,pullertank,pullerpettank,pullerpet,hunter,hunterpettank,puller,pettank]}
						|/echo LemonsDebug: z:${z} is ${FullIniLine}, checking to add |${Param${z}}|. First entry? ${z} == ${Math.Calc[${pi} +1]}, Subsequent (!${Param${z}.Find[${Me}_${Me.Level}]} && ${z} != ${Math.Calc[${pi} +1]}), Break on this? ${Param${z}.Find[${Me}_${Me.Level}]} || ${Param${z}.Find[${Me}.ini]})
						/if (${z} == ${Math.Calc[${pi} +1]}) /varset FullIniLine ${Param${z}}
						/if ((!${Param${z}.Find[${Me}_${Me.Level}]} || !${Param${z}.Find[${Me}.ini]}) && ${z} != ${Math.Calc[${pi} +1]}) /varset FullIniLine ${FullIniLine} ${Param${z}}
						/if (${Param${z}.Find[${Me}_${Me.Level}]} || ${Param${z}.Find[${Me}.ini]} || ${Select[${Param${Math.Calc[${z}+1].Int}},assist,tank,pullertank,pullerpettank,pullerpet,hunter,hunterpettank,puller,pettank]}) {
							/if (!${FullIniLine.Find[${Me}_${Me.Level}]} && !${Select[${Param${Math.Calc[${z}+1].Int}},assist,tank,pullertank,pullerpettank,pullerpet,hunter,hunterpettank,puller,pettank]}) {
								/varset FullIniLine ${FullIniLine} ${Param${z}}
							}
							/varset iniend ${z}
							/if (${FullIniLine.Right[4].NotEqual[.ini]}) {
								/varset FullIniLine "${FullIniLine}.ini"
							} else {
								/varset FullIniLine "${FullIniLine}"
							}
							|/echo LemonsDebug: This should be the last part of the ini section ${Param${z}} (${Param${z}.Find[.ini]}). iniend set to ${z}							
							/break
						}
					/next z
				}
			}
		/next pi
		|/if (${FullIniLine.Length}) /echo LemonsDebug: FullIniLine is now set to : ${FullIniLine}, PIniSet: !${PIniSet}		
		
    	/call PParse 0 ${NumParams}
	}
    | if MuleAssist finds a Muleassist_ServerName_ToonName.ini file it will use that one 
    /if (!${PIniSet}) {
        /if (${Ini["MuleAssist_${EverQuest.Server}_${Me.CleanName}_${Me.Level}.ini",General,MuleAssistVer].Length} || ${Ini["MuleAssist_${EverQuest.Server}_${Me.CleanName}_${Me.Level}.ini",Buffs,BuffsSize].Length}) {
            /varset IniFileName "MuleAssist_${EverQuest.Server}_${Me.CleanName}_${Me.Level}.ini"
			/echo Server Name ini file using level detected using ${IniFileName} | ${Ini["MuleAssist_${EverQuest.Server}_${Me.CleanName}_${Me.Level}.ini",General,MuleAssistVer].Length}
		} else /if (${Ini["MuleAssist_${EverQuest.Server}_${Me.CleanName}.ini",General,MuleAssistVer].Length}) {
            /varset IniFileName "MuleAssist_${EverQuest.Server}_${Me.CleanName}.ini"
            /echo Server Name ini file detected using ${IniFileName}
        } else {
            /varset IniFileName "MuleAssist_${EverQuest.Server}_${Me.CleanName}.ini"
			/echo No existing ini so I'm using ${IniFileName}
        }  
    }
    /declare MuleAssistVer          string      outer       ${Ini[${IniFileName},General,MuleAssistVer]}
    |Kaen01::time for sitting between casts like the olden days.
	|Lemons: Now will sit for the time specified in this setting. 0 still means it won't sit.
	/declare SitToMedTimer timer outer ${Math.Calc[${Ini[${IniFileName},General,SitToMed]} * 10]}
	|Need to check for level here
	|/echo LemonsDebug: !${Ini[${IniFileName},General,MuleAssistVer].Length}, ${IniFileName}  CurLine:${Macro.CurLine}
    DEBUGN ${IniFileName} ${MuleAssistVer}"
    /if (!${Ini[${IniFileName},General,MuleAssistVer].Length}) {
		| ok so its a new ini
		|/echo LemonsDebug: Creating a blank Ini File /ini ${IniFileName} "General" "MuleAssistVer" "0.0"
		/ini ${IniFileName} "General" "MuleAssistVer" "0.0"
	}

| ************************* Aliases **************************************|
    DEBUGN Ini/Alias info ${MuleAssistVer.NotEqual[${MacroVer}]} "${MuleAssistVer}" "${MacroVer}""
    /if (${MuleAssistVer.NotEqual[${MacroVer}]}) {
        /echo Version Mismatch Detected, Writing Aliases this can take up to 1 min
        /squelch /alias /afktoolson     /changevarint AFKTools AFKToolsOn
        /squelch /alias /assistat       /changevarint Melee AssistAt
        /squelch /alias /autofireon     /togglevariable AutoFireOn
        /squelch /alias /autorezon      /togglevariable AutoRezOn
        /squelch /alias /buffson        /togglevariable BuffsOn
		/squelch /alias /buffwhilechase	/togglevariable BuffWhileChasing
        /squelch /alias /camphere       /togglevariable ReturnToCamp
        /squelch /alias /campradius     /changevarint General CampRadius
        /squelch /alias /chase          /togglevariable ChaseAssist
        /squelch /alias /chasedistance  /changevarint General ChaseDistance
        /squelch /alias /chaseoff       /changevarint General ChaseAssist 0        
        /squelch /alias /chaseon        /changevarint General ChaseAssist 1 
        /squelch /alias /conditions     /togglevariable conditions
        /squelch /alias /conditionsoff  /togglevariable conditions off
        /squelch /alias /conditionson   /togglevariable conditions on
        /squelch /alias /debug          /togglevariable Debug
        /squelch /alias /debugbuffs     /togglevariable DebugBuffs
		/squelch /alias /debugbuff     /togglevariable DebugBuffs
        /squelch /alias /debugcombat    /togglevariable DebugCombat
		/squelch /alias /debugdps	    /togglevariable DebugDPS
        /squelch /alias /debugheal      /togglevariable DebugHeal
        /squelch /alias /debugmez       /togglevariable DebugMez
        /squelch /alias /debugmove      /togglevariable DebugMove
        /squelch /alias /debugpull      /togglevariable DebugPull
        /squelch /alias /debugrk        /togglevariable DebugRK
		/squelch /alias /debugpet		/togglevariable DebugPet
        /squelch /alias /dpsinterval    /changevarint DPS DPSInterval
        /squelch /alias /dpsmeter       /togglevariable DPSMeter
        /squelch /alias /dpson          /changevarint DPS DPSOn
        /squelch /alias /dpsskip        /changevarint DPS DPSSkip
        /squelch /alias /dpsspam        /togglevariable DPSSpam
        /squelch /alias /dpswrite       /togglevariable DPSWriteOn
        /squelch /alias /healson        /changevarint Heals HealsOn   
        /squelch /alias /interrupton    /togglevariable CastingInterruptOn     
        /squelch /alias /ktdismount     /echo KTDismount
        /squelch /alias /ktdoor         /echo KTDoorClick        
        /squelch /alias /kthail         /echo KTHail
        /squelch /alias /ktinvite       /echo KTInvite
        /squelch /alias /ktsay          /echo KTSay
        /squelch /alias /kttarget       /echo KTTarget  
        /squelch /alias /looton         /changevarint General LootOn
        /squelch /alias /maxradius      /changevarint Pull MaxRadius
        /squelch /alias /maxzrange      /changevarint Pull MaxZRange
        /squelch /alias /medstart       /changevarint General MedStart
        /squelch /alias /meleedistance  /changevarint Melee MeleeDistance
        /squelch /alias /meleeon        /togglevariable MeleeOn
        /squelch /alias /mercassistat   /changevarint Merc MercAssistAt
        /squelch /alias /mezon          /changevarint Mez MezOn
        /squelch /alias /movewhenhit    /togglevariable MoveWhenHit 
        /squelch /alias /pethold        /togglevariable PetHold
        /squelch /alias /peton          /togglevariable PetOn
        /squelch /alias /pettoyson      /togglevariable PetToysOn
        /squelch /alias /pettoysplz     /echo PetToysPlease
        /squelch /alias /rebuffon       /togglevariable RebuffOn
        /squelch /alias /returntocamp   /togglevariable ReturnToCamp
        /squelch /alias /scatteron      /togglevariable ScatterOn
        /squelch /alias /setae          /iniwrite AE
        /squelch /alias /setaggro       /iniwrite Aggro
        /squelch /alias /setbuffs       /iniwrite Buffs
        /squelch /alias /setburn        /iniwrite Burn
        /squelch /alias /setcure        /iniwrite Cure
        /squelch /alias /setdps         /iniwrite DPS
        /squelch /alias /setheals       /iniwrite Heals
        /ini ${IniFileName} "General" "MuleAssistVer" "${MacroVer}"
    }
    DEBUGN Aliases processed"
| ************************* Tasks ****************************************|
| Do Not Edit These *****************************************************|

	/declare PullOnce               int         outer       0
	/declare HideResult             int         outer       0
	/declare DoMuleHideID           int         outer       0
	/declare DoMassPullString       string      outer       NULL
    /declare ImDraggingACorpse      int         outer       0
    /declare DeadGroupMember        int         outer       0
    /declare 1stBuffCheck           int         outer       0
    /declare AddSpam                timer       outer       0
    /declare AddsArray[50,3]        string      outer       NULL
    /declare AdvPullTimer           timer       outer       0
    /declare AdvpathPointNum        int         outer       0
    /declare AdvpathPointX          float       outer       0
    /declare AdvpathPointY          float       outer       0
    /declare AdvpathPointZ          float       outer       0
    /declare AggroOffTimer          timer       outer       0
    /declare AggroTargetID          string      outer
    /declare AggroTargetID2         string      outer       0
    /declare Attacking              int         outer       0
	/declare bardShouldBeSitting 	bool		outer		TRUE
    /declare BBWindowOpen           timer       outer       0
    /declare BPBWindowOpen          timer       outer       0
    /declare BagNum                 int         outer       0
    /declare Banestrike             string      outer
    /declare BardStartTwist         int         outer       0
    /declare BurnActive             int         outer       0    
    /declare CampOnDeathTimer       timer       outer       0
    /declare CampXLoc               int         outer       ${Me.X}
    /declare CampYLoc               int         outer       ${Me.Y}
    /declare CampZLoc               int         outer       ${Me.Z}
    /declare CampZone               int         outer       ${Zone.ID}
    /declare CampfireClickTimer     timer       outer       0
    /declare CampfireTimer          timer       outer       0
    /declare CantHit                int         outer       0
    /declare CantSee                int         outer       0
    /declare CastResult             string      outer
    /declare ChainPullHold          int         outer       0
    /declare ChainPullTemp          string      outer 
    /declare ChainPullTimer         timer       outer       0
    /declare ChainPullTimer2        timer       outer       0
    /declare CleanBuffsTimer        timer       outer       0
	/declare XTarClearTimer			timer		outer		20s
	/declare ColdResistant			string		outer		${Parse[0,${If[${Ini[Lemons_Info.ini,ColdMobs].Find[${Target.CleanName}]}||${Ini[Lemons_Info.ini,ColdMobs].Find[${Zone.ShortName}]},1,0]}]}	
    /declare CombatStart            int         outer       0
    /declare CursorID               int         outer       0
    /declare CursorIDCount          int         outer       0
    /declare CursorIDTimer          timer       outer       0
	/declare DiseaseResistant		string		outer		${Parse[0,${If[${Ini[Lemons_Info.ini,DiseaseMobs].Find[${Target.CleanName}]}||${Ini[Lemons_Info.ini,DiseaseMobs].Find[${Zone.ShortName}]},1,0]}]}	
    /declare DMZ                    int         outer       ${Select[${Zone.ID},345,344,202,203,279,151,33506]}
    /declare DPSCounter             int         outer       0
    /declare DPSLastTime            int         outer       0
    /declare DPSPaused              timer       outer       0
    /declare DPSPetTotal            int         outer       0
    /declare DPSSpam                int         outer       0
    /declare DPSTarget              int         outer       0
    /declare DPSTotal               int         outer       0
    /declare DPSTwisting            int         outer       0
    /declare DPSWriteOn             int         outer       0
    /declare DebuffCount            int         outer       0
    /declare DurationMod            float       outer       1
    /declare FailCounter            int         outer       0
    /declare FailMax                int         outer       3
	/declare FireResistant			string		outer		${Parse[0,${If[${Ini[Lemons_Info.ini,FireMobs].Find[${Target.CleanName}]}||${Ini[Lemons_Info.ini,FireMobs].Find[${Zone.ShortName}]},1,0]}]}
    /declare GHCond[10]             string      outer       TRUE
    /declare GMailEvents            string      outer         
    /declare GSent                  int         outer       0
    /declare GoMActive              int         outer       0
    /declare GotHitToggle           int         outer       0
    /declare GroupHeal[10]          string      outer
    /declare HealAgain              int         outer       0
	/declare HideCorpseFlag			bool		outer		FALSE
    /declare IAmDead                int         outer       0
    /declare IniNextTimer           timer       outer       0
    /declare IsTankRoaming          string      outer       0 
    /declare JoinedParty            timer       outer       0
    /declare JustZoned              timer       outer       0
    /declare LastMobPullID          int         outer       0
    /declare LastZone               int         outer       0
	/declare LastSpawnID			int			outer		
	/declare LastBeep				string 		outer
	/declare LastMove				string		outer
	/declare LocKillX1				float		outer		0
	/declare LocKillX2				float		outer		0
	/declare LocKillY1				float		outer		0
	/declare LocKillY2				float		outer		0
	/declare LocRadius				int			outer		200
    /declare LookForward            int         outer       ${Me.Heading.DegreesCCW}
    /declare LooterAssigned         int         outer       0
	/declare MagicResistant			string		outer		${Parse[0,${If[${Ini[Lemons_Info.ini,MagicMobs].Find[${Target.CleanName}]}||${Ini[Lemons_Info.ini,MagicMobs].Find[${Zone.ShortName}]},1,0]}]}	
    /declare MASitTime              timer       outer       0
    /declare MainAssist             string      outer
	/declare MainAssistID			int			outer		
    /declare MainAssistClass        string      outer
    /declare MainAssistType         string      outer
	/declare MapTheZone				int			outer		0
    /declare MashArray[30]          string      outer
    /declare MashCond[30]           string      outer       TRUE
    /declare MedStat                string      outer
    /declare MedStat2               string      outer       Endurance
    /declare Medding                int         outer       0
    /declare MercAssisting          int         outer       0
    /declare MercInGroup            int         outer       0
    /declare MezAETimer             timer       outer       0
    /declare MezArray[50,3]         string      outer       NULL
    /declare MezBroke               int         outer       0
    /declare MezImmuneIDs           string      outer
    /declare MezMobAECount          int         outer       0
    /declare MezMobCount            int         outer       0
    /declare MezMobFlag             int         outer       0
    /declare MezMod                 int         outer       0
    /declare MobCount               int         outer       0
    /declare MobFlag                int         outer       1
	/declare MobWatchName1			string		outer
	/declare MobWatchName2			string		outer
    /declare MountOn                int         outer       1
	/declare TankAllTimer			timer		outer		5s
	/declare MTIDSetAt				int			outer		
    /declare MyAAExp                float       outer       ${Me.PctAAExp}
    /declare MyExp                  float       outer       ${Me.PctExp}
    /declare MyMerc                 string      outer       0
    /if (!${Defined[MyTargetID]}) /declare MyTargetID             int         global       0
    /declare MyTargetName           string      outer       0
	/declare MyCurTarID				int			outer		0
	/declare MyCurTarName			string		outer		0
	/declare nameKill1				string		outer		
	/declare nameKill2				string		outer		
    /declare NamedCheck             int         outer       0
	/declare NumFails				int 		outer 		0
    /declare NeedCuring             int         outer       0
    /declare OrigRanged             string      outer       ${InvSlot[ranged].Item.Name}
    /declare PCsDetected            int         outer       0
    /declare ParseDPSTimer          int         outer       0
    /declare PetActiveState         int         outer       0     
    /declare PetAttack              timer       outer       0
    /declare PetAttackRange         int         outer       0
	/declare petBackTimer			timer		outer		2s
    /declare PetBuffCheck           timer       outer       0
    /declare PetFollowTimer         timer       outer       60s    
    /declare PetSuspendState        int         outer       0 
    /declare PetTanking             int         outer       0
    /declare PetTauntOn             int         outer       0
    /declare PetTotCount            int         outer       0
	/declare PoisonResistant		string		outer		${Parse[0,${If[${Ini[Lemons_Info.ini,PoisonMobs].Find[${Target.CleanName}]}||${Ini[Lemons_Info.ini,PoisonMobs].Find[${Zone.ShortName}]},1,0]}]}	
    /declare PullAlertTimer         timer       outer       0
    /declare PullAmmo               string      outer       NULL
    /declare PullHeading            float       outer       0
	/declare PullLSide              float       outer       0
    /declare PullRSide              float       outer       0
	/declare RPullLSide             float       outer       0
    /declare RPullRSide             float       outer       0
    /declare PullItem               string      outer       NULL
    /declare PullMax                int         outer       0
    /declare PullMin                int         outer       0
    /declare PullMoveUse            string      outer       
    /declare PullPathArrayX[999]    float       outer        
    /declare PullPathArrayY[999]    float       outer
    /declare PullPathArrayZ[999]    float       outer
    /declare PullPathWpCount        int         outer       0
    /declare PullRange              int         outer       0
    /declare PullRangeActual        int         outer
    /declare PullTooFar             int         outer       0
    /declare PullWithAlt            string      outer       Melee
    /declare Pulled                 int         outer       0
    /declare Pulling                int         outer       0
    /declare ReMemCast              int         outer       0
    /declare ReMemCastLW            int         outer       0
    /declare ReMemWaitLong          string      outer       null
    /declare ReMemWaitShort         string      outer       null
    /declare ReadBuffsTimer         timer       outer       0
    /declare Redguides              int         outer       1
    /declare RememberCamp           int         outer       0
	/declare rogInvisTimer			timer		outer		10s
    /declare SHCond[40]             string      outer       TRUE
    /declare SHealPct               int         outer
    /declare SingleHealPoint        int         outer       0
    /declare SingleHeal[40]         string      outer
	/declare sitTimer				timer		outer		4s
	/declare SlowResistant			string		outer		${Parse[0,${If[${Ini[Lemons_Info.ini,SlowMobs].Find[${Target.CleanName}]}||${Ini[Lemons_Info.ini,SlowMobs].Find[${Zone.ShortName}]},1,0]}]}	
	/declare standTimer				timer		outer		1s
    /declare SpamTimer              timer       outer       0
    /declare TWbufflist             string      outer
    /declare TankTimer              timer       outer       0
    /declare TaskGiver              string      outer
    /declare TempMaxRadius          int         outer       0
    /declare ToClose                int         outer       0
    /declare TributeTimer           timer       outer       0
    /declare Twisting               int         outer       0
	/declare TwistingInvis			int			outer		0
	/declare TwistStop				string		outer		
	/declare UsedReloc				bool		outer		FALSE
	|Set to FALSE if you never want to use AdvPath, like Lemons
	/declare UseAdvPath				bool		outer		FALSE
    /declare ValidTarget            int         outer       0
    /declare WaitTimer              timer       outer       0
    /declare WeaveArray[30]         string      outer
    /declare WeaveCond[30]          string      outer       TRUE
    /declare WriteBuffsMercTimer    timer       outer       0
    /declare WriteBuffsPetTimer     timer       outer       0
    /declare WriteBuffsTimer        timer       outer       0
    /declare XTSlot                 int         outer       0
    /declare XTSlot2                int         outer       0
	/declare CharmPetID				int			outer		0
	/declare StickChecked			int 		outer		0
	/declare BuffeeLevel			int 		outer		0
	/declare Buffee					int 		outer		0
	/declare castedOOGs				int			outer		0
	/declare ZombieMode				bool		outer		FALSE
	/declare ZombieTimer			timer		outer		0
	||/declare MostHurtMob int outer 500 --Switching these back to local so they get reset. This was probably the bug where he wouldn't target anything.
    ||    /declare HighestLevelMob int outer 0
    ||    /declare ClosestMobID int outer 0
    ||    /declare MostHurtMobID int outer 0
    ||    /declare HighestLevelMobID int outer 0
    ||    /declare BlurredMobID int outer 0
     ||   /declare XTDistance float outer 0
    ||    /declare TempTargetID int outer
    ||    /declare TmpTar int outer 0
    DEBUGN Misc Declares Processed"	
| ************************* General **************************************|
    | Edit settings in your MuleAssist_ToonName.ini file
    /echo [${Time}] Loading INI Info
    /call LoadIni General Role                  string      Assist
    /call LoadIni General CampRadius            int         30
    /call LoadIni General CampRadiusExceed      int         400
    /call LoadIni General ReturnToCamp          int         0
	/call LoadIni General ReturnToCampAccuracy  int         10
    /call LoadIni General ChaseAssist           int         0
    /call LoadIni General ChaseDistance         int         25
	/call LoadIni General BuffWhileChasing		bool		1
    /call LoadIni General MedOn                 int         1
    /call LoadIni General MedStart              string         20
	|Ini setting to sit to med function, 0=off / 1=on, off by default
    /call Loadini General SitToMed              float       0
    /call LoadIni General LootOn                int         0
    /call LoadIni General RezAcceptOn           string      0|96
    /call LoadIni General AcceptInvitesOn       int         1
    /call LoadIni General GroupWatchOn          string      0
    /call LoadIni General CastingInterruptOn    int         0
    /call LoadIni General TheWinTitle			string	    NULL
    /call LoadIni General GemStuckHelp          string      "Sometimes the spellgems get stuck in a foreverloop, casting an altability that has a cast time will unstick it, this is an eq bug."
    /call LoadIni General GemStuckAbility       string	    NULL

    /declare GroupWatchPct string outer 20
	/declare GroupWatchClasses string outer 
    /if (${GroupWatchOn.Find[|]}) {
		/if (${GroupWatchOn.Arg[1,|].Equal[3]}) {
			/varset GroupWatchClasses ${GroupWatchOn.Arg[3,|]}
			}
        /varset GroupWatchPct ${GroupWatchOn.Arg[2,|]}
        /varset GroupWatchOn ${GroupWatchOn.Arg[1,|]}
    }
    /call LoadIni General MiscGem               int         8
    /call LoadIni General MiscGemLW             int         0
    /call LoadIni General MiscGemRemem          int         1
    /declare ReMemMiscGem           string      outer       ${Me.Gem[${MiscGem}].Name}
    /declare ReMemMiscGemLW         string      outer       ${Me.Gem[${MiscGemLW}].Name}	
    /call LoadIni General HoTTOn                int         0
    /call LoadIni General CampfireOn            int         0 
    /if (${Int[${Ini[${IniFileName},General,CharInfo].Arg[2,|]}]}!=${Me.Level}) /ini ${IniFileName} "General" "CharInfo" "${Me.Class}|${Me.Level}|${Me.Subscription}"
    /if (${Int[${Ini[${IniFileName},General,DefaultUI].Arg[1,|]}]}!=${EverQuest.CurrentUI.Equal[Default]}) /ini ${IniFileName} "General" "DefaultUI" "${If[${EverQuest.CurrentUI.Equal[Default]},TRUE,FALSE|Custom UIs are not supported. Please switch to Default UI before posting bugs.]}"
    /declare GroupEscapeOn int     outer      0
    /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
        /call LoadIni General GroupEscapeOn     int         0
    }
    /call LoadIni General DPSMeter              int         0
    /call LoadIni General Scatter               int         0
    /declare ConditionsOn int outer 2
    |/call LoadIni General ConditionsOn          int         2
    /call LoadIni General MoveCloserIfNoLOS     int         0
	|Not optional anymore, everyone needs this to be set to 2 for mq2mule compatability.
	/call LoadIni General CheerPeople			int			0
	/call LoadIni General CastRetries			int			3
	/varset ConditionsOn 2
    /varset ConditionsFileName ${IniFileName}

| **************** EQBC vs DanNet General Settings ***********************|
    /call LoadIni General IRCOn                 int         0
    /call LoadIni General EQBCOn                string      0
    /call LoadIni General DanNetOn              string      0
    /call LoadIni General DanNetDelay           int         20
	/call LoadIni General SwitchWithMA			bool		FALSE
	/call LoadIni General TravelOnHorse			bool		FALSE
	/if (${Ini[../lua/ma/schema.lua].Length} && !${Ini[${IniFileName},General,OnStart].Length}) {
		/call LoadIni General OnStart				string		"lua run ma\start"
	} else {
		/call LoadIni General OnStart				string		NULL
	}
	/if (${EQBCOn}) /call CheckPlugin MQ2EQBC	
	/call CheckPlugin MQ2Dannet
    /if (${EQBCOn} && ${DanNetOn}) {
        | TODO(klompr/jaybocc2): Default to EQBC for now.  Should Default to Dannet Eventually?
        /echo Invalid Combination for EQBC and DanNet. Defaulting to EQBC
        /varset EQBCOn 1
        /varset DanNetOn 0
    }
    |/declare EQBCSay                            string      outer   bc
    /declare BroadCastSay                       string      outer   bc
    /if (${EQBCOn}) {
		/if (!${EQBC.Connected}) /bccmd connect
        /varset BroadCastSay bc
        /if (${EQBCOn.Arg[2,|].Length} && ${EQBCOn.Arg[1,|].Equal[2]}) {
            DEBUGN ${EQBCOn} ${EQBCOn.Arg[1,|]} ${EQBCOn.Arg[2,|]} "
            /varset BroadCastSay bct ${EQBCOn.Arg[2,|]}
            /varset EQBCOn 2
        }
    } else /if (${DanNetOn}) { 
        /varset BroadCastSay dgtell all
        /if (${DanNetOn.Arg[2,|].Length} && ${DanNetOn.Arg[1,|].Equal[2]}) {
            DEBUGN ${DanNetOn} ${DanNetOn.Arg[1,|]} ${DanNetOn.Arg[2,|]} "
            /varset BroadCastSay dgtell ${DanNetOn.Arg[2,|]}
            /varset DanNetOn 2
        }
    }

| ************************* SpellSet *************************************|
    /call LoadIni SpellSet LoadSpellSet          int         0
    /call LoadIni SpellSet SpellSetName          string      "MuleAssist"   
| ************************* Buffs ****************************************|
    /call LoadIni Buffs BuffsOn                 int         0
    /call LoadIni Buffs BuffsCOn                int         0          NULL         FALSE          ${ConditionsFileName}
    /call LoadIni Buffs BuffsSize               int         40
    /declare Buffs[${BuffsSize}]                string      outer
    /declare BuffsCond[${BuffsSize}]            string      outer      TRUE
    /call LoadIni Buffs Buffs                   string      NULL       Buffs        BuffsCond      ${IniFileName} ${ConditionsFileName}
    /call LoadIni Buffs RebuffOn                int         1
    /call LoadIni Buffs CheckBuffsTimer         int         10
    /call LoadIni Buffs PowerSource             string      NULL
	/declare BuffMode 							bool 		outer 		FALSE
| ************************* Buff Beg ****************************************|
	/call LoadIni Buffs BegOn					string			0
	/call LoadIni Buffs BegSize					int			1
	/declare Beg[${BegSize}]					string		outer
	/call LoadIni Buffs BegPermissionHelp		string		"Valid options are |raid|guild|fellowship|all|tell|group"
	/call LoadIni Buffs BegPermission			string		NULL
	/call LoadIni Buffs BegHelp					string		"Spellname|alias1,alias2,alias3 etc"
	/call LoadIni Buffs Beg						string		NULL		Beg			NULL			${IniFileName}
	/call LoadIni Buffs BuffCacheingDelay		int			300
| ************************* Melee ****************************************|
    /call LoadIni Melee AssistAt                string         95
    /if (${Select[${Me.Class.ShortName},BST,BER,MNK,PAL,RNG,ROG,SHD,WAR]}) {
        /call LoadIni Melee MeleeOn             int         1
		/assist off
	} else {
        /call LoadIni Melee MeleeOn             int         0
		/assist off
    }
    /call LoadIni Melee FaceMobOn               int         1
    /call LoadIni Melee MeleeDistance           string         30
    /call LoadIni Melee StickHow                string      "snaproll rear"
    /call LoadIni Melee AutoFireOn              string         0
    /call LoadIni Melee UseMQ2Melee             int         1
	/call LoadIni Melee DismountDuringFights    int         0

    /declare BeforeCombat string outer
    /call LoadIni Melee BeforeCombat        string      "Cast Before Melee Disc"

	/declare RogueTimerEight string         outer      Daggerslice
    /if (${Select[${Me.Class.ShortName},ROG]}) {
        /call LoadIni Melee AutoHide            int         1
        /call LoadIni Melee RogueTimerEight     string         Daggerslice
    }
	/call LoadIni Melee TankAllMobs 			bool 		FALSE
| ************************* GoM ****************************************|
    /if (!${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
		/call LoadIni GoM GoMOn                 int         1
        /call LoadIni GoM GoMSHelp              string       "Format - Spell|Target, MA Me or Mob, i.e. Rampaging Servant Rk. II|Mob"
        /call LoadIni GoM GoMCOn                int         0          NULL         FALSE          ${ConditionsFileName}
        /call LoadIni GoM GoMSize               int         4
        /declare GoM[${GoMSize}]           string      outer
        /declare GoMCond[${GoMSize}]            string      outer       TRUE
        |string       sectionName, varName,     varType,    varValue,  varArray,    varArray2,     FileName,        FileName2
        /call LoadIni GoM GoM              string      NULL       GoM     GoMCond        ${IniFileName} ${ConditionsFileName}  
    }
| ************************* Gmail ****************************************|
    /call LoadIni GMail GMailHelp              string       "Events currently support - Dead,GM,Level,Named,Leftgroup,Say,Tell"
    /call LoadIni GMail GMailOn                int         0
    /call LoadIni GMail GMailSize              int         5
    /declare GMail[${GMailSize}]               string        outer
    /call LoadIni GMail GMail                  string        NULL       GMail
| *************************  AE ******************************************|
    /call LoadIni AE AEOn                       int         0
    /call LoadIni AE AESize                     int         20
    /call LoadIni AE AERadius                   int         50
    /declare AE[${AESize}]                      string      outer
    /call LoadIni AE AE                         string      NULL        AE
| ************************* DPS ******************************************|
    /call LoadIni DPS DPSOn                     int         0
    /call LoadIni DPS DPSCOn                    int         0           NULL          FALSE           ${ConditionsFileName}
    /call LoadIni DPS DPSSize                   int         40
    /call LoadIni DPS DPSSkip                   int         1
    /call LoadIni DPS DPSInterval               int         2
    /declare DPS[${DPSSize}]                    string      outer
    /declare DPSCond[${DPSSize}]                string      outer       TRUE
    |string       sectionName, varName,         varType,    varValue,   varArray,     varArray2,     FileName,        FileName2
    /call LoadIni DPS DPS                       string      NULL        DPS           DPSCond        ${IniFileName} ${ConditionsFileName}
    /call LoadIni DPS DebuffAllOn               int         0
	/call LoadIni DPS StayAwayToCast			bool		FALSE
	/if (${AutoFireOn} || ${StayAwayToCast}) {
		/if (${MeleeOn}) {
			/popup You have AutoFire and Melee on. Turning off Melee
			/varset MeleeOn 0
		}
		/if (${StickHow.NotEqual[off]}) {
			/popup You have StickHow set with AutoFire. Changing it to "off"
			/varset StickHow off
		}
	}
| ************************* Bandolier ******************************************|
    /call LoadIni Bandolier BandolierOn         int         0    
    /call LoadIni Bandolier BandolierCOn        int         0           NULL          FALSE           ${ConditionsFileName}
    /call LoadIni Bandolier BandolierSize       int	    2
    /call LoadIni Bandolier BandolierPull       string	    1HS
    /declare Bandolier[${BandolierSize}]        string      outer
    /declare BandolierCond[${BandolierSize}]    string      outer       TRUE
    /call LoadIni Bandolier Bandolier           string      NULL        Bandolier           BandolierCond        ${IniFileName} ${ConditionsFileName}
| ************************* OhShit ******************************************|
    /call LoadIni OhShit OhShitOn         int         0    
    /call LoadIni OhShit OhShitCOn        int         0           NULL          FALSE           ${ConditionsFileName}
    /call LoadIni OhShit OhShitSize          int	        10
    /declare OhShit[${OhShitSize}]        string      outer
    /declare OhShitCond[${OhShitSize}]    string      outer       TRUE
    |string       sectionName, varName,         varType,    varValue,   varArray,     varArray2,     FileName,        FileName2
    /call LoadIni OhShit       OhShit           string      NULL        OhShit        OhShitCond    ${IniFileName} ${ConditionsFileName}
| ************************* Aggro ******************************************|
    /call LoadIni Aggro AggroOn                 int         0
	/call LoadIni Aggro AggroCOn				int         0           NULL          FALSE           ${ConditionsFileName}
    /call LoadIni Aggro AggroSize           int         10
    /declare Aggro[${AggroSize}]                string      outer
    /declare AggroCond[${AggroSize}]            string      outer       TRUE
    /call LoadIni Aggro Aggro                   string      NULL        Aggro         AggroCond      ${IniFileName} ${ConditionsFileName}
| ************************* Bard *****************************************|
    /declare IAmABard                           bool        outer          ${Me.Class.Name.Equal[Bard]}
    /declare TwistOn      			int	    outer	   0
    /declare MeleeTwistOn			int	    outer	   0
    /if (${IAmABard}) {
        /call LoadIni General TwistOn           int         0
        /call LoadIni General TwistMed          string         "Mana song gem"
        /call LoadIni General TwistWhat         string      "Twist order here"
        /call LoadIni Melee MeleeTwistOn        int         0
        /call LoadIni Melee MeleeTwistWhat      string      "DPS twist order here"
        /call LoadIni Pull PullTwistOn          int         0
    }
| ************************* Heals ***************************************|
    /call LoadIni Heals Help                    string      "Format Spell|% to heal at i.e. Devout Light Rk. II|50"
    /call LoadIni Heals HealsOn                 int         0
    /call LoadIni Heals HealsCOn                int         0           NULL          FALSE           ${ConditionsFileName}
	/call LoadIni Heals	InterruptHeals			int			100
    /call LoadIni Heals HealsSize				int         40
    /declare Heals[${HealsSize}]                string      outer
    /declare HealsCond[${HealsSize}]            string      outer       TRUE
    /call LoadIni Heals Heals                   string      NULL        Heals         HealsCond      ${IniFileName} ${ConditionsFileName} 
	|Lemons: XTarHeal is now a string array. 0 for off, otherwise put numbers separated by | 
    /call LoadIni Heals XTarHeal                string      0
    /declare AutoRezOn int outer 0
    /if (${Select[${Me.Class.ShortName},CLR,NEC,SHM,DRU,PAL]}) {
        /call LoadIni Heals AutoRezOn           int         0
        /call LoadIni Heals AutoRezWith         string      "Your Rez Item/AA/Spell"
    }
    /call LoadIni Heals HealGroupPetsOn         int         0
| ************************* Cures ***************************************|
    /call LoadIni Cures CuresOn                 int         0
    /call LoadIni Cures CuresSize               int         10
    /declare Cures[${CuresSize}]                string      outer
    /call LoadIni Cures Cures                   string      NULL        Cures
	/declare CuresCond[${CuresSize}]			string		outer
	/call LoadIni Cures Cures                   string      NULL       Cures        CuresCond      ${IniFileName} ${ConditionsFileName}
| ************************* Pet *****************************************|
	/declare PetForceHealOnMed int outer 0
	/declare PetOn int outer 0
	/declare PetFocus string outer NULL
	/declare PetToysGave string outer NULL
	/declare PetToysOn int outer 0
	/declare PetAssistAt string outer 95
	/declare PetCombatOn int outer 0
	/declare PetHold                        string     outer
    /if (${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,SHD]}) {
        /call LoadIni Pet PetOn                 int         0
        /call LoadIni Pet PetSpell              string      "YourPetSpell"
        /if (${Select[${Me.Class.ShortName},BST,MAG,NEC]})  /call LoadIni Pet PetFocus   string  "NULL"
        /call LoadIni Pet PetShrinkOn           int         0
        /call LoadIni Pet PetShrinkSpell        string      "Tiny Companion"
        /call LoadIni Pet PetBuffsOn            int         0
        /call LoadIni Pet PetBuffsSize          int         8
        /declare PetBuffs[${PetBuffsSize}]      string      outer
        /call LoadIni Pet PetBuffs              string      NULL        PetBuffs
        /call LoadIni Pet PetCombatOn           int         1
        /call LoadIni Pet PetAssistAt           string         95          
        /declare PetToysDone                    int         outer       0
        /call LoadIni Pet PetToysSize           int         6
        /declare PetToys[${PetToysSize}]        string      outer
        /if (${Select[${Me.Class.ShortName},MAG]}) {
            /call LoadIni Pet PetToysOn         int         0
            /call LoadIni Pet PetToys           string      NULL        PetToys
            /call LoadIni Pet PetToysGave       string      NULL
        }
        /call LoadIni Pet PetBreakMezSpell    string      NULL
        /call LoadIni Pet PetRampPullWait       int         0  
        /call LoadIni Pet PetSuspend            int         0
        /call LoadIni Pet MoveWhenHit           int         0
        /call LoadIni Pet PetHoldOn             int         1
        /if (${Me.AltAbility[Pet Discipline].Rank}>=1) {
			/if (${Select[${Me.Class.ShortName},bst,shm,nec,mag,shd]} || ${Me.AltAbility[Pet Discipline].Rank}>=4) {
				/varset PetHold ghold
				/pet ghold on
			} else {
				/varset PetHold hold
				/pet hold on
			}
        }
        /call LoadIni Pet PetForceHealOnMed     int         0
    }    
		/call LoadIni Pet PetBehind             bool         TRUE
| ************************* Mez *****************************************|
    |Have to declare this, its refered in multiple places throughout the macro.
    /declare MezOn int outer 0
    /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
		/call LoadIni Mez MezOn                 int         0
        /call LoadIni Mez MezRadius             int         50
        /call LoadIni Mez MezMinLevel           int         "Min Mez Spell Level"
        /call LoadIni Mez MezMaxLevel           int         "Max Mez Spell Level"
        /call LoadIni Mez MezStopHPs            int         80
        /call LoadIni Mez MezSpell              string      "Your Mez Spell"
        | necros can't AE mez
        /if (${Select[${Me.Class.ShortName},BRD,ENC,Nec]}) {
            /call LoadIni Mez MezAESpell            string      "Your AE Mez Spell|0"
            /declare MezAECount                     int         outer ${MezAESpell.Arg[2,|]}
            /varset MezAESpell                      ${MezAESpell.Arg[1,|]}
        }
        /declare MezCount[13]                   int         outer 0
        /declare MezAEClosest                   int         outer 0
    }
        | This loads and declares the MezImmune var
        /call LoadIni "${ZoneName}" MezImmune string "List up to 10 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL False ${InfoFileName}

| ************************* Burn ****************************************|
    /call LoadIni Burn  BurnCOn                 int         0           Null          FALSE            ${ConditionsFileName}
    /call LoadIni Burn  BurnSize                int         40
    /declare Burn[${BurnSize}]                  string      outer
    /declare BurnCond[${BurnSize}]              string      outer   TRUE
    /call LoadIni Burn  BurnText                string      "Burn this"
    /call LoadIni Burn  BurnAllNamed            int         0
    /call LoadIni Burn  Burn                    string      NULL        Burn          BurnCond        ${IniFileName} ${ConditionsFileName}
    /call LoadIni Burn  UseTribute              int         0
| ************************* Pull ****************************************|
    /call LoadIni Pull PullWith                 string      "Melee"
    /call LoadIni Pull PullMeleeStick           int         0
    /call LoadIni Pull MaxRadius                int         350
    /call LoadIni Pull MaxZRange                int         50
    /call LoadIni Pull CheckForMemblurredMobsInCamp                 int         0
    /call LoadIni Pull PullWait                 int         5
	/call LoadIni Pull PullCond					string 		TRUE
	/call LoadIni Pull PrePullCond				string 		TRUE
    /call LoadIni "${ZoneName}" MobsToPull 		string 		"List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or ALL for all mobs" NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToPullSecondary string 	NULL 	NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToIgnore 	string 		"List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToBurn 		string 		"List up to 10 mobs. Use full names i.e. Beget Cube,Helias,Raze or NULL" Null False ${InfoFileName}
    /call LoadIni "${ZoneName}" PullPath 		string 		"Place holder for path file. Not yet impletmented." NULL False ${InfoFileName}
    /call LoadIni Pull PullRoleToggle           int         0
    /call LoadIni Pull ChainPull                int         0
    /call LoadIni Pull ChainPullHP              int         90
    /call LoadIni Pull ChainPullPause           string      30|2
    /call LoadIni Pull PullLevel                string      0|0
    /call LoadIni Pull PullArcWidth             string      0
	/call LoadIni Pull PullNamedsFirst          int         0
    /call LoadIni Pull ActNatural               int         1
    /call LoadIni Pull UseCalm                  int         0
    /call LoadIni Pull CalmWith                 string      Harmony
    /call LoadIni Pull CalmRadius               int      	50
    /call LoadIni Pull GrabDeadGroupMembers     int         1

    | /call LoadIni Pull PullPath               string      NULL
| ************************* AFKTools ************************************|
    /call LoadIni AFKTools AFKHelp              string      "AFKGMAction=0 Off, 1 Pause Macro, 2 End Macro, 3 Unload MQ2, 4 Quit Game"
    /call LoadIni AFKTools AFKToolsOn           int         0
    /call LoadIni AFKTools AFKGMAction          int         1
    /call LoadIni AFKTools AFKPCRadius          int         500
    /call LoadIni AFKTools CampOnDeath          int         0
    /call LoadIni AFKTools ClickBacktoCamp      int         0
	/call LoadIni AFKTools BeepOnNamed		    int         0
	
| ************************* Rogue ************************************|
	/if (${Me.Class.ShortName.Equal[rog]}) {
		/call LoadIni Rogue RogCorpseRetrieval		bool		FALSE
		/call LoadIni Rogue RogCorpseRadius			int			500
	} else {
		/declare RogCorpseRetrieval bool outer FALSE
		/declare RogCorpseRadius int outer 0
	}
    DEBUGN Load ini processed"
	
    | Set AA DurationMod for various timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==4) /varset DurationMod 1.7
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==5) /varset DurationMod 1.9
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==4) /varset DurationMod 1.6
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==5) /varset DurationMod 1.7
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==6) /varset DurationMod 1.8

    | Set AA DurationMod for mez timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==1) /varset MezMod 6
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==2) /varset MezMod 12
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==3) /varset MezMod 18
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==4) /varset MezMod 24
    | Compensate for Eyes Wide open AA and Extended Target Window
    /declare XSlotTotal int outer 13
    /for n 1 to ${Me.XTargetSlots}
        /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]}) {
            /if (${XTSlot} && !${XTSlot2}) /varset XTSlot2 ${n}
            /if (${XTSlot}==0) /varset XTSlot ${n}
        }
    /next n
    |  Added extra slot check and Error Message
    /if (${XTSlot}==0 || ${ChainPull} && !${XTSlot2}) {
        /echo You need more slots in your Extended Target Window set to Auto.
		/if (${ChainPull}) {
            /echo Please set at least 2 slots to Auto for Chain Pulling and restart MuleAssist.
        } else {
            /echo Please set at least 1 slot to Auto and restart MuleAssist.
        }
        /end
    }
    | Changed Logic for populating AggroTargetID. This change will include mobs in camp not on XTarget.
    /noparse /varset AggroTargetID ${If[${Me.XTarget[${XTSlot}].ID},${Me.XTarget[${XTSlot}].ID},${If[${AggroTargetID2},${AggroTargetID2},0]}]}
| ************************* Merc ****************************************|
    /call LoadIni Merc Help                     string      "To use: Turn off Auto Assist in Manage Mercenary Window"
    /call LoadIni Merc MercOn                   int         0
    /call LoadIni Merc MercAssistAt             int         92
    /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
    /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
	DEBUGN Timers Processed"
| -------------------------------------------------------------------------------------
| Check if required plugins are loaded and settings
| -------------------------------------------------------------------------------------
	|/echo [${Time}] START CheckAllPlugins
	/call CheckAllPlugins
	|/echo [${Time}] END CheckAllPlugins
    |  Turn aggro mode off and turn on melee mode in MQ2Melee
	|/echo UseMQ2Melee = ${UseMQ2Melee}
    /if (!${UseMQ2Melee}) {
		/if (${Bool[${Plugin[mq2melee]}]}) /plugin mq2melee unload noauto
	}
	|/echo [${Time}] START UseMQ2Melee
    /if (${UseMQ2Melee}) {
		/if (${Bool[${Plugin[mq2melee]}]}) {
			/squelch /melee aggro=0
			/squelch /melee melee=1
			/squelch /melee stickbreak=1
			/squelch /melee petassist=0
			/squelch /melee on
			|If they don't have their own stick settings already, then we set to our defaults.
			/if (!${meleemvs[stickcmd].Length} && ${meleemvi[stickmode]} != 2) {
				/squelch /melee stickmode=0
				/squelch /melee stickrange=30.
			}
		} else {
		/popup Warning! You have UseMQ2Melee=1, but MQ2Melee isn't loaded. Trying to load it for you. 
		/plugin mq2melee noauto
		}
		|Had a bad stickhow default. Removing it if it exists.
		/if (${StickHow.Equal[snaproll !front]}) {
			/echo Invalid StickHow found. Setting it to !front
			/ini ${IniFileName} "Melee" "StickHow" "!front"
		}
		|If using melee stick commands
		/if (${meleemvs[stickcmd].Length} && ${meleemvi[stickmode]} == 1) {
			|If StickHow is not default and does have something
			/if (${StickHow.NotEqual[snaproll rear]} && ${StickHow.Length}) {
				|Nothing. StickHow is at the top of the Tier list so we keep it and turn off melee sticking
				/melee stickrange=0
				/echo Turning off your stickmode from MQ2Melee because you have a custom setting in [Melee] for StickHow. (${StickHow.NotEqual[snaproll rear]} && ${StickHow.Length})
			} else {
				|StickHow is just the ini default or blank, so we want to use the custom sticking in Melee. 
				/melee stickmode=1
				/varset StickHow ${meleemvs[stickcmd]}
				/echo Setting StickHow to ${meleemvs[stickcmd]} from your MQ2Melee ini because (stickcmd: ${meleemvs[stickcmd].Length} stickmode: ${meleemvi[stickmode]} == 1) then false on: (stickcmd: ${meleemvs[stickcmd].Length} && stickmode: ${meleemvi[stickmode]} == 1) 
			}
		}
    }
	/echo Sticking with the command /stick ${StickHow} 
	/if (${Bool[${Plugin[mq2mule]}]}) {
		|ok they are good users, we can check it's ini.
		/varset DebugBuffs ${Ini["${MacroQuest.Path}\mq2mule.ini,${EverQuest.Server}_${Me},DebugBuffs,0"]}
		/varset DebugDPS ${Ini["${MacroQuest.Path}\mq2mule.ini,${EverQuest.Server}_${Me},DebugDPS,0"]}
		/mule updateversion
		/mule updatelevel
	}
    |/echo [${Time}] Set MQ2moveutils variables
	|mq2moveutils saves EVERYTHING on each save... we dont want to wait that long.
	|and besides a macro has NO buisness AT ALL changing the users plugin settings permanently.
	|we turn on autosave in the :OnExit event anyway.
	/stick set autosave off
    /if (${Debug}) {
		/stick set verbflags 33554431
	} else {
		/stick set verbflags 0
	}
    |There is no such setting in mq2moveutils, its only a command /stick set moveback 12
	|/echo [${Time}] /stick Set breakonkb on
    /stick set breakonkb on
	|/echo [${Time}] /stick Set breakonmouse off
    /stick set breakonmouse off
	|/echo [${Time}] /stick Set breakdist ${CampRadiusExceed}
    /stick set breakdist ${CampRadiusExceed}
	|/echo [${Time}] /stick Set breakonwarp on
    /stick set breakonwarp on
	|/echo [${Time}] /stick Set usefleeing on
    /stick set usefleeing on
	|/echo [${Time}] /stick Set delaystrafe on
    /stick set delaystrafe on
    |/echo [${Time}] Set up MQ2rez if RezAcceptOn=1
	|/echo Rez settings (${RezAcceptOn.Arg[1,|].Equal[1]})
    /if (${RezAcceptOn.Arg[1,|].Equal[1]}) {
        /squelch /rez accept on
        /squelch /rez loot off
		|/echo (${Int[${RezAcceptOn.Arg[2,|]}]}>0) /rez pct ${Int[${RezAcceptOn.Arg[2,|]}]}
        /if (${Int[${RezAcceptOn.Arg[2,|]}]}>0) /rez pct ${Int[${RezAcceptOn.Arg[2,|]}]}
    }
    /if (${Select[${AFKToolsOn},1,2]}) {
        /posse radius ${AFKPCRadius}
        /posse friendnotify off
        /posse strangernotify on
        /if (!${Posse.Status})  {
            /posse on
            /posse load
        }
    }
    | Initialize variables for ninjadvloot.inc include file
	
	|/echo [${Time}] START: setting up lootvars
    /call SetupAdvLootVars
	|/echo ${Time} END: setting up lootvars
	|/echo ${Time} START: Sorting heals
    /if (${HealsOn}) {
        /call SortArray Heals HealsCond 100|100 >
        /call FindSingleHeals
        /call FindGroupHeals
        /call CreateTimersHeals
    }
	|/echo ${Time} END: Sorting heals
	|/echo ${Time} START: AlertAddToList
    /call AlertAddToList 3 "${MobsToIgnore}"
    /call CreateTimersGoM
	|/echo ${Time} END: AlertAddToList
	|/echo ${Time} START: SortArray DPS
	|/echo ${DPSOn} dpson
    /if (${DPSOn}) /call SortArray DPS DPSCond 1|1 <
    /if (${BuffsOn}) /call SortArray Buffs null 100|100 >
    /if (${AggroOn}) /call SortArray Aggro AggroCond 1|1 >
    /if (${BurnSize}) /call SortArray Burn BurnCond 1|1 >
    /if (${AutoRezOn}) /call CreateTimersRez
    /if (${MezOn}) /call CreateTimersMez
    /if (!${MezImmune.Find[List up to 10 mobs]}) /call AlertAddToList 4 "${MezImmune}"
    /if (${PullLevel.Find[auto]}) {
       /varcalc PullMin ${Me.Level}-5
       /varcalc PullMax ${Me.Level}+2       
    } else /if (${PullLevel.Equal[0|0]} || ${PullLevel.Equal[0]} || ${PullLevel.Equal[null]} || !${PullLevel.Find[|]}) {
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    } else {
       /varset PullMin ${PullLevel.Left[${Math.Calc[${PullLevel.Find[|]}-1]}]}
       /varset PullMax ${PullLevel.Right[${Math.Calc[${PullLevel.Length}-${PullLevel.Find[|]}]}]} 
    }
    /if (${PullMin}>${PullMax} || ${PullMin}==0 || ${PullMax}==0) {
       /echo Invalid Pull Level Settings resetting to default.
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    }
	/echo ${Time} START: Checking your ini file for errors
    /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) {
        |/echo Checking your KissAssist_Buffs ini file for errors. 
        /call ScanIni
    }
	/if (${Macro.Params}) {
		/call PParse 1 ${NumParams}
	}
	/if ((${Role.Find[pull]} && ${paramStartCheck.Find[pull]}) || (${Role.Find[hunter]} && ${paramStartCheck.Find[hunter]})) {
        /if (${customMaxRadius} != 0) {
            /echo Setting MaxRadius to the custom value of ${MaxRadius} | ${customMaxRadius}
            /varset MaxRadius ${customMaxRadius}
        }
    }
    /if (${GMailOn}) /call GmailIniParse
	/if (${AdvPath.Following}) /afollow off
	|/echo [${Time}] Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
| Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
    /if (${ParseDPSTimer}>=1) {
		/if (${MuleDebug}) /echo Targeting a mob 15a
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
        /if (${DPSOn}) /varset DPSOn 2
        /varset Role Tank
        /call Bind_AssignMainAssist
        /call CheckRoles
        /call CheckBuffs
        /call Bind_Parse ${ParseDPSTimer}
    }
	/if (!${MainAssist.Length}) {
		|Make pet if it isn't up already !!!!
		/if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && !${Me.Pet.ID}) {
			/echo My role is (${Role}), but I have no active pet.
			/echo Making my pet so I can assign it as Main Assist!
			/call DoPetStuff
		}
		/if (!${Target.ID} && ${Select[${Role},tank,pullertank,hunter]}) {
			/if (${MuleDebug}) /echo Targeting a mob 15b
			/target id ${Me.ID}
			/delay 10 ${Target.ID}==${Me.ID}
		}
		/if ((!${Target.ID} || ${Target.ID}!=${Me.ID}) && ${Select[${Role},pettank,pullerpettank,hunterpettank]}) {
			/if (${MuleDebug}) /echo Targeting a mob 15c
			/target id ${Me.ID}
			/delay 10 ${Target.ID}==${Me.ID}
		}
		/call Bind_AssignMainAssist
    } else /if (${MainAssist.Length}) {
        DEBUGN ${MainAssist}"
		/if (${Spawn[=${MainAssist}].ID}) {
			/if (${MuleDebug}) /echo Targeting a mob 15d
			/target id ${Spawn[=${MainAssist}].ID}
			DEBUGN targeting ${Spawn[=${MainAssist}].ID}"
			/delay 10 ${Target.ID}==${Spawn[=${MainAssist}].ID}
			| Target PC instead of familiar or pet
			/if (${Spawn[=${MainAssist}].Type.Equal[Pet]} && !${MainAssist.Find[`s]}) {
				/if (${MuleDebug}) /echo Targeting a mob 15e
				/tar pc ${MainAssist}
				/delay 10 ${Target.ID}==${Spawn[=${MainAssist} pc].ID}
			}
		}
        /call Bind_AssignMainAssist
    }
    /if ((!${Target.ID} || ${Target.CleanName.NotEqual[${Me.CleanName}]}) && ${Select[${Role},hunter,pullertank]}) {
		/if (${MuleDebug}) /echo Targeting a mob 15f
		/target id ${Me.ID}
		/delay 10 ${Target.ID}==${Me.ID}
    }
    | Targeted myself end macro
    /if (${Target.CleanName.Equal[${Me.CleanName}]} && (${Role.Equal[assist]} || ${Role.Equal[puller]})) {
        /echo ERROR: You cannot assist yourself! Please target Main Tank and restart macro.
        ||/beep
        /end
    }
    | Error control no tank selected end macro
    /if (!${Target.ID} || !${Select[${Target.Type},Mercenary,PC,Pet]} || ${Me.Type.Equal[corpse]}) {
        /echo ERROR: You have >> ${Target.CleanName} << targeted. Please target a Mercenary, PC or Pet for Main Tank and restart the macro.
        ||/beep
        /end
    }
	/squelch /mapfilter TargetRadius
    /call CheckRoles
    /echo ================================
    /echo Redguides presents
    /if (${LastModBy.NotEqual[NULL]}) {
    	/echo MuleAssist v.${MacroVer} mod by ${LastModBy}
    	/popup MuleAssist v.${MacroVer} mod by ${LastModBy}
    }
    /echo ================================
    /doevents
    /if (${Select[${Role},tank]}) {
        /if (${MainAssist.Equal[${Me}]}) {
            /echo I am Tanking & Main Assist
        } else {
           /echo  I am Tank & MuleAssisting >> the ${Spawn[=${MainAssist}].Class} <<
        }
    } else /if (${Select[${Role},puller]}) {
        /echo I am Puller. MuleAssisting >> the ${Spawn[=${MainAssist}].Class} << at ${AssistAt}%
		/squelch /mapfilter TargetRadius ${MaxRadius}
        /if (${ChainPull}) /echo  What? I have to chain pull now.
    } else /if (${Select[${Role},pullertank]}) {
        /echo I am Puller & Tank.
    | PetTank set role
    } else /if (${Select[${Role},pettank]}) {
        /echo My Pet is Tanking & MuleAssisting >> the ${Spawn[=${MainAssist}].Class} <<
    | PullerPetTank set role
    } else /if (${Select[${Role},pullerpettank]}) {
        /echo I am Pulling & my Pet is Tanking.
        /echo We are all doomed.
        /delay 1s
        /echo DOOMED!
    | HunterPetTank set role
    } else /if (${Select[${Role},hunterpettank]}) {
        /echo I am Hunting & my Pet is Tanking.       
    } else /if (${Select[${Role},hunter]}) {
        /echo I am Hunting.
    } else {
        /echo MuleAssisting ${MainAssistType} >> the ${Spawn[=${MainAssist}].Class} << at ${AssistAt}%
    }
	/if (${Select[${Role},puller,pullertank]} && ${Float[${PullArcWidth}]} > 0) {
		/call SetPullAngles ${Me.Heading.Degrees} ${Float[${PullArcWidth}]} 1
        /echo Pulling an Area starting from the Left at ${PullLSide} degrees ending at ${PullRSide} degrees. 
        |/echo Reverse Pulling an Area starting from the Left at ${RPullLSide} degrees ending at ${RPullRSide} degrees. 
    }
    | If I am group leader set Main Assist Tag for Group Check for pet and make master MainAssist
    /if (${Select[${Me},${Group.Leader}]} && (${Spawn[group ${MainAssist}].ID} || (${Spawn[=${MainAssist}].Type.Equal[pet]} && ${Spawn[group ${Spawn[=${MainAssist}].Master.CleanName}].ID}))) { 
        | If Main Assist is someone else than who its suppose to be unset Group tag
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
        /if (!${Group.MainAssist.Name.Length}) {
            /if (${Spawn[=${MainAssist}].Type.Equal[pet]}) {
                /call BroadCast r "Assigning ${Spawn[=${MainAssist}].Master.CleanName} as Main Assist in Group Window"
                /call AssignGroupRole set "${Spawn[=${MainAssist}].Master.CleanName}" 2
            } else {
				/call BroadCast r "Assigning ${MainAssist} as Main Assist in Group Window"
				/call AssignGroupRole set "${MainAssist}" 2
            }
        }
    } else /if (${Select[${Me},${Group.Leader}]}) {
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
    }
	/if (${MuleDebug}) /echo clearing target 1
    /squelch /target clear
    /if (${Role.Find[pull]} || ${Role.Find[hunter]} ) {
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
            /call BroadCast r "PULL: Path >> ${PullPath} <<  found with ${PullPathWpCount} waypoints."
            /call BroadCast r "PULL: Using MQ2AdvPath to Pull"
        } else /if (${mq2navloaded}) {
			/if (${Navigation.MeshLoaded} && ${UseNav} ) {
            	| Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
            	/varset PullMoveUse nav
            	/call BroadCast r "PULL: The MQ2Nav mesh for ${Zone} is loaded"
            	/call BroadCast r "PULL: Using MQ2Nav to Pull"
			}
        }    
    }    
    /if (${LoadSpellSet}) /call LoadSpellSet
    /call WinTitle
	|Lemons: If XTarHeal is on, then we want to check and see if one of the slots is our MainAssist and set the MainAssistXTar equal to that slot number
	/declare MainAssistXTar int outer 0
	/if (${Int[${XTarHeal}]}) {
		/for n 1 to ${Math.Calc[${XTarHeal.Count[|]} + 1]}
			/if (${Me.XTarget[${XTarHeal.Arg[${n},|]}].ID} == ${Spawn[${MainAssist}].ID}) {
				/varset MainAssistXTar ${XTarHeal.Arg[${n},|]}
				/break
			}
		/next n
	/echo XTarHealing is on with ${XTarHeal}, MainAssist is ${MainAssistXTar} if set, these are a list of all your XTar slots in your window. NULL is OK. | ${Me.XTarget[1]}, ${Me.XTarget[2]}, ${Me.XTarget[3]}, ${Me.XTarget[4]}, ${Me.XTarget[5]}, ${Me.XTarget[6]}, ${Me.XTarget[7]}, ${Me.XTarget[8]}, ${Me.XTarget[9]}, ${Me.XTarget[10]}, ${Me.XTarget[11]}, ${Me.XTarget[12]}, ${Me.XTarget[13]}
	}
	/declare ChaseName				string		outer		${MainAssist}
	/call Cleanup
	|/lua run lib\lemons\lemontarget
	/if (${Lua.Script[muleassist/lemonassist].Status.Equal[RUNNING]}) {
		/lua stop ../macros/muleassist/lemonassist
		/delay 2s ${Lua.Script[muleassist/lemonassist].Status.NotEqual[RUNNING]}
	}
	/lua run ../macros/muleassist/lemonassist
	/delay 2s ${Lua.Script[muleassist/lemonassist].Status.Equal[RUNNING]}
	/lassist
	|Small delay to set pull arc width etc
	/for n 1 to ${Math.Calc[${OnStart.Count[|]}+1]}
		/if (${OnStart.Arg[${n},|].Find[lua]}) {
			/if (!${Select[${OnStart.Arg[${n},|]},NULL,""," ",]} && !${Lua.Script[${OnStart.Arg[${n},|].Right[8]}].Status.Equal[RUNNING]}) {
				/echo \aw Doing OnStart command \ar${OnStart.Arg[${n},|]}
				/docommand /${OnStart.Arg[${n},|]}
			}
		} else {
			/if (!${Select[${OnStart.Arg[${n},|]},NULL,""," ",]}) {
				/echo \aw Doing OnStart command \ar${OnStart.Arg[${n},|]}
				/docommand /${OnStart.Arg[${n},|]}
			}
		}
	/next n
	/if (${Role.Find[Puller]}) /delay 2s
	/if (${CheerPeople}) /popup Warning! You have CheerPeople=1. I'm gonna send a tell to every person who gets a broadcast kill message
| -------------------------------------------------------------------------------------
| Main Loop
| -------------------------------------------------------------------------------------

        :MainLoop
            /doevents
			/if (${Me.Combat}) /attack off
            /if (${ChainPull}!=2) {
                /call CampfireBack
                /if (${AFKToolsOn}) /call AFKTools
                /call CheckForCombat 1 MainLoop
                /if (${AEOn}) /call AECheck
                /if (${MezOn}) /call DoMezStuff
                /call WriteDebuffs
                /if (${HealsOn}) /call CheckHealth
                /if (${CuresOn}) /call CheckCures
                /if (${Me.CombatState.NotEqual[COMBAT]}) {
					/call DoWeMove MainLoop
				}
                /if (${AutoRezOn}) /call RezCheck
                /if (${CampfireOn} && ${Me.CombatState.NotEqual[COMBAT]}) /call Campfire
                /call DoMiscStuff
                /call CanIDoStuff
                /if (${MercOn}) /call MercsDoWhat
                /call CastMana
                /if (${PetOn} || ${Me.Pet.ID} && ${Me.Pet.CleanName.NotEqual[${Me.Name}`s familiar]}) {
					/call DoPetStuff
					/call CheckPetBuffs
				}
                /if (${Me.CombatState.NotEqual[COMBAT]}) {
                    /call WriteBuffs
                    /call WriteBuffsMerc
                    /call WriteBuffsPet
                }
                /if (${BuffsOn}) /call CheckBuffs
                /if (${IAmABard}) /call DoBardStuff
                /if (${Me.CombatState.NotEqual[COMBAT]}) {
					/if (${MedOn}) /call DoWeMed
				}
                /if (${Me.CombatState.NotEqual[COMBAT]}) {
					/if (${GroupWatchOn}) /call GroupWatch
				}
			}
			/if (${RogCorpseRetrieval}) /call RogDragging
			/if (${MapTheZone}) /call ZoneMap FALSE
			|Lemons: I can't figure out why CombatStart isn't getting reset to 0 in that sub, so we need to reset it here if no mobs on Xtarget. If you can fix it elsewhere, we can remove this.
			|I might have fixed it.
			|/if (${XAssist.XTFullHaterCount} && !${Me.CombatState.Equal[COMBAT]}) /varset CombatStart 0

			
            /if (${ChainPull}==2) /call AFKTools
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) /call FindMobToPull 1
            /if (${DPSOn} || ${MeleeOn}) {
                /call CheckForCombat 0 MainLoop
            } else {
                /call CheckForCombat 2 MainLoop
            }
            /if (${LootOn}) /call LootStuff
            /delay 1
			/if (${OhShitOn}) {
				/call OhShitStuff "MainLoop"
			}
			/if (${MainAssistID} != ${Spawn[${MainAssist}].ID} && ${Spawn[${MainAssist}].ID}) /varset MainAssistID ${Spawn[${MainAssist}].ID}
        /goto :MainLoop

:OnExit
	/echo running OnExit 
	/stick set verbflags 33554431
	/stick set autosave on
	/end
/return
| -------------------------------------------------------------------------------------
| SUB: PParse Parse passed command line parameters
| -------------------------------------------------------------------------------------    
Sub PParse(int iniLoaded, int nump)
    /declare i int local 0
    /declare j int local 0
    /declare k int local 0
    /declare TempPathX float local 0
    /declare TempPathY float local 0
    /declare TempPathZ float local 0
    /declare ipa int local 0
    /declare ipb int local 0
	/declare anonini string local
    /for i 0 to ${nump}
        /if (${Defined[PParam${i}]}) {
            DEBUGN PParse Enter:  Defined[IniFileName] =  ${Defined[IniFileName]} ${Defined[PParam${i}]} #${i} PParam${i} = ${PParam${i}} PParam${i} Length = ${PParam${i}.Length} is PParam${i} equal ma? ${PParam${i}.Equal[ma]}  ${Int[${PParam${i}}]}"
			/varcalc ipa ${i}+1
            /varcalc ipb ${i}-1
            /if (${PParam${i}.Equal[ini]} && ${Defined[IniFileName]}) {
				|/echo LemonsDebug: (${PParam${i}.Equal[ini]} && ${Defined[IniFileName]}), FullIniLine: ${FullIniLine}
                /varset IniFileName ${FullIniLine}
				/varset anonini ${IniFileName.Replace[${Me},${Me.Class}]}
				/varset anonini ${anonini.Replace[${EverQuest.Server},server]}
                /echo Ini file has been set to >> ${anonini} << (anon)
                /varset PIniSet 1
            }
			/if (${i} >= ${inistart} && ${i} <= ${iniend} && ${iniend}) {
				|/echo LemonsDebug: Next i in PParse because we're on a parameter which is part of the ini (${i} >= ${inistart} && ${i} <= ${iniend})
				/continue
			}
            /if (${Select[${PParam${i}},assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank]} && ${Defined[Role]}) /varset Role ${PParam${i}}
            /if (${PParam${i}.Equal[ma]} && ${Defined[MainAssist]}) {
				/if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
				/varset MainAssist ${PParam${ipa}}
			}
            /if (${Select[${PParam${i}},ini,parse,assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank]}==0 && ${Int[${PParam${i}}]}==0) {
				/if (!${PParam${i}.Find[.ini]} && !${PParam${i}.Find[Muleassist]} && !${PParam${i}.Find[${EverQuest.Server}]} && ${Defined[MainAssist]}) {
					/echo im setting mainassist to the ${Spawn[=${PParam${i}}].Class}
					/varset MainAssist ${PParam${i}}
				}
			}
			/if (${PParam${i}.Equal[assistat]} && ${Defined[AssistAt]}) {
				/if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
				/varset AssistAt ${PParam${ipa}}
			}
            /if (${Defined[PParam${ipb}]}) {
				/if (${PParam${ipb}.NotEqual[parse]}) {
					/if (${Int[${PParam${i}}]} >= 1 && ${Int[${PParam${i}}]} <= 100 && ${Defined[AssistAt]}) {
						/varset AssistAt ${PParam${i}}
					}
				}
			}
			/if (${Defined[PullPathWpCount]}) {
				/if (${PParam${i}.Equal[path]} && ${Defined[PullPath]}) {
                    /call CheckPlugin MQ2AdvPath
					/varset mq2advpathloaded 1
                    /delay 20 ${AdvPath.State}
        	        | Play path on pause to load info . Only way we can grab info from advpath
        	        /if (${AdvPath.PathList[${PParam${ipa}}]}) {
        				/play ${PParam${ipa}} pause
        				/varset PullPath ${PParam${ipa}}
        				/delay 1s
        				| Set PullPathWpCount with total amount of waypoints in path
        				/varset PullPathWpCount ${AdvPath.Waypoints}    
        				| Load path points into array
        				/for k 1 to ${PullPathWpCount} 
							DEBUGN PParse WP#: ${Int[${Math.Calc[${k}-1]}]}-${k} Distance Between: ${Math.Distance[${TempPathY},${TempPathX}:${AdvPath.Y[${k}]},${AdvPath.X[${k}]}]}"
							/varset PullPathArrayX[${k}] ${AdvPath.X[${k}]}
                			/varset PullPathArrayY[${k}] ${AdvPath.Y[${k}]}
                			/varset PullPathArrayZ[${k}] ${AdvPath.Z[${k}]}
                			/varset TempPathX ${PullPathArrayX[${k}]}
                			/varset TempPathY ${PullPathArrayY[${k}]}
                			/varset TempMaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
               				/if (${TempMaxRadius}>${MaxRadius}) /varset MaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
							DEBUGN PParse: WP: ${k} WPX: ${PullPathArrayX[${k}]} WPY: ${PullPathArrayY[${k}]}"
						/next k    
                        /varset TempMaxRadius ${MaxRadius}
                        /play off
                        | Tell Mule we are using MQ2advpath for pulling
                        /varset PullMoveUse advpath
                    } else {
                    	/echo Path ${PParam${ipa}} not found.
                    	/varset PullMoveUse 
                    	/varset PullPathWpCount 0
                    }
				}
            }
            /if (${PParam${i}.Equal[parse]} && ${Defined[ParseDPSTimer]}) {
				/if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
				/varset ParseDPSTimer ${PParam${ipa}}
			}
	    /if (${PParam${i}.Equal[custom]}) {
			/echo custom arg invoked. \agLine#:${Macro.CurLine}
			/varset bCallCustom 1
	    }
            /varset ipa 0
            /varset ipb 0
        }
    /next i
    /if (${Debug}) {
		|these are not set when this sub gets called first time so in practice we cant echo them...
		/if (${iniLoaded}) {
			DEBUGN PParse Leave Role: ${Role} MA:${MainAssist} AssistAt:${AssistAt} INI:${IniFileName} PullPath:${PullPath} Parse:${ParseDPSTimer}"
		} else {
			DEBUGN PParse Leave"
		}
	}
/return
| -------------------------------------------------------------------------------------
| SUB: CheckForCombat Used to help with controlling combat
| -------------------------------------------------------------------------------------
    Sub CheckForCombat(int SkipCombat, string FromWhere)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/call OhShitStuff
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        DEBUGCOMBAT CheckForCombat Enter SkipCombat: ${SkipCombat} ChainPull: ${ChainPull} Role: ${Role} ${FromWhere}"
		/if ((!${Spawn[${AssistID}].ID} || ${Spawn[${AssistID}].Type.Equal[PC]} || ${Spawn[${AssistID}].Master.Type.Equal[PC]} || ${Spawn[${AssistID}].Type.Equal[Corpse]}) && ${AssistID} != 0) /varset AssistID 0
        /if (${SkipCombat}) /goto :SkipMelee
        :CombatTop
			/if (${bCallCustom}==1) {
				/call Custom
			}
			/if (${IAmABard}) /call DoBardStuff
			/if (${BandolierOn}) {
				/call DoBandolier
			}
           /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0) ) /varset IAmDead 0
            /call MobRadar ${MeleeDistance} CheckForCombat
            |/if (${Debug}) /delay 10
            /if ((${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Hovering} || (${IAmDead} && !${AggroTargetID}) || (!${MobCount} && !${AggroTargetID}) || (!${DPSOn} && !${MeleeOn}) || (${Spawn[${AggroTargetID}].Master.ID} && ${Spawn[${AggroTargetID}].Master.Type.Equal[PC]})) {
				/if (${CombatStart} || ${Pulled}) /call CombatReset CFC1
				/return
			}
            DEBUGCOMBAT CheckForCombat: Calling Assist Begin ${If[!${SkipCombat},Normal,CheckForAdds]}"
            /call Assist
			DEBUGCOMBAT CheckForCombat: Calling Combat Begin ${If[!${SkipCombat},Normal,CheckForAdds]}"
            /call Combat
            DEBUGCOMBAT CheckForCombat: Return from Combat Assist/Combat End ${If[!${SkipCombat},Normal,CheckForAdds]}"
            /if (${ChainPull}==2) {
				/if (${CombatStart}) /call CombatReset CheckForCombat
				/return
			}
            :SkipMelee
			/if (${SkipCombat}) /call Assist
            /if (${MezOn}) {
                /varset MezBroke 0
                /doevents MezBroke
                /if (!${MezBroke}) /call DoMezStuff
            }
			/if (${OhShitOn}) {
				/call OhShitStuff "CheckForCombat1"
			}
			/doevents TankTarget
			/doevents ImDead
			/doevents MonKill
			/if (${BandolierOn}) {
				/call DoBandolier
			}
            /if (${SkipCombat}==2) {
                /if (${AggroTargetID}) {
					/if ((${PetOn} || ${Me.Pet.ID}) && ${PetCombatOn}) /call CombatPet
                    /if (${HealsOn}) /call CheckHealth
                    /if (${CuresOn}) /call CheckCures
                    /if (${AutoRezOn}) /call RezCheck
					/if (${ChaseAssist}) /call DoWeMove "CheckForCombat 1"
                    /call CastMana
                    /call WriteDebuffs
                    /goto :SkipMelee
                } else {
					/return
                }
            } 
            /call CheckForAdds CheckForCombat
            /if (${Role.Equal[tank]} || ${Role.Equal[pullertank]}) {
                | If tank is assisting puller and in chase mode
                /if (${MainAssist.NotEqual[${Me}]} && ${ChaseAssist}) {
					/call DoWeMove "CheckForCombat 1"
				}
				/if (${ReturnToCamp} && ((!${MobCount} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>5) || (${MobCount}==1 && ${AggroTargetID} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>75))) {
					/call DoWeMove "CheckForCombat 2"
				}
                /if ((${MobCount} && ${AggroTargetID} && ${Spawn[npc ${AggroTargetID}].ID} && ${Spawn[npc ${AggroTargetID}].Type.Equal[NPC]}) || ${TankTimer}) /goto :CombatTop
            }
			/if (${MainAssist.NotEqual[${Me}]} && ${ChaseAssist}) {
				/call DoWeMove "CheckForCombat 1"
				DEBUGMOVE Following while in combat?
			}
        DEBUGCOMBAT CheckForCombat MobCount: ${MobCount} AggroTargetID: ${AggroTargetID} ChainPull: ${ChainPull} (${AggroTargetID} || (${MezMobFlag} && ${MobCount})"
        /if (((${AggroTargetID} || (${MezMobFlag} && ${MobCount})) && !${ChainPull}) || (${MobCount}>1 && ${ChainPull})) /goto :CombatTop
        /if (${MobCount}==1 && ${ChainPull} && ${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}<=${ChainPullHP}) {
			/return
		}
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) {
            /if (${MainAssist.NotEqual[${Me}]}) /delay ${Math.Calc[${Math.Rand[1]}+1]}s
            /if (${MobCount}<=0) /call DoWeMove "CheckForCombat 3"
        }
        DEBUGCOMBAT CheckForCombat Exit."
    /return

| -------------------------------------------------------------------------------------
| SUB: CacheBuffs
| -------------------------------------------------------------------------------------
	Sub CacheBuffs(string searchfilter,sentFrom)
		DEBUGBUFF CacheBuff: ${searchfilter} ${sentFrom}"
		/if (!${Defined[OOGTimerArray${searchfilter}]}) {
			/declare OOGTimerArray${searchfilter} timer outer  0s
			DEBUGBUFF CacheBuff: Setting up a timer for ${searchfilter} ${Spawn[${searchfilter}]} ${OOGTimerArray${searchfilter}}"
		}
		/if (${Target.ID}==${Spawn[${searchfilter}].ID}) {
			/delay 3s ${Target.BuffsPopulated}
			/delay 3s ${Target.CachedBuffCount}!=-1
			/varset OOGTimerArray${searchfilter} ${BuffCacheingDelay}s
			DEBUGBUFF Returning from CacheBuffs because we already have ${Target.ID} targeted..."
			/return
		}
		|Lemons: CachedBuff issues, gonna make sure we always target when calling this sub. 
		|Lemons: God I hate having a toon have to constantly target someone. The behavior is so unnatural. Timer per person? So much data to store...Gonna just skip it for OOG/Beg buffing
		|Lemons: Not gonna skip for OOG anymore. If I do it will skip raid members who died etc. 
		|Lemons: Timer system...Fuck buffs and hub zones
		|/echo CacheBuff: Checking for ${searchfilter} ${Spawn[${searchfilter}].CachedBuffCount}==-1 || !${OOGTimerArray${searchfilter}}  ${Spawn[${searchfilter}]}"
		/if (${Spawn[${searchfilter}].CachedBuffCount}==-1 || !${OOGTimerArray${searchfilter}}) {
			/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
			/target id ${Spawn[${searchfilter}].ID}
			/delay 1s ${Target.ID}==${Spawn[${searchfilter}].ID}
			/delay 3s ${Target.BuffsPopulated}
			/delay 3s ${Target.CachedBuffCount}!=-1
			/if (${Select[${Spawn[${searchfilter}].Type},pc,pet]}) /varset OOGTimerArray${searchfilter} ${BuffCacheingDelay}s
			DEBUGBUFF CacheBuff: Timer:${OOGTimerArray${searchfilter}} Spawn:${Spawn[${searchfilter}]} Cached ${Target.CachedBuffCount}/${Spawn[${searchfilter}].CachedBuffCount} buffs for the ${Target} ${Spawn[${searchfilter}].Class}"
		}
		/if (${CombatStart} && !${AggroTargetID}) /call CombatReset CachedBuff
	/return

| -------------------------------------------------------------------------------------
| SUB: Assist - Get Main Tank's target
| -------------------------------------------------------------------------------------
    Sub Assist
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /if (${DMZ} && ${Me.InInstance}==FALSE) {
			DEBUGCOMBAT Assist: Leaving cause DMZ and not in an instance
			/return
		}
        /if (!${MeleeOn} && !${DPSOn} && !${MezOn} && !${Me.Pet.ID}) {
			DEBUGCOMBAT Assist: Leaving cause Melee, DPS and Mez are all off
			/return
		}
        /if (${DPSPaused}) {
			DEBUGCOMBAT Assist: Leaving cause DPS is Paused
			/return
		}
        /if (${Me.Hovering}) {
			DEBUGCOMBAT Assist: Leaving cause I'm hovering
			/return
		}
        /if (${Pulled} && ${MyTargetID} && ${MainAssist.Equal[${Me}]}) {
			DEBUGCOMBAT Assist: Leaving cause I'm the main Assist and Pulled and MyTargetID
			/return
		}
        DEBUGCOMBAT Assist Enter"
        /declare i int local 0
        /declare j int local
        /declare n int local
        /declare MostHurtMob int local 500
        /declare HighestLevelMob int local 0
        /declare ClosestMobID int local 0
        /declare MostHurtMobID int local 0
        /declare HighestLevelMobID int local 0
        /declare BlurredMobID int local 0
        /declare XTDistance float local 0
        /declare TempTargetID int local
        /declare TmpTar int local 0
        /doevents
        /call MobRadar ${MeleeDistance} Assist
		| Normal assist check		
		/if (${DebugCombat} || ${DebugDPS}) {
			DEBUGCOMBAT Assist0: ${Me} ${MainAssist} ${Spawn[=${MainAssist}].Distance} MobCount:${MobCount} AggroTID:${AggroTargetID} Target.ID:${Target.ID} MyTID:${MyTargetID}"
			/if (${UseMQ2Melee}) {
				DEBUGCOMBAT Melee=${Melee} Melee.Combat=${Me.Combat} Melee.Target=${Melee.Target} Melee.Status=${Melee.Status}"
			}
		}
		/if (${MainAssist.NotEqual[${Me}]} && (${MobCount} || ${AggroTargetID})) {
			/if (${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Distance} < 200) {
				DEBUGCOMBAT Assist1: ${Me} ${MainAssist} ${Group.MainAssist.ID} ${Spawn[=${MainAssist}].Distance} MobCount:${MobCount} AggroTID:${AggroTargetID} XTarSlot:${Me.XTarget[${XTSlot}].ID} XTarSlot2:${Me.XTarget[${XTSlot2}].ID}"
				/if (${AssistOutside}) {
					/if (${Spawn[${Spawn[=${MainAssist}].AssistName}].ID}) {
						DEBUGCOMBAT TmpTar set to ${Spawn[${Spawn[=${MainAssist}].AssistName}].ID} ${Spawn[${Spawn[=${MainAssist}].AssistName}]} \agLine#${Macro.CurLine}"
						/varset TmpTar ${Spawn[${Spawn[=${MainAssist}].AssistName}].ID}
					} else {
						|Lemons: Added because we aren't killing pets and AssistName could be set to NULL if no action has been taken yet. 15.1.1
						DEBUGCOMBAT TmpTar maybe set to ${Me.GroupAssistTarget.ID} if ${Me.GroupAssistTarget.ID} \agLine#${Macro.CurLine}"
						/if (${Me.GroupAssistTarget.ID}) /varset TmpTar ${Me.GroupAssistTarget.ID}
					}
					/if (${TmpTar}) {
						DEBUGCOMBAT We have a TmpTar"
						/if (${Spawn[${TmpTar}].Type.Equal[NPC]} || (${Spawn[${TmpTar}].Type.Equal[PET]} && ${Spawn[${TmpTar}].Master.Type.NotEqual[PC]})) {
							DEBUGCOMBAT TmpTar is an NPC or a Pet who's master isn't an PC"
							/if (${Target.ID}!=${TmpTar} && (${Spawn[${TmpTar}].Distance3D} < 200 || ${Spawn[${TmpTar}].LineOfSight})) {
								DEBUGCOMBAT Current target isn't TmpTar and it's less than 200 units away or I have LOS. "
								/echo [${Time}] Assisting ${MainAssist} FOR -> ${Spawn[=${MainAssist}].AssistName} <-
								/if (${MuleDebug}) /echo Targeting a mob 15g
								/target id ${TmpTar}
								DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
								/delay 10 ${Target.ID}==${TmpTar}
							}
						}
					}
				} else /if (${Bool[${Group.MainAssist.ID}]}==TRUE) {
					DEBUGCOMBAT There is a Group MainAssist ID"
					/if (${Me.GroupAssistTarget.ID}) {
						DEBUGCOMBAT Group Main Assist has a target which is ${Me.GroupAssistTarget.ID} ${Me.GroupAssistTarget}"
						DEBUGCOMBAT Checking if: (${Me.GroupAssistTarget.Type.Equal[NPC]} || (${Spawn[${Me.GroupAssistTarget.ID}].Type.Equal[PET]} && ${Spawn[${Me.GroupAssistTarget.ID}].Master.Type.NotEqual[PC]}))"
						/if (${Me.GroupAssistTarget.Type.Equal[NPC]} || (${Spawn[${Me.GroupAssistTarget.ID}].Type.Equal[PET]} && ${Spawn[${Me.GroupAssistTarget.ID}].Master.Type.NotEqual[PC]})) {
							DEBUGCOMBAT GroupMainAssist Target is an NPC or Pet who's master isn't a PC"
							/if (${Target.ID}!=${Me.GroupAssistTarget.ID}) {
								DEBUGCOMBAT My target isn't the Group Main Assist's target"
								/if (${MuleDebug}) /echo Targeting a mob 15h
								/target id ${Me.GroupAssistTarget.ID}
								DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
								/delay 10 ${Me.GroupAssistTarget.ID}==${Target.ID}
							}
						}
					} else {
						DEBUGCOMBAT GroupMainAssist doesn't have a target"
						/if (${Target.ID}) {
							DEBUGCOMBAT But I have a target ${Target.ID} ${Target}"
							/if (${Target.Type.Equal[NPC]} || (${Spawn[${TmpTar}].Type.Equal[PET]} && ${Spawn[${TmpTar}].Master.Type.NotEqual[PC]})) {
								DEBUGCOMBAT Target is an NPC or Pet who's master isn't a PC"
								/if (${AggroTargetID} && ${AggroTargetID}!=${Target.ID} || ${Target.Type.Equal[Corpse]}) {
									DEBUGCOMBAT I have an AggroTargetID and it's not my current target or my target is a corpse. Gonna clear target"
									/if (${MuleDebug}) /echo Target Clearing at\agLine#:${Macro.CurLine}
									/squelch /target clear
								}
							}
						}
					}
				} else /if (${Me.XTarget[1].TargetType.Equal[Specific PC]} && ${Me.XTarget[1].ID}) {
					/invoke ${Me.XTarget[1].DoAssist}
					/delay 10 ${Target.ID} == ${Me.XTarget[1].ID}
				} else {
					DEBUGCOMBAT Generic /assist on ${MainAssist}"
					/assist ${MainAssist}
					/delay 10 ${Target.ID} == ${Me.XTarget[1].ID}
				}
				| Target mob when assisting puller and they are targeting Tank
				/if (${Target.CleanName.Equal[${Me}]} && (${MobCount} || ${AggroTargetID}) && ${MyTargetID}) {
					DEBUGCOMBAT Clearing target cause I'm targeting myself with mobs around or an Aggro Target ID"
					/if (${MuleDebug}) /echo clearing target 2
					/squelch /target clear
					/if (${MuleDebug}) /echo Targeting a mob 1: ${Spawn[${AggroTargetID}]}
					/squelch /target id ${MyTargetID}
					DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
					/delay 10 ${MyTargetID}==${Target.ID}
				}
				DEBUGCOMBAT Going to validate with current target ${Target} ${Target.ID}"
				DEBUGTARGETCHOICE TargetChoice:Going to validate with current target ${Target} ${Target.ID}"
				/goto :validatetarget
				| If the tank is dead and aggro mob in camp target 1st mob on autohater in xtarget
			} else /if (!${Spawn[=${MainAssist}].ID} && ${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance} <= ${CampRadius}) {
				DEBUGCOMBAT MainAssist isn't here and we have a target within camp radius ${AggroTargetID}"
				|/echo Targeting a mob 2: ${Spawn[${AggroTargetID}]}
				/if (${Target.ID} != ${AggroTargetID}) {
					/squelch /target id ${AggroTargetID}
					DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
				}
				/delay 10 ${AggroTargetID}==${Target.ID}
				/goto :validatetarget
			}   
		}
		/if (${MainAssist.Equal[${Me}]} || ${Select[${Role},tank,pullertank,pettank,pullerpettank]} > 0) {
			DEBUGCOMBAT Assist2: MainAssist.Equal[${Me}] is ${MainAssist.Equal[${Me}]} OR my role is ${Role} MobCount = ${MobCount}"
			DEBUGTARGETCHOICE I'm the MA and need to choose a target"
			|/if (${Target.CleanName.Equal[${Me}]} && (${MobCount} || ${AggroTargetID})) {}
			/if (${Target.CleanName.Equal[${Me}]} && ${AggroTargetID}) {
				/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
				/squelch /target clear
			}
			| I am tank with a single mob wait for it then validate and attack.
			DEBUGTARGETCHOICE TargetChoice: 1 mob on XTarget check and I have an AggroTargetID: (${MobCount}==1 && (!${XTSlot2} || (${XTSlot2} && !${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID})"
			/if (${MobCount}==1 && (!${XTSlot2} || (${XTSlot2} && !${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
				DEBUGCOMBAT Assist: ${MobCount}==1 && ${AggroTargetID}"
				DEBUGTARGETCHOICE Assist: ${MobCount}==1 && ${AggroTargetID} going to validate"
				/if (${Target.ID} != ${AggroTargetID}) {
					DEBUGTARGETCHOICE TargetChoice:Targeting AggroTargetID ${AggroTargetID} ${Spawn[${AggroTargetID}]} in single target then validate"
					/if (${MuleDebug}) /echo Targeting a mob 3: ${Spawn[${AggroTargetID}]}
					/squelch /target id ${AggroTargetID}
					DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
					/delay 10 ${Target.ID}==${AggroTargetID}
					DEBUGCOMBAT Assist: Single target: ${AggroTargetID} ${Spawn[${AggroTargetID}].CleanName}"
				}
				/goto :validatetarget
			}
            | More than one mob targeting
			DEBUGTARGETCHOICE TargetChoice:More than one mob on XTarget . Pre-ClosestMobID stuff ((${MobCount} >= 2 || (${XTSlot2} && ${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID})"
            /if ((${MobCount} >= 2 || (${XTSlot2} && ${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
                | Check if named incoming an target if true else assign closest target.
                /for n 1 to ${XSlotTotal}
				DEBUGTARGETCHOICE n is ${n} for all XTarget looping. Checking is it's an AutoHate slot and it has an ID (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${n}].ID})"
                    /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${n}].ID}) {
						DEBUGTARGETCHOICE TargetChoice:XTarget slot ${n} is AutoHater and has an ID ${Me.XTarget[${n}].ID} ${Me.XTarget[${n}]}"
                        /if (${Me.XTarget[${n}].Named}) {
							DEBUGTARGETCHOICE TargetChoice:It's a named on ${n}. Targeting ${Me.XTarget[${n}].ID}"
							/if (${MuleDebug}) /echo Targeting a mob 15i
							DEBUGCOMBAT XTarget Slot ${n} is a named. Going to validate ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID}"
                            /squelch /target id ${Me.XTarget[${n}].ID}
							DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
                            /delay 10 ${Target.ID}==${Me.XTarget[${n}].ID}
                            /goto :validatetarget
                        }
                        | Tank mez immune mobs first.
						DEBUGTARGETCHOICE TargetChoice:Checking for mez immunes if we have any (${Alert[4].Size})"
                        /if (${Alert[4].Size}) {
							DEBUGTARGETCHOICE TargetChoice:Alert List 4 is populated"
                            /for j 0 to ${Alert[4].Size}
                                /if (${Alert[4].List[${j}].Name.Equal[${Me.XTarget[${n}].CleanName}]} && ${Alert[4].List[${j}].Name.Length}) {
									DEBUGTARGETCHOICE TargetChoice:Immune alert list match on ${j} ${Me.XTarget[${n}].CleanName}. Targeting it"
                                    /if (WITHINCAMP) /call BroadCast y "Grabbing MEZ Immune -> ${Me.XTarget[${n}].CleanName} <- ID:${Me.XTarget[${n}].ID}"
                                    /if (${MuleDebug}) /echo Targeting a mob 15j
                                    DEBUGCOMBAT Targeting alert list mez immune mob ${Me.XTarget[${n}].ID}
									/squelch /target id ${Me.XTarget[${n}].ID}
									DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
                                    /delay 10 ${Target.ID}==${Me.XTarget[${n}].ID}
                                    /goto :validatetarget
                                }
                            /next j
                        }
						|Lemons: Last named in the list will take priority
						DEBUGTARGETCHOICE TargetChoice:HighestLevelMob Check vs Xtarget${n} check(${HighestLevelMob} < ${Me.XTarget[${n}].Level} || ${Me.XTarget[${n}].Named})"
						DEBUGCOMBAT HighestLevelMob Check${n}: (${HighestLevelMob} < ${Me.XTarget[${n}].Level} || ${Me.XTarget[${n}].Named})"
						/if (${HighestLevelMob} < ${Me.XTarget[${n}].Level} || ${Me.XTarget[${n}].Named}) {
							DEBUGCOMBAT HighestLevelMob now set to Level ${Me.XTarget[${n}].Level} ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID} HP:${Me.XTarget[${n}].PctHPs} Named?:${Me.XTarget[${n}].Named} n:${n}"
							DEBUGTARGETCHOICE TargetChoice:HighestLevelMob now set to Level ${Me.XTarget[${n}].Level} ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID} HP:${Me.XTarget[${n}].PctHPs} Named?:${Me.XTarget[${n}].Named} n:${n}"
							/varset HighestLevelMob ${Me.XTarget[${n}].Level}
							/varset HighestLevelMobID ${Me.XTarget[${n}].ID}
						}
						DEBUGTARGETCHOICE TargetChoice:MostHurt ${n}: (${MostHurtMob} > ${Me.XTarget[${n}].PctHPs})"
						/if (${MostHurtMob} > ${Me.XTarget[${n}].PctHPs})  {
							DEBUGCOMBAT MostHurtMob now set to  ${Me.XTarget[${n}].PctHPs} ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID}  ${n}"
							DEBUGTARGETCHOICE TargetChoice:MostHurtMob now set to  ${Me.XTarget[${n}].PctHPs} ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID}  ${n}"
							/varset MostHurtMob ${Me.XTarget[${n}].PctHPs}
							/varset MostHurtMobID ${Me.XTarget[${n}].ID}
						}
						DEBUGTARGETCHOICE TargetChoice:ClosestMob ${n}:(!${ClosestMobID} && (!Pet:${Me.XTarget[${n}].Type.NotEqual[PET]} && PC:${Spawn[${Me.XTarget[${n}].Master.CleanName}].Type.NotEqual[PC]}))"
                        /if (!${ClosestMobID} && (${Me.XTarget[${n}].Type.NotEqual[PET]} && !${Spawn[${Me.XTarget[${n}].Master.CleanName}].Type.Equal[PC]})) {
							DEBUGCOMBAT ClosestMob set to ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID} ${n}"
							DEBUGTARGETCHOICE TargetChoice:ClosestMob set to ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID} ${n}"
							/varset ClosestMobID ${Me.XTarget[${n}].ID}
						}
						DEBUGTARGETCHOICE TargetChoice:Cur ClosestMob to Camp Check vs ${n} mob to camp check ${n}: (${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} >= ${Math.Distance[${Me.XTarget[${n}].Y},${Me.XTarget[${n}].X}:${CampYLoc},${CampXLoc}]})"
                        /if (${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} >= ${Math.Distance[${Me.XTarget[${n}].Y},${Me.XTarget[${n}].X}:${CampYLoc},${CampXLoc}]}) {
							|/echo Setting ClosestMobID to XTar ${n} ${Me.XTarget[${n}]} \agLine#:${Macro.CurLine}
							DEBUGCOMBAT ClosestMobID set to ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID}  ${n} Distance: ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]}"
							DEBUGTARGETCHOICE TargetChoice:ClosestMobID set to ${Me.XTarget[${n}]} ${Me.XTarget[${n}].ID}  ${n} Distance: ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]}"
							/varset ClosestMobID ${Me.XTarget[${n}].ID}
						}
                    }
                /next n
				|Lemons: Should still kill the lowest HP mob so we have less mobs in camp, even if it's higher level by a bit.
				DEBUGTARGETCHOICE Done checking all XTarget slots"
				DEBUGTARGETCHOICE TargetChoice:CID:${ClosestMobID} Spwn:${Spawn[ClosestMobID]} HID:${HighestLevelMobID} CampRad: ${CampRadius} :: (${HighestLevelMob} > ${Spawn[${ClosestMobID}].Level} && ${Spawn[${HighestLevelMobID}].Distance} <= ${CampRadius} && ${MostHurtMob} <= ${Spawn[${ClosestMobID}].PctHPs})"
				DEBUGTARGETCHOICE TargetChoice:ElseIf check is for MostHurtMob is lower hp than CID and is in camp: ${MostHurtMob} < ${Spawn[${ClosestMobID}].PctHPs} && ${Spawn[${ClosestMobID}].Distance} <= ${CampRadius} && ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} > ${Math.Distance[${Me.XTarget[${n}].Y},${Me.XTarget[${n}].X}:${CampYLoc},${CampXLoc}]})"
				DEBUGCOMBAT CID:${ClosestMobID} HID:${HighestLevelMobID} CampRad: ${CampRadius} | (${HighestLevelMob} > ${Spawn[${ClosestMobID}].Level} && ${Spawn[${HighestLevelMobID}].Distance} <= ${CampRadius} && (${MostHurtMob} <= ${Spawn[${ClosestMobID}].PctHPs} || !${ClosestMobID}))"
				/if (${HighestLevelMob} > ${Spawn[${ClosestMobID}].Level} && ${Spawn[${HighestLevelMobID}].Distance} <= ${CampRadius} && ${MostHurtMob} <= ${Spawn[${ClosestMobID}].PctHPs}) {
					|/echo picking a mob that's the highest level on xtarget for killing first \agLine#:${Macro.CurLine}
					|/delay 5
					DEBUGTARGETCHOICE TargetChoice:ClosestMobID setting to Highest ${Spawn[${HighestLevelMobID}]} cause ${HighestLevelMob} > ${Spawn[${ClosestMobID}].Level} && ${Spawn[${HighestLevelMobID}].Distance} <= ${CampRadius} && ${MostHurtMob} <= ${Spawn[${ClosestMobID}].PctHPs} \ag${Macro.CurLine}"
					DEBUGCOMBAT ClosestMobID setting to Highest ${Spawn[${HighestLevelMobID}]} cause ${HighestLevelMob} > ${Spawn[${ClosestMobID}].Level} && ${Spawn[${HighestLevelMobID}].Distance} <= ${CampRadius} && ${MostHurtMob} <= ${Spawn[${ClosestMobID}].PctHPs} \ag${Macro.CurLine}"
					/varset ClosestMobID ${HighestLevelMobID}
				} else /if (${MostHurtMob} < ${Spawn[${ClosestMobID}].PctHPs} && ${Spawn[${ClosestMobID}].Distance} <= ${CampRadius} && ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} > ${Math.Distance[${Me.XTarget[${n}].Y},${Me.XTarget[${n}].X}:${CampYLoc},${CampXLoc}]}) {
					DEBUGTARGETCHOICE TargetChoice:MostHurtMob ${MostHurtMob} is in camp and lower HP than CID so we gonna kill it instead. Info from ElseIf line above"
					/echo all mobs are fine to kill, but lets do the one with lowest hp first that's in camp radius
					/varset ClosestMobID ${MostHurtMobID}
				}
                | Don't need to target mob on incoming and out of meleedistance'
				|Lemons: Why not? It's on XTarget...
				DEBUGTARGETCHOICE TargetChoice:Targeting ClosestMobID: (( (${Target.ID}!=${ClosestMobID} && ${MobCount}) || (!${Target.ID} && ${AggroTargetID}) ) && ${ClosestMobID}) Type: ${Spawn[${ClosestMobID}]} ${Spawn[${ClosestMobID}].Type}"
                /if (( (${Target.ID}!=${ClosestMobID} && ${MobCount}) || (!${Target.ID} && ${AggroTargetID}) ) && ${ClosestMobID}) {
					DEBUGTARGETCHOICE Is closest mob ID not a corpse? (${Spawn[${ClosestMobID}].Type.NotEqual[Corpse]})"
					/if (${Spawn[${ClosestMobID}].Type.NotEqual[Corpse]}) {
						/squelch /target id ${ClosestMobID}
						DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target} ${Target.ID} comapred to CID of ${ClosestMobID}"
					}
					DEBUGTARGETCHOICE TargetChoice:Doing the target on ClosestMobID
					DEBUGCOMBAT Targeting ClosestMobID ${Spawn[${ClosestMobID}]} CID:${ClosestMobID} TID:${Target.ID} and MobCount:${MobCount}"
                    /if (${MuleDebug}) /echo Targeting a mob 4: ${Spawn[${ClosestMobID}]} ${ClosestMobID} curTar:${Target.ID}
                    /delay 10 ${Target.ID}==${ClosestMobID}
                }
				DEBUGTARGETCHOICE Going to Validate: ClosestMobID: ${ClosestMobID} Distance: ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} XTarget[${XTSlot2}] XID: ${Me.XTarget[${XTSlot2}].ID} Distance: ${Math.Distance[${Me.XTarget[${XTSlot2}].Y},${Me.XTarget[${XTSlot2}].X}:${CampYLoc},${CampXLoc}]} AgroTargetID: ${AggroTargetID}"
				DEBUGCOMBAT ClosestMobID: ${ClosestMobID} Distance: ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} XTarget[${XTSlot2}] XID: ${Me.XTarget[${XTSlot2}].ID} Distance: ${Math.Distance[${Me.XTarget[${XTSlot2}].Y},${Me.XTarget[${XTSlot2}].X}:${CampYLoc},${CampXLoc}]} AgroTargetID: ${AggroTargetID}"
				/goto :validatetarget
			}
            | Check for memblurred mobs in camp when nothing left on xtarget. Check only for 5 secs after last mob.
            /if (${CheckForMemblurredMobsInCamp}) {
                DEBUGCOMBAT Assist3: ${AggroTargetID} ${MobCount} ${MezMobFlag}"
	            /if (!${AggroTargetID} && ${MobCount} && ${MezMobFlag}==1) {
	                /varset BlurredMobID ${NearestSpawn[1,npc targetable los radius ${MeleeDistance} zradius 50 noalert 3].ID}
	                DEBUGCOMBAT Assist4: ${BlurredMobID} ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]} ${MeleeDistance}"
	                /if (${BlurredMobID} && ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]} < ${MeleeDistance}) {
						/call CacheBuffs ${BlurredMobID}
						/if (${Spawn[${BlurredMobID}].CachedBuff[^Mezzed].Duration} > 0) {
							/call BroadCast y "Found Mezzed Mob: ${Spawn[${BlurredMobID}].CleanName} <- ID:${BlurredMobID}"
							/echo MEZ >> Found a Mezzed mob in Camp. <<
							/varset AggroTargetID2 ${BlurredMobID}
							/varset MyTargetID ${Target.ID}
							|/ltar
							/varset MyTargetName ${Target.CleanName}
							/varset MTIDSetAt ${Macro.CurLine}
	                    }
	                    /return
	                }
	            }
			}
            /varset MezMobFlag 0
        }
        :validatetarget
		DEBUGTARGETCHOICE TargetChoice:Validatetarget with ClosestMobID ${ClosestMobID} ${Spawn[${ClosestMobID}]} ${Spawn[${ClosestMobID}].Distance} ${Spawn[${ClosestMobID}].Named} Target ${Target} TID:${Target.ID}"
        DEBUGCOMBAT Assist: validatetarget ID:${Target.ID} ${Target}"
        /if (!${Target.ID}) {
            DEBUGCOMBAT Assist: Validate Target - No target return"
			DEBUGTARGETCHOICE TargetChoice:No Target in Validate"
            /return
        }
        /varset TempTargetID ${Target.ID}
		|/echo Going to validate ${Target} \agLine#:${Macro.CurLine}
        /call ValidateTarget
		DEBUGTARGETCHOICE TargetChoice:ValidateTarget return is Assist Target:${Target.CleanName} ${Target.ID} ValidTarget:${ValidTarget} Marco Return:${Macro.Return}"
        | If target is not valid return
        DEBUGCOMBAT Validate Return Assist Target:${Target.CleanName} ${Target.ID} ValidTarget:${ValidTarget} Marco Return:${Macro.Return}"
        /if (${ValidTarget}==0) {
			DEBUGCOMBAT Target is not valid:${Macro.Return} at\agLine#:${Macro.CurLine}"
			DEBUGTARGETCHOICE TargetChoice:Target is not valid:${Macro.Return} ${Target} ${Target.ID} setting MyTargetID to 0"
            /squelch /alert add 2 id ${Spawn[${Target.CleanName}].ID}
            /varset MyTargetID 0
			/varset MTIDSetAt ${Macro.CurLine}
            /varset MyTargetName
            /return
        }
        /if (${ValidTarget}) {
			DEBUGCOMBAT Target is valid ${Target} ${Target.ID}"
			DEBUGTARGETCHOICE TargetChoice:Target is valid ${Target} ${Target.ID}"
            /if (${Target.ID}!=${TempTargetID}) {
				DEBUGCOMBAT Targeting the valid mob ${TempTargetID} ${Spawn[${TempTargetID}]}. CUrrent target is ${Target} ${Target.ID}"
				DEBUGTARGETCHOICE TargetChoice:Targeting the valid mob ${TempTargetID} ${Spawn[${TempTargetID}]}. CUrrent target is ${Target} ${Target.ID}. ClosestMob is ${ClosestMobID} ${Spawn[${ClosestMobID}]}"
				/if (${MuleDebug}) /echo Targeting a mob 6: ${Spawn[${TempTargetID}]}
				/target id ${TempTargetID}
				DEBUGTARGETCHOICE TargetChoice: Targeting a ${Target}"
				/delay 10 ${Target.ID}==${TempTargetID}
            }
			DEBUGCOMBAT Setting MyTargetID to ${Target.ID} which is ${Spawn[${Target.ID}]}"
			DEBUGTARGETCHOICE TargetChoice:Setting MyTargetID to ${Target.ID} which is ${Spawn[${Target.ID}]}"
			|/echo LemonsDebug: Setting MyTargetID to ${Target.ID} which is ${Spawn[${Target.ID}]}
			/varset MyTargetID ${Target.ID}
			|/ltar
			/varset MTIDSetAt ${Macro.CurLine}
			/varset MyTargetName ${Target.CleanName}
			/if (${Target.ID} != ${MyTargetID} && ${MyTargetID}) {
				/target id ${MyTargetID}
				DEBUGTARGETCHOICE Targeting ${MyTargetID}"
			}
			/if (${MoveCloserIfNoLOS} && ${Navigation.MeshLoaded} && ${UseNav} ) {
				/if (${Target.ID}==${Me.GroupAssistTarget.ID} && ${Group.MainAssist.ID}!=${Me.ID}) {
					/if (!${Target.LineOfSight}) {
						/if (${Spawn[=${MainAssist}].Distance3D} < 150 && ${Target.Distance3D} < 150) {
							/if (${Target.PctHPs} < 90) {
								/if (${Navigation.PathExists[id ${Target.ID}]}==TRUE) {
									|/beep
									|/call BCTExec ${Spawn[=${MainAssist}].Name} "/popup ${Me.Class} Needs to move closer in Assist"
									/echo I cant see the mob lets move closer (ValidTarget)
									|/call Bind_ToggleVariable ReturnToCamp off
									|/call Bind_ToggleVariable ChaseAssist off
        							/if (${MoveTo.Moving}) /moveto off
									/if (${Stick.Active}) /squelch /stick off
									/if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.State}) {
										/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
										/play off
 									}
									/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
				   					/nav spawn id ${Spawn[=${MainAssist}].ID} | dist=10
									/delay 1s ${Navigation.Active}==TRUE
									/delay 5s ${Navigation.Active}==FALSE
								}
							}
						}
					}
				}
			}
        }
		DEBUGTARGETCHOICE TargetChoice:Done with Target Selection"
        DEBUGCOMBAT Assist MyTargetName:${MyTargetName} ID:${MyTargetID}"
        DEBUGCOMBAT Assist Leave"
    /return   
| -------------------------------------------------------------------------------------
| SUB: Validate Target Combined Spawn and Target
| -------------------------------------------------------------------------------------
    Sub ValidateTarget(int SpawnID, int pull_flag)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        DEBUGCOMBAT ValidateTarget Enter Target Name:${Target.CleanName} ID:${Target.ID} Spawn Name: ${Spawn[${SpawnID}].CleanName} ID:${SpawnID}"
        /declare i int local 0
        /declare j int local
        /declare k int local
        /declare n int local
        /declare XTValid int local 0
        /declare PullValid int local 0
        /declare MobID int local 0
        /declare MobName string local
        /declare MobType string local        
        /varset ValidTarget 0
        /if (${SpawnID}) {
           /varset MobID ${Spawn[${SpawnID}].ID}
           /varset MobName ${Spawn[${SpawnID}].CleanName}
           /varset MobType ${Spawn[${SpawnID}].Type}
        } else {
           /varset MobID ${Target.ID}
           /varset MobName ${Target.CleanName}
           /varset MobType ${Target.Type}
        }
        /if (!${MobID}) {
			/echo No Valid MobID to validate in ${Macro.CurSub} so returning. \agLine#:${Macro.CurLine}
			/return NoTarget
		}
        DEBUGCOMBAT ValidateTarget ${Select[${MobType},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,TRIGGER,TRAP,TIMER,MOUNT,Mercenary]} Validate 1, Mob is a valid type"
        /if (${Select[${MobType},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,TRIGGER,TRAP,TIMER,MOUNT,Mercenary]}) {
			/return BadTargetType
		}
        DEBUGCOMBAT ValidateTarget On Ignore List and XTarget? ${MobsToIgnore.Find[${MobName}]} && ${Select[${MobID},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]} Validate 2"
        | If mob found on ignore and not on xtarget skip
        /if (${MobsToIgnore.Find[${MobName}]} && ${Select[${MobID},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) {
			/return MobOnIgnoreList
		}
        | MOb was charmed and I can't attack 'friendly' pets.
        /if (${Spawn[${MobID}].Type.Equal[pet]} && (${Spawn[${Spawn[${MobID}].Master.ID}].Type.Equal[PC]} || ${Spawn[${Spawn[${MobID}].Master.ID}].Type.Equal[PC]})) {
			DEBUGCOMBAT Mob must have been charmed. Can't attack it"
			/return MobIsFriendlyPet
		}
        | Check if target is somewhere on my extended target.        
        /if (${Select[${Role},tank]} && ${pull_flag}!=3) {
			/if (${MobCount} <= ${XSlotTotal} && ${Spawn[=${MainAssist} ${MainAssistType} group].ID}) {
				/for n 1 to ${XSlotTotal}
					/if (${MobID}==${Me.XTarget[${n}].ID}) {
						/varset XTValid 1
						/goto :XTValidSkip
					}
				/next n
				:XTValidSkip
				/if (!${XTValid}) {
					/return NotOnXTarget
				}
			}
        }
		|Lemons: WTF is this line? If you're the tank, but definitely not if you're the tank? This is probably why it fails at handling mobs out of camp radius. "&& !${AggroOn} && !${MainAssist.NotEqual[${Me}]} && !${Select[${Role},Tank]}"|||&& (${Spawn[${MobID}].Speed} == 0 && ${Spawn[${MobID}].Distance} > 16)  
		DEBUGCOMBAT ValidateTarget ${Spawn[${MobID}].Distance}>${MeleeDistance} && !${Pulling} && ${Select[${Role},tank,pullertank,pettank,pullerpettank]} OutofCampRadius"
        /if (${Spawn[${MobID}].Distance}>${MeleeDistance} && !${Pulling} && ${Select[${Role},tank,pullertank,pettank,pullerpettank]}) {
			DEBUGCOMBAT Mob is outside of MeleeDistance. Checking if the mob is moving and within 30% of it's MaxTo relative to it's target.  (!${Spawn[${MobID}].Speed} && ${Spawn[${MobID}].Distance} <= ${Math.Calc[(${Spawn[${MobID}].MaxRangeTo} + ${Spawn[${Spawn[${MobID}].AssistName}].Distance}) *1.3]})"
			/if (!${Spawn[${MobID}].Speed} && ${Spawn[${MobID}].Distance} <= ${Math.Calc[(${Spawn[${MobID}].MaxRangeTo} + ${Spawn[${Spawn[${MobID}].AssistName}].Distance}) *1.3]}) {
				DEBUGCOMBAT Mob is within 130% of max range of it's target and isn't moving, so they probably have long arms and are beating on someone. Let's kill it"
			} else {
				DEBUGCOMBAT Mob is out of MeleeDistance ${MeleeDistance} at ${Spawn[${MobID}].Distance}ft."
				/return OutofCampRadius
			}
		}
        DEBUGCOMBAT ValidateTarget Initial checks done, now pulling"
        | Only valid when pulling
        /if (${Pulling} && !${Pulled} ) {
			/if (${If[${PrePullCond},0,1]}) {
				/echo PrePullCond is False. Not starting pull
				DEBUGPULL PrePullCond is false"
				/return PrePullCondBad
			}
            /if ((!${PullPathWpCount} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) {
				/return OutofRadius
			}
            /if (${Select[${Role},puller,pullertank,pullerpettank]} || ${pull_flag}==3) {
				/if (!${Spawn[${MobID}].LineOfSight} && !${PullPathWpCount}) {
					/if (${mq2navloaded}) {
						/if (!${Navigation.MeshLoaded} && ${UseNav} ) {
							/return NoLOS
						}
					} else {
						/return NoLOS
					}
				}
			}         
			/if (${SpawnCount[loc ${Spawn[${MobID}].Y} ${Spawn[${MobID}].X} radius 20 pc]} >= 1 && ${Pulling} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${Me.Y},${Me.X}]} >= 16) {
				/return PCNear
			}
			/if (${Spawn[${MobID}].PctHPs} <= 99 && ${Spawn[${MobID}].Type.NotEqual[CORPSE]}) {
				/if (${Target.ID}!=${MobID}) {
					/if (${MuleDebug}) /echo NEED TO TARGET TO CHECK HPs
					/if (${Target.ID}) {
						/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
						/squelch /target clear
						/delay 1s ${Target.BuffsPopulated}==FALSE
					}
					/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
					/target id ${MobID}
					/delay 1s ${Target.ID}==${MobID}
					/delay 1s ${Target.BuffsPopulated}
					/delay 1s ${Target.CachedBuffCount}!=-1
					/if (${Spawn[${MobID}].PctHPs} <= 99) {
						/return PullNotFullHealth
					}
					/if (${Me.TargetOfTarget.ID}) {
						/return PCNear
					}
				}
			}
			/if (${Spawn[${MobID}].Level} < ${PullMin} || ${Spawn[${MobID}].Level} > ${PullMax}) {
				/return BadLevel
			}
			/if (${Target.ID}==${MobID}) {
				| - If mob I'm pulling is aggroed already by non damaging spell by someone else.
				|/delay 1
				/if (${Me.TargetOfTarget.Type.Equal[PC]} && ${Me.TargetOfTarget.Name.NotEqual[${Me}]} && ${Group.Member[${Me.TargetOfTarget.Name}].Index}<1) {
					/return PullToTTNotPuller
				}
				/if (${Me.TargetOfTarget.Type.Equal[PET]} && ${Me.TargetOfTarget.Name.NotEqual[${Me.Pet.CleanName}]}) {
					/return PullToTTNotMyPet
				}
				|/echo mob is not agroed by anyone else so all good \agLine#:${Macro.CurLine}
			}
			/if (${MobsToPull.Find[null]}) DEBUGPULL ValidateTarget ${MobsToPull} \agLine#:${Macro.CurLine}"
			/if (${MobsToPull.Find[ALL for all]} || ${MobsToPull.Equal[ALL]}  || ${MobsToPull.Equal[NULL]}) {
				/goto :SkipPullValidate
			}
			/for j 1 to 25
				DEBUGPULL ValidateTarget ${j} ${MobsToPull.Arg[${j},,]} ${MobName.Find[${MobsToPull.Arg[${j},,]}]}"
				/if (${MobName.Find[${MobsToPull.Arg[${j},,]}]}) {
					/varset PullValid 1
					/echo Skipping validate because ${MobName} has ${MobsToPull.Arg[${j},,]} in it. \agLine#:${Macro.CurLine}
					/goto :SkipPullValidate
				}
			/next j
			/if (!${PullValid}) {
	    		/if (${MobsToPullSecondary.NotEqual[NULL]}) {
					/if (${MuleDebug}) /echo ok so we dont have anything to pull, but the user specified some
					|mobs to pull if everything else is down...
					/for j 1 to 25
						DEBUGPULL ValidateTarget ${j} ${MobsToPullSecondary.Arg[${j},,]} ${MobName.Find[${MobsToPullSecondary.Arg[${j},,]}]}"
						/if (${MobName.Find[${MobsToPullSecondary.Arg[${j},,]}]}) {
                			/varset PullValid 1
							/if (${MuleDebug}) /echo pulling secondary mob: ${MobName.Find[${MobsToPullSecondary.Arg[${j},,]}]}
                			/goto :SkipPullValidate
                		}
            		/next j
				} else {
					/if (${MuleDebug}) /echo ${MobsToPullSecondary} not found
				}
			}
			/if (!${PullValid}) {
				/return PullMobNotonList
			}
		}
		:SkipPullValidate
		DEBUGCOMBAT ValidateTarget Validate 4"
		/if (${MobName.Find[eye of]} && ${SpawnCount[pc ${MobName.Right[${Math.Calc[${MobName.Length}-7]}]}]}) /return Spell-Eye-PC        
		/if (${MobType.Equal[Pet]} && ${Spawn[${MobID}].Master.Type.Equal[PC]}) /return PET-PC
		/if (!${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) /return PC
		| This prevents characters on the Zek server from attacking PC targets in their group
		/if (${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) {
			/for i 0 to 5
				/if (${MobID}==${Group.Member[${i}].ID}) /return GroupMember
			/next i
			/if (${MobID}==${Spawn[=${MainAssist}].ID}) /return MA
		}
		/varset ValidTarget 1
		DEBUGCOMBAT ValidateTarget Leave ValidTarget return is going to be: ${ValidTarget}"
    /return ${ValidTarget}
	
| -------------------------------------------------------------------------------------
| SUB: FindvalidRangeLocation
| -------------------------------------------------------------------------------------
Sub FindvalidRangeLocation(int targetID, string radius)
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
	/declare i int local 0
	/declare XOff float local 0
	/declare YOff float local 0
	/declare ZOff float local 0
	/declare XMove float local 0
	/declare YMove float local 0
	/declare BaseRadians local
	|we incrememnt by 5 feet around the circle...
	/declare Multiplier local 10
	
	/declare MyHeading float local ${Math.Calc[${Spawn[${targetID}].Heading.Degrees} - ${Multiplier}]}
	/declare BaseRadian float local ${Math.Calc[360 / 36]}
	/for i 1 to 36
		/varcalc XMove ${Math.Cos[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
		/varcalc YMove ${Math.Sin[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
		/varcalc XOff ${Spawn[${targetID}].X} + ( ${Int[${radius}]} * ${XMove} )
		/varcalc YOff ${Spawn[${targetID}].Y} + ( ${Int[${radius}]} * ${YMove} )
		/varcalc ZOff ${Spawn[${targetID}].Z}
		/if (${Navigation.PathExists[locyxz ${YOff} ${XOff} ${ZOff}]}) {
			/if (${LineOfSight[${YOff},${XOff},${ZOff}:${Spawn[${targetID}].Y},${Spawn[${targetID}].X},${Spawn[${targetID}].Z}]}==TRUE) {
				|/echo ${SpawnCount[pc loc ${XOff} ${YOff} radius 20]}
				/if (${EverQuest.ValidLoc[${XOff} ${YOff} ${ZOff}]}) {
					/if (${SpawnCount[npc loc ${XOff} ${YOff} radius 60]}<=${Me.XTarget}) {
						DEBUGMOVE FindValidLoc: We have a valid loc at ${YOff} ${XOff} ${ZOff}"
						/echo [${i}] We have a valid loc at ${YOff} ${XOff} ${ZOff}
						/squelch /nav locyxz ${YOff} ${XOff} ${ZOff}
						/delay 1s ${Navigation.Active}==TRUE
						/delay 5s ${Navigation.Active}==FALSE
						/delay 1s !${Me.Speed}
						/delay 2
						/break
					}
				}
			}
		}
	/next i
/return

Sub RangerStuff
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
	DEBUGDPS RangerStuff Enter"
	/declare bskip int local 0
	/if (${Target.ID}==${MyTargetID} && !${Bool[${Target.Mezzed.ID}]}) {
		DEBUGDPS RangerStuff Distance check ${Target.Distance3D}  < 30 || LoS !${Target.LineOfSight}"
		/if (${Target.Distance3D} < 30 || !${Target.LineOfSight}) {
			/if (${Zone.ShortName.Equal[trialsofsmoke_mission]}) {
				/if (${Me.Z} < 1) {
					/varset bskip 1
				}
			}
			/if (${bskip}==0) {
				/if (${Bool[${Plugin[mq2moveutils]}]}==TRUE) {
					/if (${Stick.Active}) /squelch /stick off
					/squelch /moveto off
				}
				/if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.Playing}) {
					/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
					/squelch /play off
					/squelch /afollow off
 				}
				DEBUGDPS need to move back a little ${Target.Distance3D} < 30 || !${Target.LineOfSight}"
				/echo need to move back a little
				/call FindvalidRangeLocation ${Target.ID} 33
			}
		}
		/if (${Me.Sitting} && ${AutoFireOn}) {
			/if (!${standTimer}) /stand
			/delay 1s ${Me.Standing}
			/if (!${Me.Standing}) {
				DEBUGDPS Returning cause I'm not standing"
				/return
			}
		}
		/if (!${Me.AutoFire} && !${StayAwayToCast}) {
			/echo turning on autofire target is ${Target.Distance3D} feet away
			/autofire on
			/squelch /face fast
		}
	}
/return

| -------------------------------------------------------------------------------------
| SUB: Combat
| -------------------------------------------------------------------------------------
    Sub Combat
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /doevents
		DEBUGCOMBAT Combat Enter"
		|/if (${DebugCombat} || ${DebugDPS}) /delay 7
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius} && ${Pulling}) {
			DEBUGCOMBAT Wrong role (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius} && ${Pulling})"
			/return
		}
        /if (!${MyTargetID}) {
			DEBUGCOMBAT No MyTargetID (!${MyTargetID})"
			/return
		}
        /if (!${Target.ID}) {
			DEBUGCOMBAT No Target.ID (!${Target.ID})"
			/return
		}
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) {
			DEBUGCOMBAT In DMZ ((${DMZ} && ${Me.InInstance}==FALSE))"
			/return
		}
        /if (!${Target.LineOfSight}) {
			DEBUGCOMBAT LOS (!${Target.LineOfSight})"
			|/echo No LineOfSight! Normally I would just exit Combat. Let's see what happens. 
			|Lemons: Keeping this change. Small hills or random objects would make the tank not pick up mobs within their camp radius.
			|Inside small dungeons this causes issues...Don't know a good solution
			DEBUGCOMBAT Checking if LOSmovement is on and they're in range.(${Select[${Role},tank,pullertank,pullerpettank]} && ${MoveCloserIfNoLOS} && ${Target.Distance} < ${CampRadius} && ${Target.Distance} < ${MeleeDistance} && ${Navigation.PathExists[id ${Target.ID}]})"
			/if (${Select[${Role},tank,pullertank,pullerpettank]} && ${MoveCloserIfNoLOS} && ${Target.Distance} < ${CampRadius} && ${Target.Distance} < ${MeleeDistance} && ${Navigation.PathExists[id ${Target.ID}]}) {
				/nav id ${Target.ID}
				DEBUGCOMBAT I have LOS and the mob is within melee and camp radius, going to Nav to it."
			} else /if ((${StayAwayToCast} || ${AutoFireOn}) && CANSTARTCOMBAT) {
				/echo I'm autopositioning but I can't see the mob. Getting to main assist. 
				/nav id ${MainAssistID}
				/delay 1s ${Spawn[${MainAssistID}].LineOfSight}
			} else {
				/return
			}
		}
        /if (${DPSPaused}) {
			DEBUGCOMBAT (${DPSPaused})"
			/return
		}
		|Lemons: Test section to see how to handle a charm break. The idea is, if you're not a tank then don't attack the mob and give the enchanter a chance to mez and recharm it without having mez broken.
		/if (${Target.ID} == ${CharmPetID} && !${Select[${Role},tank,pullertank,pullerpettank,manual]}) {
			DEBUGCOMBAT Not going into combat cause it's our enchanters pet."
			/return
		} else /if (${Target.ID} == ${CharmPetID} && !${Select[${Role},manual]} && ${LemonsFlag}) {
			:charmloop
			/if (${MuleDebug}) /echo In Charm Loop and ${Target.Distance} > 10, ${CharmPetID} && !${Spawn[${CharmPetID}].Master.ID}
			/if (!${Me.Standing}) {
				DEBUGN going to stand\agLine#:${Macro.CurLine}"
				/if (!${standTimer}) /stand
				/delay 1s ${Me.Standing}
				/if (!${Me.Standing}) {
					DEBUGN Returning cause I'm not standing"
					/return
				}
			}
			|delayremove
			/delay 1
			/if (${Target.Distance} > 10 && ${Target.Distance} < 100) {
				DEBUGMOVE Moveto target between 10-100"
				/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
				/moveto ID
			}
			/delay 2s !${Navigation.Velocity}
			/if (${Me.AbilityReady[Taunt]}) /doability taunt
			/if (${MapTheZone}) /call ZoneMap FALSE
			/if (${CharmPetID} && !${Spawn[${CharmPetID}].Master.ID} && ${SpawnCount[pc enchanter radius 100]}) /goto :charmloop
			/return
		}
		|Lemons: I think this is stopping the tank from awakening a new mob. Not sure if that's OK or not. Leaving note here for later. 
		/if (${Me.XTarget}==0) {
			DEBUGCOMBAT There's nothing on my XTarget list, not gonna do combat if it's not mezzed MyTargetID: ${MyTargetID} MA: ${MainAssist}"
			/if (!${Target.Mezzed.ID}) {
				DEBUGCOMBAT ${Target} isn't mezzed so I'm leaving combat"
				/return
			}
		}
        /if (${Me.Song[Rallying Call].ID} && !${Select[${Role},tank,pullertank]}) /return
        | Check if mob mezzed
        /if (${HealsOn}) /call CheckHealth
        /if (${ChaseAssist}) /call DoWeMove Combat
        /declare SpamTankWait int local 1
        /declare ZDist float local 0
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) /call DoMezStuff
        }
		/if (${Group.MainAssist.ID} && ${Group.MainAssist.ID}!=${Me.ID} && ${Target.Mezzed.ID} && ${MeleeOn}) {
			|/if (${Target.Mezzed.ID}) /echo Mob is mezzed ->> ${Target.CleanName} <<- I am not going to wake it since I am not the MA.
			|delayremove/delay 5
			/return
        }
		/if (${bardShouldBeSitting}) /varset bardShouldBeSitting FALSE
		/if (${TwistingInvis}) /varset TwistingInvis FALSE
        | Check Target Hps and type NPC or NPC Pet
        DEBUGCOMBAT Combat ${Spawn[${MyTargetID}].Name} PctHPs = ${Spawn[${MyTargetID}].PctHPs} AssistAt=${AssistAt} Distance = ${Spawn[${MyTargetID}].Distance} MeleeDistance = ${MeleeDistance} MRT: (!${Spawn[${MyTargetID}].Speed} && ${Spawn[${MyTargetID}].Distance} <= ${Math.Calc[(${Spawn[${MyTargetID}].MaxRangeTo} + ${Spawn[${Spawn[${MyTargetID}].AssistName}].Distance}) *1.3]})"
        | PullerPetTank and PetTank send in pet if mob in range
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Spawn[${MyTargetID}].Distance}<${PetAttackRange}) /call CombatPet
        /if (${AggroOn} && ${MainAssist.NotEqual[${Me}]} && ${Select[${Role},Tank]} && ${Spawn[${MyTargetID}].Distance}>${MeleeDistance}) /call AggroCheck
		/if (${TankAllMobs} && ${MainAssist.NotEqual[${Me}]} && ${Select[${Role},Tank]}) /call TankAllMobs
		/if (!${Select[${Role},tank,pullertank,pullerpettank,hunter]}) /call HomogenizeMainTarget
		DEBUGCOMBAT |${Spawn[${MyTargetID}].Type}| CANSTARTCOMBAT "
        /if (CANSTARTCOMBAT) {
			/if (${DismountDuringFights}==1) {
				/if (${Me.Mount.ID}) {
					/dismount
				}
			}
			DEBUGCOMBAT !CombatStart Currently at ${CombatStart}"
			/if (!${CombatStart}) {
					DEBUGCOMBAT Combat Setting CombatStart to 1"
					/if (${Cursor.ID}) /call CheckCursor
					/varset MercAssisting 0
					/varset CombatStart 1
					/echo  ATTACKING -> ${Spawn[${MyTargetID}]} <- 
					|If the mob is back in camp, but I chased the last mob outside of engage distance, I need to return to camp so I can engage the new mob.
					/if (${ReturnToCamp} && ${Spawn[${MyTargetID}].Distance} >= ${MeleeDistance} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 10) {
						DEBUGMOVE Mob is here in camp, but I'm not at camp"
						/call DoWeMove "Combat 2"
					}
					/if (${IAmABard}) /call DoBardStuff
					/if ((${Select[${Role},Tank,PullerTank,Hunter]} || (${Role.Equal[manual]} && (${Group.Member[0].MainAssist} || ${Group.Member[0].MainTank}))) && ${MyTargetID} != ${CharmPetID}) /call BroadCast y "TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
					/if (${Select[${Role},petTank,pullerpettank,hunterpettank]} && ${MyTargetID} != ${CharmPetID}) /call BroadCast y "${Me.Pet.CleanName} is TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
					| Moloing as as puller turn off puller tag in group so tank merc attacks and doesn't wait for me to get 2 feet near them.
					/if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<${CampRadius}) /call AssignGroupRole unset "${Me.CleanName}" 3
					/if (${Target.Named} && ${BeepOnNamed}) {
						/echo Named mob!
						/beep
						/beep
					}
				}
			|Lemons: Gonna force some good practices on players, since they seem to suck more at the game. If available, Mages will force their pet behind the mob with a bit of math. Copied from some of my personal stuff, hope it still works. 
			|This line checks to see if my pet is facing the opposite direction of the mob. Are they looking at each other
			/if (${PetBehind})	{
				/if (${Me.AltAbilityReady[3816]} && !${Me.Casting.ID} && !${UsedReloc} && ((${Me.Pet.Heading.Clock} < ${Math.Calc[${Spawn[${MyTargetID}].Heading.Clock} - 3]}) || (${Me.Pet.Heading.Clock} > ${Math.Calc[${Spawn[${MyTargetID}].Heading.Clock} + 3]})) && ${Me.Pet.ID} && !${Role.Find[pet]}) {
				|This line checks to see if my pet is facing me	
					/if ((${Me.Pet.Heading.Clock} <= ${Math.Calc[${Me.Heading.Clock} - 3]}) || (${Me.Pet.Heading.Clock} >= ${Math.Calc[${Me.Heading.Clock} + 3]})) {
						/face fast away
						/delay 3
						/alt activate 3816
					} else {
						/face fast
						/delay 3
						/alt activate 3816
					}
					/delay 1s ${Me.Casting.ID}
					/delay 1s !${Me.Casting.ID}
					/echo Repositioning pet behind mob 
					/varset UsedReloc TRUE
				}
			}
			/if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID}) && (!FACING)) {
				/face fast nolook
				DEBUGCOMBAT Facing ${Target}"
				}
			/if (${Select[${Role},pettank,pullerpettank]} && !${Attacking} && ${Target.Distance} < ${CampRadius}) { 
				/pet attack ${MyTargetID}
				/pet swarm
				/varset Attacking 1
				/if (${MuleDebug}) /echo Pet attacking at \ag${Macro.CurLine}
			}
			DEBUGCOMBAT MeleeOn and !Attacking --	${MeleeOn} && !${Attacking})"
			/if (${MeleeOn} && !${Attacking}) {
				/varset Attacking 1
				/if (!${Me.Standing}) {
					DEBUGCOMBAT going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGCOMBAT Returning cause I'm not standing"
						/return
					}
				}
				DEBUGCOMBAT MeleeOn and Distance, MeleeDist and not attacking-	${MeleeOn} && ${Target.Distance} <= ${MeleeDistance} && !${Me.Combat}	"
				DEBUGCOMBAT Combat Attack On \ag${Macro.CurLine}"
				DEBUGCOMBAT (${MeleeOn} && (${Target.Distance} <= ${MeleeDistance} || ((!${Spawn[${Target.ID}].Speed} && ${Spawn[${Target.ID}].Distance} <= ${Math.Calc[(${Spawn[${Target.ID}].MaxRangeTo} + ${Spawn[${Spawn[${Target.ID}].AssistName}].Distance}) *1.3]} && !${Spawn[${Spawn[${Target.ID}].AssistName}].Speed} && ${Spawn[${Target.ID}].Distance} <= ${Math.Calc[${CampRadius}*1.5]}))) && !${Me.Combat})"
				|Lemons: There are issues with with giants who have longer arms than most people's melee distance. 
				/if (${MeleeOn} && (${Target.Distance} <= ${MeleeDistance} || ((!${Spawn[${Target.ID}].Speed} && ${Spawn[${Target.ID}].Distance} <= ${Math.Calc[(${Spawn[${Target.ID}].MaxRangeTo} + ${Spawn[${Spawn[${Target.ID}].AssistName}].Distance}) *1.3]} && !${Spawn[${Spawn[${Target.ID}].AssistName}].Speed} && ${Spawn[${Target.ID}].Distance} <= ${Math.Calc[${CampRadius}*1.5]}))) && !${Me.Combat}) {
					/attack on
					DEBUGCOMBAT Attack on"
					/if (${Navigation.Active}) /nav stop
				}
				/if (!${AutoFireOn}) {
					DEBUGCOMBAT Combat Attack On \ag${Macro.CurLine}"
					| Speed up tanks attacking inc mobs MQ2Melee /killthis can cause a delay
					/if (${Select[${Role},tank,pullertank,hunter]}) {
						/if (${Me.Skill[Taunt]} && ${Me.AbilityReady[Taunt]}) {
							|/echo taunting mob...
							/doability Taunt
						}
						/if (!${Me.Combat}) {
							DEBUGCOMBAT I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
							/attack on
						}
						/if (${Me.FeetWet} && ${Target.ID} != ${Stick.StickTarget}) {
							/if (${Navigation.Active}) {
								DEBUGMOVE Stopping nav at "
								/nav stop
							}
							DEBUGMOVE Sticking"
							/stick uw ${StickHow} id ${MyTargetID}
						} else /if (${Target.ID} != ${Stick.StickTarget}) {
							DEBUGMOVE Sticking"
							/stick ${StickHow} id ${MyTargetID}
						}
					}
					| Use zerker kick in the teeth line before melee
					/if (${Defined[BeforeCombat]}) {
						/if (!${BeforeCombat.Find[disc]} && ${Me.CombatAbilityReady[${Spell[${BeforeCombat}].RankName}]}) {
							/call CastWhat "${BeforeCombat}" ${MyTargetID} Combat
							/call WaitCast "Combat" ${Spell[${BeforeCombat}].MyCastTime}
							/if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo ** ${BeforeCombat} on >> ${Spawn[${MyTargetID}].CleanName}
						}
					}
					/if (!${UseMQ2Melee} && ${MeleeOn}) {
						/if (${Spawn[${MyTargetID}].Distance}>13) {
							/if (${MuleDebug}) /echo moveto 1 id ${MyTargetID}
							DEBUGMOVE Moveto 1 ${MyTargetID}"
							/moveto id ${MyTargetID}
						}
						/if (${Me.FeetWet} && ${Target.ID} != ${Stick.StickTarget}) {
							/if (${Navigation.Active}) {
								DEBUGMOVE Stopping nav at "
								/nav stop
							}
							DEBUGMOVE Sticking"
							/stick uw ${StickHow} id ${MyTargetID}
						} else {
							DEBUGMOVE Sticking"
							/stick ${StickHow} id ${MyTargetID}
						}
						DEBUGCOMBAT I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
						/attack on
					} else {
						DEBUGCOMBAT We already validated target ${Spawn[${MyTargetID}]}, so I'm gonna turn on attack"
						|If im not eh puller, stay the fuck back until he is close.
						|Lemons: Is this needed since we already validated the target distance in Validate Target in Assist?
						|Lemons: Experimental 15.1.1 disabling this check. 
						|Lemons: Undisabling this in 15.1.5 cause we are getting stick and nav at the same time. Also attack is on without stick while mq2melee is active somehow?
						/if (${Group}) {
							/if (${MainAssist.NotEqual[${Me}]}) {
								/if (${Spawn[=${MainAssist}].Distance3D} > ${MeleeDistance} || ${Spawn[${MyTargetID}].Distance} > ${MeleeDistance}) {
									DEBUGCOMBAT Not going to move to the target cause they're outside MeleeDistance"
									/return
								}
							}
						}
						DEBUGCOMBAT I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
						DEBUGMOVE Moveto "
						/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
						/killthis
						/attack on
						/moveto ID
						/squelch /afollow off
					}
					/if (${Target.ID} != ${Stick.StickTarget}) {
						DEBUGCOMBAT Sticking to ${MyTargetID} ${Target.ID}"
						DEBUGMOVE Sticking to ${MyTargetID} ${Target.ID}"
						|/echo LemonsDebug:\agLine#:${Macro.CurLine}
						/if (${Me.FeetWet}) {
							/if (${Navigation.Active}) {
								DEBUGMOVE Stopping nav at "
								/nav stop
							}
							DEBUGMOVE Sticking"
							/stick uw ${StickHow} id ${MyTargetID}
						} else {
							DEBUGMOVE Sticking"
							/stick ${StickHow} id ${MyTargetID}
						}
					}
					| Move closer if Z distance more than 4 due to levitation
					/call ZAxisCheck ${ZDist} 4.1
				}
			}
			
			/varset  MyExp ${Me.PctExp}
			/varset  MyAAExp ${Me.PctAAExp}
			| Turn on check for mez mob in camp that has been mem blurred if i am a tank type
			/if (${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /varset MezMobFlag 1
			
			:Attack
				DEBUGCOMBAT :Attack Loop "
				/if (${CombatStart} && (${AutoFireOn} || ${StayAwayToCast})) {
					/if (${Target.ID}==${MyTargetID} && !${Bool[${Target.Mezzed.ID}]}) /call RangerStuff
				}
				DEBUGMOVE Checking if I should stick. (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]} <= ${CampRadius} && ${MeleeOn} && (!${AutoFireOn} && !${StayAwayToCast}) && !${Navigation.Velocity} && (${MyTargetID} != ${Stick.StickTarget} || ${Stick.Status.Equal[OFF]}))"
				/if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]} <= ${CampRadius} && ${MeleeOn} && (!${AutoFireOn} && !${StayAwayToCast}) && !${Navigation.Velocity} && (${MyTargetID} != ${Stick.StickTarget} || ${Stick.Status.Equal[OFF]})) {
					/if (${MuleDebug}) /echo moveto 2 ${MyTargetID} != ${Stick.StickTarget}
					DEBUGCOMBAT Moving closer to target ${MyTargetID}"
					DEBUGMOVE Moving closer to target ${MyTargetID}"
					/stick ${StickHow} id ${MyTargetID}
				}
				/if (${Select[${Me.Class.ShortName},ROG]}) {
					/call AssassinAttack
				}
				/doevents
				|/if (${DPSMeter}) /doevents YouHit
				/if (${MercOn} && ${MercAssisting} != ${MyTargetID} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
				DEBUGCOMBAT Attack Loop: !MQ2Melee. !${UseMQ2Melee} && ${Spawn[${MyTargetID}].Distance}>13 && ${MeleeOn}"
				/if (!${UseMQ2Melee} && ${Spawn[${MyTargetID}].Distance}>13 && ${MeleeOn} && (${MyTargetID} != ${Stick.StickTarget} || ${Stick.Status.Equal[OFF]})) {
					|/if (${MuleDebug}) /echo moveto ${Macro.CurLine}
					|DEBUGMOVE Moveto "
					|/stick ${StickHow} id ${MyTargetID}
					/if (!${Me.Combat}) {
						DEBUGCOMBAT Attack on"
						/attack on
					}
				}
				/if (${BandolierOn}) {
					/call DoBandolier
				}
				/if (${MezOn}) {
					/varset MezBroke 0
					/doevents MezBroke
					/if (!${MezBroke}) /call DoMezStuff
				}
				/if (${AEOn}) /call AECheck
				/if (${AggroOn}) /call AggroCheck
				/if (${TankAllMobs}) /call TankAllMobs
				/if (!${Select[${Role},tank,pullertank,pullerpettank,hunter]}) /call HomogenizeMainTarget
				/if (${Spawn[${MyTargetID}].PctHPs} <= ${PetAssistAt} && (${PetOn} || ${Me.Pet.ID}) && ${PetCombatOn}) {
					|I mean if they have a pet up, lets use it, like a charm pet...
					/call CombatPet
				}
				/if (${HealsOn}) /call CheckHealth
				/if (${CuresOn}) /call CheckCures
				/if (${AutoRezOn}) /call RezCheck
				/if (${Target.ID} != ${MyTargetID} && ${MeleeOn}) {
					/tar id ${MyTargetID}
				}
				/if (!${NamedCheck}) {
					/if (${BurnAllNamed}) {
						/call NamedWatch
					} else {
						|People that don't want to burn nameds still want the gmail notification...
						/if (${Spawn[${MyTargetID}].Named}) {
							/if (${Bool[${GMailEvents.Find[named]}]}==TRUE) {
								/call GmailSend "${Spawn[${MyTargetID}].CleanName} is a NAMED and its in CAMP!"
							}
							/varset NamedCheck 1
						}
					}
				}
				DEBUGDPS Combat: Checking for DebuffAll ${DebuffAllOn} && (!${Role.Equal[puller]} || !${ChainPull})  \agLine#:${Macro.CurLine}"
				/if (${DebuffAllOn} && (!${Role.Equal[puller]} || !${ChainPull})) {
				   | Debuff stuff
				   /call DoDebuffStuff ${MyTargetID}
				   |When returning the mob you were started on could be dead, so don't keep trying to kill a corpse.
				   /if (${Me.XTarget}==0 || ${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused} || ${Target.Charmed.ID} && ${MyTargetID} || (${Spawn[${AggroTargetID}].Master.ID} && ${Spawn[${AggroTargetID}].Master.Type.Equal[PC]})) {
					   /call CombatReset Combat1
					   /return
				   }
				}
				/if (${BandolierOn}) {
					/call DoBandolier
				}
				DEBUGDPS Calling DPS sub CombatCast with (${DPSOn} && (!${Role.Equal[puller]} || !${ChainPull})) and MTID: ${MyTargetID}  CurTar:${Target.ID}"
				/if (${DPSOn} && (!${Role.Equal[puller]} || !${ChainPull})) /call CombatCast
				/call CastMana
				/call WriteDebuffs
				/if (${IAmABard}) /call DoBardStuff
				/if (${DPSOn} || ${MeleeOn} || ${PetOn}) {
					/if (${Me.Class.ShortName.Equal[CLR]}) {
						/if (!${HealsOn}) {
							/if (${MuleDebug}) /echo calling CombatTargetCheck from Combat
							/call CombatTargetCheck
					}
					} else {
					|/echo calling CombatTargetCheck from Combat
					/call CombatTargetCheck
					}
				}
				DEBUGCOMBAT Combat: Atk${Attacking} && MOn${MeleeOn} && TrgHPs${Target.PctHPs}<=${Math.Calc[${AssistAt}-5]} && Dist:${Target.Distance}<${MeleeDistance} && !${AutoFireOn} MTID ${MyTargetID}"
				/if (${Attacking} && ${MeleeOn} && (${Target.PctHPs}<=${Math.Calc[${AssistAt}-5]} || ${Select[${Role},pullertank,pettank,pullerpettank,hunterpettank,hunter,tank]} || ${Me.ID} == ${MainAssistID}) && ${Target.Distance}<${MeleeDistance} && !${AutoFireOn}) {
					DEBUGCOMBAT Am I attacking? ${Me.Combat}"
					/if (!${Me.Combat}) {
						/if (!${Me.Standing}) {
							DEBUGN going to stand"
							/if (!${standTimer}) /stand
							/delay 1s ${Me.Standing}
							/if (!${Me.Standing}) {
								DEBUGN Returning cause I'm not standing"
								/return
							}
						}
						/if (!${UseMQ2Melee} && ${Target.Type.Equal[NPC]} && ${Me.Standing}) {
							DEBUGCOMBAT Don't Use MQ2Melee"
							/if (${Me.FeetWet}) {
								/if (${Navigation.Active}) {
									DEBUGMOVE Stopping nav at "
									/nav stop
								}
								DEBUGMOVE Sticking"
								/stick uw ${StickHow} id ${MyTargetID}
							} else {
								DEBUGMOVE Sticking"
								/stick ${StickHow} id ${MyTargetID}
							}
							DEBUGCOMBAT I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
							/attack on
						} else /if (${Target.Type.Equal[NPC]} && ${Me.Standing}) {
							DEBUGCOMBAT UseMQ2Melee yes"
							/if (!${Select[${Role},tank,pullertank,hunter,hunterpettank,pettank,pullerpettank]} && ${Target.Mezzed.ID}) {
								/echo Don't want to break mez. Waiting for tank.
							} else {
								/if (${AdvPath.State} && ${MeleeOn}) /afollow off
								DEBUGCOMBAT  I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
								/killthis
								/attack on
								/if (${Target.Distance} > 13 && ${Target.Distance} < ${MeleeDistance}) {
									DEBUGMOVE Moveto "
									/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
									/moveto ID
								}
							}
						}
						/if (${StickHow.NotEqual[0]} && !${Stick.Active} && ${Target.Distance}>13) {
							DEBUGCOMBAT Not sticking while meleeon MTID ${MyTargetID} ${Spawn[${MyTargetID}]}"
							/if (${Me.FeetWet}) {
								/if (${Navigation.Active}) {
									DEBUGMOVE Stopping nav at "
									/nav stop
								}
								DEBUGMOVE Sticking"
								/stick uw ${StickHow} id ${MyTargetID}
							} else {
								DEBUGMOVE Sticking"
								/stick ${StickHow} id ${MyTargetID}
							}
						}
					} else /if (${Attacking} && ${MainAssist.Equal[${Me}]} && !${Me.Combat} && ${MeleeOn} && ${Target.Distance} <= ${CampRadius} && ${Me.Standing}) {
						DEBUGCOMBAT im in the :Attack loop but attack is not on Attacking=${Attacking} MeleeOn=${MeleeOn} Target.PctHPs=${Target.PctHPs} Math.Calc[AssistAt-5]=${Math.Calc[${AssistAt}-5]} Target.Distance=${Target.Distance} MeleeDistance=${MeleeDistance} AutoFireOn=${AutoFireOn}"
						DEBUGCOMBAT I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
						/attack on
						/if (${Target.Distance} <= ${CampRadius}) {
							DEBUGMOVE Moveto ${Target}"
							/moveto ID
						}
					}
					/if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${Me.XTarget}==0 || (${Target.Charmed.ID} && ${MyTargetID})) {
						DEBUGCOMBAT CombatReset (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${Me.XTarget}==0 || (${Target.Charmed.ID} && ${MyTargetID}) at\agLine#:${Macro.CurLine}"
						DEBUGDPS CombatReset (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${Me.XTarget}==0 || (${Target.Charmed.ID} && ${MyTargetID}) at\agLine#:${Macro.CurLine}"
						/call CombatReset Combat
						/return
					}
					/if (${Role.Equal[puller]} && ${ChainPull}) {
					   /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=75) {
							/if (!${ChainPullHold} && ${MobCount}<2 && !${Me.XTarget[${XTSlot2}].ID} && ${If[${Target.Named},0,1]}==1) {
								/if (${Target.ID} && ${Target.PctHPs} < ${ChainPullHP}) {
									/call FindMobToPull 0
									/if (${Macro.Return}>0 && ${Spawn[${ChainPullTemp}].Distance}<${Math.Calc[${PullRange}+400]} && ${Me.TargetOfTarget.Name.NotEqual[${Me.CleanName}]} && ${Me.PctAggro}<50) {
										/if (${UseMQ2Melee}) /squelch /melee melee=0
										|/delay 1s
										/if (${Stick.Active}) /squelch /stick off 
										DEBUGCOMBAT Attack on"
										/squelch /attack off
										|delayremove/delay 1s 
										/if (${UseMQ2Melee}) /squelch /melee melee=1
										/varset ChainPull 2
										/varset MyTargetID 0
										/varset MTIDSetAt ${Macro.CurLine}
										/varset Attacking 0
										/return
									}
								}
							}
						} else /if (${SpamTankWait}) {
							/call BroadCast r "Holding Pulls. Tank to far from camp."
							/varset SpamTankWait 0 
						}
					}  
					/if (${OhShitOn}) {
						/call OhShitStuff "Combat"
					}
					/if (${Role.Equal[puller]} && ${ChainPull} && ${DebuffAllOn}) /call DebuffCast ${MyTargetID} 1 
					DEBUGDPS Calling DPS sub CombatCast with (${Role.Equal[puller]} && ${ChainPull} && ${DPSOn}) and MTID: ${MyTargetID}  CurTar:${Target.ID}"
					/if (${Role.Equal[puller]} && ${ChainPull} && ${DPSOn}) /call CombatCast     
					/if (${MapTheZone}) /call ZoneMap FALSE
					/if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]} || ${Spawn[${MyTargetID}].ID}) /goto :Attack
					/if (${Bool[${Plugin[MQ2Melee]}]}) {
							/if (${Melee.Status.NotEqual[FEIGNING]}) /goto :Attack
					}
				} else /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && (${Spawn[${MyTargetID}].Distance}<${MeleeDistance} || ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius})) {
					/if ((${PetOn} || ${Me.Pet.ID}) && ${PetCombatOn}) /call CombatPet
				}
		DEBUGCOMBAT Combat Leave end :Attack loop"
		}
    /return
| -------------------------------------------------------------------------------------
| SUB: CombatTargetCheck
| -------------------------------------------------------------------------------------
    Sub CombatTargetCheck
        | If mob is dead return
        /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) /return 
		
        | Check target matches MA if group mainassist assigned and MA is in group
		|Lemons: I think I need to remove this if I'm ever going to get the tank to hold agro on multiple unmezzed mobs. Gonna try removing it now to see how it goes.
		|So I think I was getting stale MyTargetIDs without this which was causing issues with mezzing. Unfortunately we can't use AssistID because people use a combination of macs/plugins. And I'm currently inclined to help them. We'll see how long that lasts.
		|Gonna change this to a separate variable so we can at least check against it for mezzing without screwing up other stuff. 
        /if (${Spawn[=${MainAssist}].ID} && ${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID}) {
            /if (${Target.ID}!=${Me.GroupAssistTarget.ID} && ${Group.MainAssist.ID}!=${Me.ID}) {
                /if (${MyTargetID}!=${Me.GroupAssistTarget.ID} && ${Spawn[id ${Me.GroupAssistTarget.ID} npc].ID} && ${Target.ID} != ${AssistID}) {
                    /if (${SwitchWithMA}) {
						/echo My target does not match MA's. Switching to new target.
						/varset MyTargetID ${Me.GroupAssistTarget.ID}
						/varset MTIDSetAt ${Macro.CurLine}
						/varset MyTargetName ${Spawn[id ${Me.GroupAssistTarget.ID}].CleanName}
					}
                }
            }
        }
        /if (${Target.ID}!=${MyTargetID} && ${Spawn[${MyTargetID}].ID}) {
			/if (${Target.ID}) {
				/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
				 /squelch /target clear
				 /delay 1s ${Target.BuffsPopulated}==FALSE
			}
			/if (${MuleDebug}) /echo Targeting a mob 7: ${Spawn[${MyTargetID}]}
            /squelch /target id ${MyTargetID}
            /delay 1s ${Target.ID}==${MyTargetID}
			/delay 1s ${Target.CachedBuffCount}!=-1
        }
		/call SmartMerc
	/return
| -------------------------------------------------------------------------------------
| SUB: DoBandolier
| -------------------------------------------------------------------------------------
Sub DoBandolier
	/declare tempbandid	int      local
	/declare bandi		int      local 0
	DEBUGN Entering DoBandolier"
	/if (${PullOnce}) {
		/varset PullOnce 0
		/call FindMobToPull 3
	}
	/if (${MapTheZone}) /call ZoneMap FALSE Med
	/for bandi 1 to ${Bandolier.Size}
		/if (${BandolierCond[${bandi}].NotEqual[NULL]}) {
			DEBUGN Condition${bandi} is ${BandolierCond[${bandi}]}"
			/if (${If[${BandolierCond[${bandi}]},1,0]}) {
			|Lemons: Me.Bandolier don't work on TLPs
				/if (${Me.Bandolier[${Bandolier[${bandi}]}].Item[1].ID} != ${Me.Inventory[mainhand].ID} || ${Me.Bandolier[${Bandolier[${bandi}]}].Item[2].ID} != ${Me.Inventory[offhand].ID} || ${Me.Bandolier[${Bandolier[${bandi}]}].Item[3].ID} != ${Me.Inventory[ranged].ID} || ${Me.Bandolier[${Bandolier[${bandi}]}].Item[4].ID} != ${Me.Inventory[ammo].ID}) {
	    			DEBUGN player want us to activate Bandolier: ${Bandolier[${bandi}]}."
					/invoke ${Me.Bandolier[${Bandolier[${bandi}]}].Activate}
	    			|delayremove/delay 1 
	    			/delay 1s ${Me.Bandolier[${Bandolier[${bandi}]}].Item[1].ID} == ${Me.Inventory[mainhand].ID}
					DEBUGN Activated Bandolier: ${Bandolier[${bandi}]}."
				}
				/return
	    		}
	    	}
	/next bandi
	DEBUGN Leave Bandolier"
/return
| -------------------------------------------------------------------------------------
| SUB: Combat Cast
| -------------------------------------------------------------------------------------
    Sub CombatCast
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}	
		DEBUGDPS Enter CombatCast (DPS)"
        /declare i           int      local 0
        /declare DPSStart    int      local ${Math.Calc[${DebuffCount}+1]}
        |/declare DPSText     string   local
        /declare DPSAt       int      local ${AssistAt}
        /if (!${Defined[DPSTargetID]}) /declare DPSTargetID int outer ${MyTargetID}
        /declare DPSItem     string   local
        /declare DPSPart1    string   local 
        /declare DPSPart2    string   local 
        /declare DPSPart3    string   local 
        /declare DPSPart4    string   local 
        /declare DPSPart5    string   local
        /declare WeaveCheck  int      local 0
		/declare MacroReturn string 	local
        /call WriteDebuffs
		|Lemons: No reason to go through this sub if we only have DPS items tagged with debuffall.
		/if (${DPS.Size} == ${DebuffCount}) {
			DEBUGDPS Not going to go through normal DPS routine cause all my spells are debuffall. ${DPS.Size} == ${DebuffCount}"
		}
		/if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID}) && !FACING) {
			/if (${MuleDebug}) /echo facing ${Target.ID} FaceMobOn = ${FaceMobOn} (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID}) && !FACING) \agLine#:${Macro.CurLine}
			DEBUGCOMBAT Facing ${Target}"
			/face fast nolook
		}
		DEBUGCOMBAT About to loop through DPS with DBCount is ${DebuffCount}+1 DPSStart at ${DPSStart}, Size is ${DPS.Size} and my target is: ${MyTargetID}, ${DPSTargetID}"
        /for i ${DPSStart} to ${DPS.Size}
			DEBUGCOMBAT DPS loop ${i} with MTID: ${MyTargetID} and DPSTID: ${DPSTargetID}"
			/if (${MyTargetID} && ${DPSTargetID} != ${MyTargetID}) {
				DEBUGCOMBAT DPSTargetID ${DPSTargetID} does not equal MyTargetID ${MyTargetID}. Resetting timers."
				|/call DPSTimerReset "CombatCast"
				/varset DPSTargetID ${MyTargetID}
			}
			/if (!${Defined[DPSTimer${i}${DPSTargetID}]}) /declare DPSTimer${i}${DPSTargetID} timer outer 0
			/if (${Spawn[${MyTargetID}].PctHPs} <= ${PetAssistAt} && (${PetOn} || ${Me.Pet.ID}) && ${PetCombatOn} && !${Me.Pet.Combat}) {
				/pet attack ${MyTargetID}
				/if (${MuleDebug}) /echo Pet attacking in DPS loop
			}
			DEBUGCOMBAT I'm checking DPSArray${i} ${DPS[${i}]} (May not match DPS# in ini) MTID${MyTargetID} DPSID${DPSTargetID}"
			/doevents wornoff
			/if (${BandolierOn}) {
				/call DoBandolier
			}
			/if (${OhShitOn}) {
				/call OhShitStuff "CombatCast"
			}
			/if (${CallCustomFunc}) {
				/call CustomFunc "${CustomFuncName}"
			}
            /doevents
			|/echo The target we should nuke is ${Spawn[${MyTargetID}]}
			|these classes are usually set as healers and we dont want them to switch between group and mobs constantly, they do that anyway if needed in combat cast for the dps section
			/if (${Select[${Me.Class.ShortName},CLR,DRU,SHM]}) {
				/if (!${HealsOn}) {
					/call CombatTargetCheck
				}
			} else {
				/call CombatTargetCheck
			}
            /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                DEBUGCOMBAT Returning from CombatCast because my target is a corpse or dead or DPSPaused is ${DPSPaused}."
                /return
            }
            /if (${DPSPaused}) {
                DEBUGCOMBAT Returning from CombatCast because DPSPaused is ${DPSPaused}"
                /return
            }
			|--- only call code for GroupEscape kick off.
            /if (${GroupEscapeOn}) {
				/if (${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) {
					/call GroupEscape
				}
			}
            /if (${MezOn}) {
                /varset MezBroke 0
                /doevents MezBroke
                /if (!${MezBroke}) /call DoMezStuff
            }
            /if (${HealsOn}) /call CheckHealth
            /if (${CuresOn}) /call CheckCures
            /if (${Cursor.ID}) /call CheckCursor

            /if (${Int[${DPS[${i}].Arg[2,|]}]} > 0 && ${DPS[${i}].Arg[3,|].NotEqual[null]}) {
                /varset DPSPart1 ${DPS[${i}].Arg[1,|]}
                /varset DPSPart2 ${DPS[${i}].Arg[2,|]}
                /if (${Select[${DPS[${i}].Arg[3,|]},if,ifme,notif,notifme]}>0) {
                   /if (${DPS[${i}].Arg[5,|].NotEqual[null]}) /varset DPSPart3 ${DPS[${i}].Arg[5,|]}
                   /varset DPSPart4 ${DPS[${i}].Arg[3,|]}
                   /varset DPSPart5 ${DPS[${i}].Arg[4,|]}
                } else {
                   /varset DPSPart3 ${DPS[${i}].Arg[3,|]}
                   /varset DPSPart4 ${DPS[${i}].Arg[4,|]}
                   /varset DPSPart5 ${DPS[${i}].Arg[5,|]}
                }
            } else {
                /varset DPSPart1 ${DPS[${i}].Arg[1,|]}
                /varset DPSPart2 ${DPS[${i}].Arg[2,|]}
                /varset DPSPart3
                /varset DPSPart4
                /varset DPSPart5
            }	
			/if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                DEBUGCOMBAT Returning from CombatCast because my target is a corpse or dead or DPSPaused is ${DPSPaused}."
                /return
            }
			DEBUGCOMBAT DPSPart1 is: ${DPSPart1},2: ${DPSPart2}, 3: ${DPSPart3}, 4:${DPSPart4}, 5:${DPSPart5}. ${Spell[${DPSPart1}].RankName} ${DPSPart1} !${Me.SpellReady[${Spell[${DPSPart1}].RankName}]} && !${Me.AltAbilityReady[${DPSPart1}]} && !${Me.CombatAbilityReady[${Spell[${DPSPart1}].RankName}]} && !${Me.AbilityReady[${DPSPart1}]}"
			/if (${DPSPart1.Find[command:]}) {
				DEBUGCOMBAT We have a Command spell, lets run it."

			} else /if (!${Me.SpellReady[${Spell[${DPSPart1}].RankName}]} && !${Me.AltAbilityReady[${DPSPart1}]} && !${Me.CombatAbilityReady[${Spell[${DPSPart1}].RankName}]} && !${Me.AbilityReady[${DPSPart1}]} && !${Me.ItemReady[${DPSPart1}]}) {
				DEBUGCOMBAT Skipping cast because ${DPSPart1} is not ready."
				/goto :skipcast
			}
            /if (${ConditionsOn}) {
				/if (${DPSCOn}) {
					/if (${If[${DPSCond[${i}]},0,1]}) {
						DEBUGCOMBAT The DPSCond${i} (|${DPSCond[${i}]}| is FALSE) for ${DPSPart1} returned FALSE so we skip it."
						/goto :skipcast
					} else {
						DEBUGCOMBAT The DPSCond${i} (${DPSCond[${i}]}==TRUE) for ${DPSPart1} returned TRUE so we move on!"
					}
				}
			}
			DEBUGCOMBAT Going to cast a CA if it's ready ${Select[${DPSPart3},Me,MA]}==0 && (${Me.CombatAbility[${DPSPart1}]} || ${Me.Ability[${DPSPart1}]}) && !${DPSTimer${i}${DPSTargetID}}"
            /if (${Select[${DPSPart3},Me,MA]}==0 && (${Me.CombatAbility[${DPSPart1}]} || (${Me.SkillCap[${DPSPart1}]} && ${Me.Ability[${DPSPart1}]})) && !${DPSTimer${i}${DPSTargetID}}) {
				DEBUGCOMBAT [${Time}] CASTING 1 ${DPSPart1} DPSID: ${DPSTargetID}"
				/call CastWhat "${DPSPart1}" ${DPSTargetID} DPS
				/goto :MeleeCast
            }
			/if (${MainAssist.NotEqual[${Me}]} && ${Spell[${DPSPart1}].Category.NotEqual[Utility Detrimental]}) {
				/call CacheBuffs ${MyTargetID}
				/if (${Spawn[${MyTargetID}].CachedBuff[^Mezzed].Duration} > 0) {
					DEBUGCOMBAT Skipping spell in CombatCast because target is mezzed and I'm not mainassist and it will wake up the mob."
					/goto :skipcast
				}
			}
			/if (${Me.XTarget}==0 && ${Spawn[${MyTargetID}].PctHPs}==100) {
				DEBUGCOMBAT Returning because we have noone on xtarget, so that means we should not be casting anything, its a non aggro mob..."
				/return
			}
			|well we got this far but is the mob within sight?
			/if (${MoveCloserIfNoLOS}) {
				/if (${Bool[${Plugin[MQ2Nav]}]}) {
					/if (${Role.Equal[Assist]} && ${Target.ID} && !${Target.LineOfSight} && ${Target.Distance3D} < 50 && ${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.PathExists[id ${MainAssistID}]} && ${Spawn[${MainAssist}].Distance} > 11) {
						DEBUGCOMBAT Returning because I am assisting and I can't see the mob. I will move closer"
        				/if (${MoveTo.Moving}) /moveto off
						/if (${Stick.Active}) /squelch /stick off
						/if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.Playing}) {
							/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
							/play off
 						}
						/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
	            		/nav spawn id ${Spawn[=${MainAssist}].ID} | dist=10
						/delay 1s ${Navigation.Active}==TRUE
						/delay 5s ${Navigation.Active}==FALSE
						/return
					}
	    		}
			}
            /if (!${DPS[${i}].Length}) {
                DEBUGCOMBAT I'm skipping because there is no spell: DPS${i}"
                /goto :skipcast    
            }
			|Lemons: pretty sure this doesn't matter anymore.
            |/if (${Spell[${DPSPart1}].Subcategory.Equal[Mana Drain]} && ${MyTargetID} && !${Spawn[${MyTargetID}].Class.CanCast}) {
			|	DEBUGCOMBAT I'm skipping ${Spell[${DPSPart1}]} on ${Spawn[${MyTargetID}]} because we shouldn't try to mana drain non caster mobs"
			|	/goto :skipcast            
            |}
            /if (${MercOn} && ${MercAssisting} != ${MyTargetID} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
			/if (!${Select[${Role},tank,pullertank,pullerpettank,hunter]}) /call HomogenizeMainTarget
            /if (${AEOn}) /call AECheck
            /if (${AggroOn}) /call AggroCheck
			/if (${TankAllMobs}) /call TankAllMobs
			/if ((${PetOn} || ${Me.Pet.ID})) {
				/if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && ${PetCombatOn}) /call CombatPet
			}
			| - Check for 2nd value in dps for mob health
            /if (${DPSPart2.Length} && ${Int[${DPSPart2}]}>0) {
                /varset DPSAt ${DPSPart2}

                /if (${DPSPart3.Equal[MA]}) {
					DEBUGCOMBAT DPSID changed to  MA ${Spawn[=${MainAssist}].ID}"
					/varset DPSTargetID ${Spawn[=${MainAssist}].ID}
					/if (!${Defined[DPSTimer${i}${DPSTargetID}]}) /declare DPSTimer${i}${DPSTargetID} timer outer 0
				}
                /if (${DPSPart3.Equal[Me]} || ${DPSPart3.Equal[Feign]}) {
					DEBUGCOMBAT DPSID changed to Me ${Me.ID}"
					/varset DPSTargetID ${Me.ID}
					/if (!${Defined[DPSTimer${i}${DPSTargetID}]}) /declare DPSTimer${i}${DPSTargetID} timer outer 0
				}
                | Check if self combat buff is active
                /if (${DPSPart3.Equal[Me]}) {
                    /if (${DPSPart4.Length} && ${DPSPart4.NotEqual[null]}) {
                        /if (${Select[${DPSPart4},if,ifme]}>0 && !${Me.Buff[${DPSPart5}].ID} && !${Me.Song[${DPSPart5}].ID}) {
							DEBUGCOMBAT Skipping cast because of ${DPSPart4} clause"
							/goto :skipcast
						}
                        /if (${Select[${DPSPart4},notif,notifme]}>0 && (${Me.Buff[${DPSPart5}].ID} || ${Me.Song[${DPSPart5}].ID})) {
							DEBUGCOMBAT Skipping cast cause of ${DPSPart4} clause"
							/goto :skipcast
						}
                    } else /if (${Me.Buff[${DPSPart1}].ID} || ${Me.Song[${DPSPart1}].ID}) {
						DEBUGCOMBAT Skipping cast because ${DPSPart1} is already on Me"
                        /goto :skipcast
                    }
                }
            }
			DEBUGCOMBAT Checking for skips with ID: ${DPSTargetID} which is ${Spawn[${DPSTargetID}]}"
            /if (${Me.Class.Name.Equal[Cleric]} && ${DPSPart1.Find[Hammer]} && ${Me.Pet.ID}) {
				DEBUGCOMBAT Skipping ${DPSPart1} because of Hammer"
				/goto :skipcast
			}
            /if (${Me.Class.Name.Equal[Wizard]} && ${Me.Pet.ID} && (${DPSPart1.Find[sword]} || ${DPSPart1.Find[blade]})) {
				DEBUGCOMBAT Skipping ${DPSPart1} because of Wiz sword or blade"
				/goto :skipcast
			}
            /if (${Spawn[${DPSTargetID}].PctHPs} < ${DPSSkip}) {
				DEBUGCOMBAT Skipping ${DPSPart1} cause of DPSSkip Mobs HP ${Spawn[${DPSTargetID}].PctHPs} is less than ${DPSSkip}"
				/goto :skipcast
			}
            /if (${DPSPart1.Equal[NULL]}) {
				DEBUGCOMBAT I'm skipping cause DPSPart1 is ${DPSPart1}"
				/goto :skipcast
			}
            /if (${ABTimer${i}}) {
				DEBUGCOMBAT I'm skipping ${DPSPart1} cause ABTimer${i} ${ABTimer${i}}"
				/goto :skipcast
			}
            /if (${Spawn[${DPSTargetID}].PctHPs} > ${DPSAt} && ${DPSOn}==1) {
				DEBUGCOMBAT I'm skipping ${DPSPart1} cause DPSAt Targets hp ${Spawn[${DPSTargetID}]} ${Spawn[${DPSTargetID}].PctHPs} is > ${DPSAt}"
				/goto :skipcast
			}			
			DEBUGDPS i: ${i} Spell:${DPS[${i}]}, ${DPSPart1}, MyTID:${MyTargetID}.DPSID:${DPSTargetID} | \ar!${DPSTimer${i}${DPSTargetID}}"
			DEBUGCOMBAT Checking Skip #${i} (${DPSTimer${i}${DPSTargetID}} && ( (((${Target.Buff[${DPSPart1}].ID} || ${Target.CachedBuff[${DPSPart1}].ID} || ${Target.Buff[${AltAbility[${DPSPart1}].Spell}]} || ${Target.CachedBuff[${FindItem[${DPSPart1}].Clicky.Spell}].ID} || ${Target.Buff[${FindItem[${DPSPart1}].Clicky.Spell}].ID}) || ${DPSPart3.Find[once]}) && (${Spell[${DPSPart1}].Duration} || ${DPSPart3.Find[once]} || ${FindItem[${DPSPart1}].Spell.Duration})) || (!${Spell[${DPSPart1}].Duration} || !${FindItem[${DPSPart1}].Spell.Duration})))"
            /if (${FDTimer${i}}) {
				DEBUGCOMBAT I'm skipping ${DPSPart1} cause FDTimer${i} ${FDTimer${i}}"
				/goto :skipcast
			}
            /if (!${Select[${EverQuest.Server},zek]} && ${Spawn[${DPSTargetID}].Type.NotEqual[NPC]} && ${Spawn[${DPSTargetID}].Master.Type.NotEqual[NPC]}) {
				DEBUGCOMBAT I'm skipping ${DPSPart1} cause of weird reason"
				/goto :skipcast
			}
            /if (${Select[${DPSPart3},Me,MA]} && ${Me.Combat} && ${MainAssist.NotEqual[${Me}]}) {
				DEBUGCOMBAT Turning off attack"
                /attack off
                /delay 10 !${Me.Combat}
            }
			/if (${DPSPart1.Find[command:]}) {
				DEBUGCOMBAT I'm going to run a DPS command: ${DPSPart1}"
				/call CastWhat "${DPSPart1}" ${DPSTargetID} DPS
				/goto :skipcast
			}			
            /if (${DPSPart4.Length} && ${DPSPart4.NotEqual[null]}) {
                /if (${Select[${DPSPart4},if,notif]} > 0) {
					/call CacheBuffs ${DPSTargetID}
                    /if (${DPSPart4.Equal[if]}) {
						/if (!${Spawn[${DPSTargetID}].CachedBuff[${DPSPart5}].ID}) {
							DEBUGCOMBAT I'm skipping cause of if DPSPart5"
							/goto :skipcast
						}
					}
                    /if (${DPSPart4.Equal[notif]}) {
						/if (${Spawn[${DPSTargetID}].CachedBuff[${DPSPart5}].ID}) {
							DEBUGCOMBAT I'm skipping cause of notif DPSPart5"
							/goto :skipcast
						}
					}
                } else /if (${Select[${DPSPart4},ifme,notifme]}>0) {
                    /if (${DPSPart4.Equal[ifme]} && !${Me.Buff[${DPSPart5}].ID} && !${Me.Song[${DPSPart5}].ID}) {
						DEBUGCOMBAT I'm skipping cause of ifme DPSPart5"
						/goto :skipcast
					}
                    /if (${DPSPart4.Equal[notifme]} && (${Me.Buff[${DPSPart5}].ID} || ${Me.Song[${DPSPart5}].ID})) {
						DEBUGCOMBAT I'm skipping cause of notifme DPSPart5"
						/goto :skipcast
					}
                } else {
					DEBUGCOMBAT What The! There is no such DPS parameter: ${DPSPart4}. You may want to check your settings."
                }
            }
            | Only cast spells with weave tag during global cooldown
            /if (${WeaveArray.Size}>=1 && ${Me.SpellInCooldown}) {
                /call WeaveStuff ${DPSTargetID}
                /varset WeaveCheck 1
				DEBUGCOMBAT Skipping after Weave for ${DPSPart1}"
                /goto :skipcast
            }            
			/if (${DPSTimer${i}${DPSTargetID}} && ( (((${Target.Buff[${DPSPart1}].ID} || ${Target.CachedBuff[${DPSPart1}].ID} || ${Target.Buff[${AltAbility[${DPSPart1}].Spell}].ID} || ${Target.CachedBuff[${FindItem[${DPSPart1}].Clicky.Spell}].ID} || ${Target.Buff[${FindItem[${DPSPart1}].Clicky.Spell}].ID}) || ${DPSPart3.Find[once]}) && (${Spell[${DPSPart1}].Duration} || ${DPSPart3.Find[once]} || ${FindItem[${DPSPart1}].Spell.Duration})) || (!${AltAbility[${DPSPart1}].Spell.Duration} || !${Spell[${DPSPart1}].Duration} || !${FindItem[${DPSPart1}].Spell.Duration}))) {
				DEBUGCOMBAT I'm skipping ${DPSPart1} cause DPSTimer${i}${DPSTargetID} ${DPSTimer${i}${DPSTargetID}} and the mob has the spell on them or it has no duration and the DPSInterval timer isn't up yet "
				/goto :skipcast
			}
			DEBUGCOMBAT I'm going to cast ${DPSPart1}"
            /call CastWhat "${DPSPart1}" ${DPSTargetID} DPS
	    :MeleeCast
			|Lemons: Setting a string here since we call MuleSpew for debugging. 
			/varset MacroReturn ${Macro.Return}
			DEBUGCOMBAT DPS. MacroReturn is ${MacroReturn}"
            /if (${MacroReturn.Equal[CAST_RESIST]}) {
                /echo [${Macro.CurSub}] [${Time}] ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - RESISTED\agLine#:${Macro.CurLine}
                /if ((${DPSPart3.Length} && ${DPSPart3.Equal[once]}) || (${NumFails} > ${CastRetries})) {
                    DEBUGCOMBAT Skipping ${DPSPart1} because it is set to ${DPSPart3} or fails exceeds retries ${NumFails} > ${CastRetries}"
					/varset DPSTimer${i}${DPSTargetID} 5s
                    /goto :skipcast
                }
            }
            /if (${MacroReturn.Equal[CAST_TAKEHOLD]}) {
                /echo [${Macro.CurSub}] [${Time}] ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - DID NOT TAKE HOLD\agLine#:${Macro.CurLine}
                /varset DPSTimer${i}${DPSTargetID} 5m
                /goto :skipcast
            }
            /if (${MacroReturn.Equal[CAST_SUCCESS]}) {
                DEBUGCOMBAT Cast Successful for ${DPSPart1}, ${DPSPart2}, ${DPSPart3}"
                | Set timer for spells labeled once 5m
				DEBUGCOMBAT Checking for Once tag"
                /if (${DPSPart3.Length} && ${DPSPart3.Equal[once]}) {
                    /varset DPSTimer${i}${DPSTargetID} 5m
                    /goto :skipcast
                }
				| Timers for items    
				DEBUGCOMBAT DPS. FinditemCount for ${DPSPart1} is ${FindItemCount[=${DPSPart1}]}"
				/if (${FindItemCount[=${DPSPart1}]}) {
                    /varcalc DPSTimer${i}${DPSTargetID} ${FindItem[=${DPSPart1}].Spell.Duration.TotalSeconds}*10
                    /goto :skipcast
                }
                | FD to lose aggro
				/if (${Select[${Me.Class.ShortName},BST,MNK,NEC,SHD]} && ${DPSPart3.Equal[Feign]}) {
                    /delay 30 ${Me.State.Equal[FEIGN]}
                    /varset FDTimer${i} 60s
                    /delay 10s ${Me.State.NotEqual[FEIGN]}
                    /if (${Me.State.Equal[FEIGN]} && !${Me.Sitting}) {
						DEBUGN standing after feign"
						/if (!${standTimer}) /stand
					}
                }
				| Timers for spells
				/varset DPSTimer${i}${DPSTargetID} ${DPSInterval}s
				DEBUGCOMBAT Setting DPSTimer${i}${DPSTargetID} to ${DPSTimer${i}${DPSTargetID}} from caststate ${Macro.Return}"
				/if (${Me.Book[${DPSPart1}]}) {
                    | - Attack Buff Timers are seperate. DPS timers are cleared after every fight.
                    /if (${Select[${DPSTargetID},${Me.ID},${Spawn[=${MainAssist}].ID}]}) {
                        /varcalc ABTimer${i} (${Spell[${DPSPart1}].Duration.TotalSeconds}*${DurationMod})*10
                        DEBUGCOMBAT CombatCast Spell: ${DPSPart1} Timer: ABTimer${i} ${ABTimer${i}}"
                        /goto :skipcast
                    }
                    | - Custom timer for counterbias
					/if (${Me.Class.Name.Equal[Shaman]} && ${DPSPart1.Find[counterbias]}) {
                        /varset DPSTimer${i}${DPSTargetID} 1.5m
                        /goto :skipcast
                    }
                    | Custom timer for Chanter suffocation
					/if (${Me.Class.Name.Equal[enchanter]} && ${DPSPart1.Find[suffocation]}) {
                        /varset DPSTimer${i}${DPSTargetID} 1m
                        /goto :skipcast
                    }
                    | Custom timer for Beastlord Feralgia Timer
					/if (${Me.Class.Name.Equal[Beastlord]} && ${DPSPart1.Find[feralgia]}) {
                        /varset DPSTimer${i}${DPSTargetID} 1.5m
                        /goto :skipcast
                    }
					|Rpzip: Set timer for spells labeled spam to DPSInterval
                    DEBUGCOMBAT Checking for Spam tag"
                    /if (${DPSPart3.Length} && ${DPSPart3.Equal[spam]}) {
                        /varset DPSTimer${i}${DPSTargetID} ${DPSInterval}s
                        /goto :skipcast
                    }
					DEBUGCOMBAT Checking if I can set the spell timer normally. ${Spell[${DPSPart1}].Duration.TotalSeconds}>0 && ${MacroReturn.Equal[CAST_SUCCESS]} ${Macro.Return}."
                    | Regular spells. Lemons: If a spell is interrupted, it was still getting a full length timer. Now timer only sets if the spell landed (sans other conditions above)
					/if (${Spell[${DPSPart1}].Duration.TotalSeconds}>0 && ${MacroReturn.Equal[CAST_SUCCESS]}) {
						DEBUGCOMBAT Spell ${DPSPart1} timer being set to ${Spell[${DPSPart1}].Duration.TotalSeconds}*10 on iteration ${i}"
                        /varcalc DPSTimer${i}${DPSTargetID} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                        /goto :skipcast
                    }
					/goto :skipcast
                | AA and disc timers
                } else /if (${Spell[${DPSPart1}].Duration} > 0 && (${Me.AltAbility[${DPSPart1}]} || ${Me.CombatAbility[${DPSPart1}]})) {
					DEBUGCOMBAT AA or CA ${DPSPart1} timer being set to ${Spell[${DPSPart1}].Duration.TotalSeconds}*10 on iteration ${i}"
                    /varcalc DPSTimer${i}${DPSTargetID} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                    /goto :skipcast
                | AA and disc with no timers assign DPS interval
                } else {
                    /varset DPSTimer${i}${DPSTargetID} ${DPSInterval}s
                    /goto :skipcast
                }
            }
            :skipcast
			DEBUGCOMBAT CombatCast ${DPSPart1} ${Macro.Return} DPSTimer${i}${DPSTargetID} ${DPSTimer${i}${DPSTargetID}}"
			DEBUGCOMBAT CombatCast ${DPSPart1} ${Macro.Return} DPSTimer${i}${DPSTargetID} ${DPSTimer${i}${DPSTargetID}}"
			/if (${Select[${DPSPart3},Me,MA]}) {
				/if (${MuleDebug}) /echo calling CombatTargetCheck from CombatCast 2
				/call CombatTargetCheck
			}
            | Reset values if 2nd value in dps for mob health exists
            /if (${DPSPart2.Length} && ${DPSPart2.NotEqual[null]}) {
                /varset DPSAt ${AssistAt}
                /varset DPSTargetID ${MyTargetID}
            }
            /if (${WeaveArray.Size}>=1 && ${Me.SpellInCooldown} && !${WeaveCheck}) {
                /call WeaveStuff ${DPSTargetID}
            }
            /if (${MashArray.Size}>=1) /call MashButtons
            /varset WeaveCheck 0
        /next i
        DEBUGCOMBAT CombatCast: Leave"
    /return 

| -------------------------------------------------------------------------------------
| SUB: OhShitStuff this will stop casting and do the most important stuff
| -------------------------------------------------------------------------------------    
	Sub OhShitStuff(string sentFromOS)
		/if (${Me.Hovering}) /return
		/declare i int local 0
		/declare OhShitTargetString string local
		/declare thehp int local 0
		/declare thespell string local
		/declare thetargetid string local
		/declare cond string local
		/declare ArgC int local 0
		/declare Args int local 0
		/declare isCommand bool local FALSE
		/if (${MuleDebug}) {
			/delay 1
			|/echo LemonsDebug: Slowing down. OhShit sentFrom ${sentFromOS}
		}
		/if (${Me.Pet.ID} && ${Me.Pet.Combat} && (${Group.Member[${Me.Pet.AssistName}].ID} || ${Spawn[${Me.Pet.AssistName} pc].ID})) {
			/if (!${petBackTimer}) {
				/pet ${PetHold} on
				/pet back
				/echo Pet is attacking a PC (${Me.Pet.ID} && ${Me.Pet.Combat} && (${Group[${Me.Pet.AssistName}]} || ${Spawn[${Me.Pet.AssistName} pc].ID}))
				/varset petBackTimer 3s
			}
		}
		/if (${MashArray.Size}>=1 && CANSTARTCOMBAT && ${Target.Type.Equal[npc]} && ${Me.CombatState.Equal[COMBAT]} && !${Me.Invis}) {
			/call MashButtons ohshit
		}
		/if (${PullOnce}) {
			/varset PullOnce 0
			/call FindMobToPull 3
		}
		/if (${MapTheZone}) /call ZoneMap FALSE Med
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
		/for i 1 to ${OhShit.Size}
			|/if (${MuleDebug}) /echo OhShit${i} Cond is : ${OhShitCond[${i}]} -- ${If[${OhShitCond[${i}]},1,0]} for ${OhShit[${i}]}
			/varset OhShitTargetString 
			/if (${OhShit[${i}].Arg[1].Find[command:]}) {
				/varset isCommand TRUE
				|It's a command, so we need to start by counting the args...
				/for ArgC 1 to 10
					/if (${OhShit[${i}].Arg[${ArgC}, ].Equal[NULL]}) {
						/break
					}
					/if (${OhShit[${i}].Arg[${ArgC}, ].NotEqual[NULL]}) {
						/varcalc Args ${Args} + 1
					}
				/next ArgC
				/varset OhShitTargetString ${OhShit[${i}].Arg[1, ]}
				/if (${MuleDebug}) /echo we have ${Args} args for ${OhShitTargetString}
				|/mqp
				/for ArgC 2 to ${Args}
					/varset OhShitTargetString ${OhShitTargetString} "${OhShit[${i}].Arg[${ArgC}, ]}"
				/next ArgC
				/varset thespell ${OhShit[${i}].Arg[2]}
				/varset thetargetid ${OhShit[${i}].Arg[${Args},|]}
				/if (${OhShitTargetString.Find[|]}) {
					/varset OhShitTargetString ${OhShitTargetString.Left[${Math.Calc[${OhShitTargetString.Find[|]}-1]},400]}
				}
			} else {
				|Just a normal spell/aa/skill
				/varset thespell ${OhShit[${i}].Arg[1,|]}
				/varset thetargetid ${OhShit[${i}].Arg[2,|]}
			}
			
			/if (${Me.Spell[${thespell}].ID} && !${isCommand}) {
				|/if (${MuleDebug}) /echo It's a spell
				|/echo ${thespell} exists in my book \agLine#:${Macro.CurLine}
				/if (!${Me.SpellReady[${thespell}]}) {
					/if (${MuleDebug}) /echo ${i} It's a spell but it's not ready
					/continue
				}
			}
			
			/if (${If[${OhShitCond[${i}]},1,0]} && (!${BuffMode} || ${isCommand})) {
				|/if (${MuleDebug}) /echo OhShit${i}:MainAssistID = ${MainAssistID}
				|/if (${MuleDebug}) /echo OhShit${i}:my HP = ${Me.PctHPs}
				|/if (${MuleDebug}) /echo OhShit${i}:target HP = ${Target.PctHPs}
				/if (${Me.Casting.ID} && !${Twist}) {
					/if (${MuleDebug}) /echo Interrupting to do OhShit${i}
					/stopcast
				}
				|Lemons: Going to test the ability to use the second variable as a target chooser so we need to target whatever they have there
				/if (${thetargetid.Length} && ${Target.ID} != ${Spawn[${thetargetid}].ID} && ${Spawn[${thetargetid}].ID}) {
					/if (${MuleDebug}) /echo Need to target ${thetargetid}|${Spawn[${thetargetid}]} for OhShit#${i}
					/target id ${Spawn[${thetargetid}].ID}
					/delay 1s ${Spawn[${thetargetid}].ID} == ${Target.ID}
				}
				|Lemons: Added target check to remove error spam if you have no target and don't need one. 
				/if (${FaceMobOn}) {
					/if (${Target.ID}) {
						/if (${Target.Type.Equal[NPC]} && ${Spawn[${thetargetid}].ID} == ${Target.ID}) {
							|/echo facing ${Target.ID} FaceMobOn = ${FaceMobOn} \agLine#:${Macro.CurLine}
							/if (!FACING) {
								/face id ${thetargetid}
								DEBUGCOMBAT Facing ${Target}"
							}
						}
					}
				}
				|/if (${MuleDebug}) /echo OhShit${i}: Command? ${OhShitTargetString.Find[command:]}
				/if (${OhShitTargetString.Find[command:]}) {
					/varset OhShitTargetString ${OhShitTargetString.Replace[command:,]}				
					/docommand ${OhShitTargetString}
					|delayremove/delay 2
				} else {
					|/if (${MuleDebug}) /echo Calling CastWhat from OhShit "${thespell}" ${thetargetid} OhShitstuff 1 0
					|/echo /call CastWhat "${thespell}" ${thetargetid} OhShitstuff 1 0 \agLine#:${Macro.CurLine}
					/call CastWhat "${thespell}" ${thetargetid} OhShitstuff 1 0
				}
				|Lemons: Breaking here means users can't create a string of events in their OhShit condition. What's the advantage to breaking?
				|/break
			} else {
				|/if (${MuleDebug}) /echo condition not met for ${OhShit[${i}].Replace[$,#]} condition is: ${OhShitCond[${i}].Replace[$,#]} = ${OhShitCond[${i}]} \agLine#:${Macro.CurLine}
			}

		/next i
		/if (${CharmPetID} && ${Spawn[${CharmPetID}].Type.NotEqual[Corpse]}) /call CharmStuff
	/return

| -------------------------------------------------------------------------------------
| SUB: CharmStuff - Only called from OhShits atm, so turn on OhShits if you want to use Charming. 
| ------------------------------------------------------------------------------------- 
Sub CharmStuff
	/declare i int local
	/declare CharmSpell string local 
	|Lemons: To deal with charm pets dying and getting stuck as a corpse pet
	/if (${SpawnCount[npc corpse radius 20]} && !${HideCorpseFlag}) {
		/hidec alwaysnpc
		|delayremove
		/delay 2
		/varset HideCorpseFlag TRUE
		}
	/if ((!${Me.Class.ShortName.Equal[ENC]} && !${Me.Class.ShortName.Equal[DRU]}) || ${Me.Pet.ID}) /return
	|Lemons: Now we are going to see if we need to recharm stuff or not using a standard sequence of Stun-Tash-Charm based on whatever you have currently memorized
	/if (${MuleDebug}) /echo ${Me.Class.ShortName.Equal[ENC]} && ${CharmPetID} && !${Me.Pet.ID} && ${Spawn[${CharmPetID}].Distance} < 200 && ${Spawn[${CharmPetID}].ID} && ${Me.PctMana} > 10)
	/for i 1 to ${Me.NumGems}
		/if (${MuleDebug}) /echo LemonsDebug: Gem#${i} checking if it's a charm pet spell: ${Me.Gem[${i}].HasSPA[22]} && ${Me.CurrentMana} > ${Me.Gem[${i}].Mana}
		/if (${Me.Gem[${i}].HasSPA[22]} && ${Me.CurrentMana} > ${Me.Gem[${i}].Mana}) {
		/varset CharmSpell ${Me.Gem[${i}]}
		/break
		}
	/next i
	
	:CharmIt
	/if ((${Me.Class.ShortName.Equal[ENC]} || ${Me.Class.ShortName.Equal[DRU]}) && ${CharmPetID} && !${Me.Pet.ID} && ${Spawn[${CharmPetID}].Distance} < 200 && ${Spawn[${CharmPetID}].ID} && ${Spawn[${CharmPetID}].Type.NotEqual[Corpse]}) {
		|Lemons: Let's see if we have a charm spell loaded. If not, then fuck your charm pet.
		/if (!${Defined[neededMana]}) /declare neededMana int local 0
		/if (!${Spell[${CharmSpell}].ID}) {
			/if (${SpawnCount[pc enchanter radius 100 notid ${Me.ID} group]} || ${SpawnCount[pc druid radius 100 notid ${Me.ID} group]}) {
				DEBUGPET I have no charm spell, but someone else might. Not going to clear charmpetID"
				/return
			}
			/echo I have no spell to charm with! Just kill the Smooshers :(. 
			/charmthis clear
			/return
		}
		/if (${Spell[${CharmSpell}].Mana} > ${Me.CurrentMana}) {
			/call BroadCast r "I don't have mana to charm my pet. Just kill the Smooshers"
			/charmthis clear
			/return
		}
		/if (${MuleDebug}) /echo LemonsDebug: CharmSpell set to ${CharmSpell} based on what you have memmed.
		/if (!${Me.Standing}) {
				DEBUGN going to stand"
				/stand
				/delay 1s ${Me.Standing}
				/if (!${Me.Standing}) {
					DEBUGN Returning cause I'm not standing"
					/echo Can't charm! I'm not standing!
					/return
				}
			}
		|Now we check if you have the stun or short duration mez and cast it. Only will count PB AE spells
		/for i 1 to ${Me.NumGems}
			/if (${MuleDebug}) /echo LemonsDebug: Gem#${i} checking if it's a PB AE Stun/Mez ((${Me.Gem[${i}].HasSPA[21]} && ${Me.Gem[${i}].MaxLevel} <= ${Spawn[${CharmPetID}].Level}) && ${Me.Gem[${i}].TargetType.Find[PB AE]} && !${Me.GemTimer[${i}]})
			/if ((${Me.Gem[${i}].HasSPA[21]} && ${Me.Gem[${i}].MaxLevel} <= ${Spawn[${CharmPetID}].Level}) && ${Me.Gem[${i}].TargetType.Find[PB AE]} && !${Me.GemTimer[${i}]} && !${Me.Pet.ID}) {
				/varcalc neededMana ${Me.Gem[${i}].Mana}+${Spell[${CharmSpell}].Mana}
				/if (${neededMana} > ${Me.CurrentMana}) /break
				/echo ${Me.Gem[${i}]} is either a stun. Gonna cast it real quick to get the mob under control. 
				/call CastWhat "${Me.Gem[${i}]}" ${CharmPetID} "CharmStuff" 1 1
				/break
			}
		/next i
		
		/for i 1 to ${Me.NumGems}
			/if (${MuleDebug}) /echo LemonsDebug: Gem#${i} checking if it's a PB AE Stun/Mez (( (${Me.Gem[${i}].HasSPA[21]} && ${Me.Gem[${i}].MaxLevel} <= ${Spawn[${CharmPetID}].Level}) || (${Me.Gem[${i}].HasSPA[31]} && ${Me.Gem[${i}].Duration} < 3 && ${Spawn[${CharmPetID}].Level} <= ${Me.Gem[${i}].MaxLevel})) && ${Me.Gem[${i}].TargetType.Find[PB AE]} && !${Me.GemTimer[${i}]})
			/if ((${Me.Gem[${i}].HasSPA[31]} && ${Me.Gem[${i}].Duration} <= 3 && ${Spawn[${CharmPetID}].Level} <= ${Me.Gem[${i}].MaxLevel}) && ${Me.Gem[${i}].TargetType.Find[PB AE]} && !${Me.GemTimer[${i}]} && !${Me.Pet.ID}) {
				/varcalc neededMana ${Me.Gem[${i}].Mana}+${Spell[${CharmSpell}].Mana}
				/if (${neededMana} > ${Me.CurrentMana}) /break
				/echo ${Me.Gem[${i}]} is either a short duration Mez. Gonna cast it real quick to get the mob under control. 
				/call CastWhat "${Me.Gem[${i}]}" ${CharmPetID} "CharmStuff" 1 1
				/break
			}
		/next i
		
		|Now we should retash the pet mob while it's stunned, if we have it memmed.
		/for i 1 to ${Me.NumGems}
			/if (${MuleDebug}) /echo LemonsDebug: Gem#${i} checking if it's a tash spell ${Me.Gem[${i}].Name.Find[Tash]} && ${Me.CurrentMana} > ${Me.Gem[${i}].Mana}
			/if (${Me.Gem[${i}].Name.Find[Tash]} && ${Me.CurrentMana} > ${Me.Gem[${i}].Mana} && !${Me.GemTimer[${i}]} && (!${Target.Tashed.ID} && !${Target.Buff[${Me.Gem[${i}]}].ID}) && !${Me.Pet.ID}) {
				/varcalc neededMana ${Me.Gem[${i}].Mana}+${Spell[${CharmSpell}].Mana}
				/if (${neededMana} > ${Me.CurrentMana}) /break
				/echo ${Me.Gem[${i}]} is a form of Tash. Gonna cast it on our pet.
				/call CastWhat "${Me.Gem[${i}]}" ${CharmPetID} "CharmStuff" 1 1
				/break
			}
		/next i
	
		|Now we can finally recharm the mob with the spell we identified above.
		/if (${Spawn[${CharmPetID}].Level} <= ${Spell[${CharmSpell}].MaxLevel} && !${Me.Pet.ID}) {
			|/echo LemonsDebug: We already know CharmSpell is ${CharmSpell} and we have it, so cast it!
			/call CastWhat "${CharmSpell}" ${CharmPetID} "CharmStuff" 1 1
		} else {
			/echo Can't charm ${Spawn[${CharmPetID}]} because ${CharmSpell} only affects creatures up to level ${Spell[${CharmSpell}].MaxLevel} and it is level ${Spawn[${CharmPetID}].Level}
			/charmthis clear
		}
	}
	/doevents CannotCharm
	/if (${Spawn[${CharmPetID}].ID} && !${Me.Pet.ID} && ${CharmPetID} && !${Me.Hovering} && !${Spawn[${CharmPetID}].Master.ID} && ${Spell[${CharmSpell}].ID} && ${Spawn[${CharmPetID}].Type.NotEqual[Corpse]} && ${Spawn[${CharmPetID}].Distance} < 200) {
		/goto :CharmIt
	}
	
	/return
| -------------------------------------------------------------------------------------
| SUB: WeaveStuff
| -------------------------------------------------------------------------------------    
    Sub WeaveStuff(int TarID)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /declare i int local 0
        /declare isitem int local 0
        /declare DPSat1 int Local 0
        /declare DPSWeaveSpell string local 
        /for i 1 to ${WeaveArray.Size}
            /varset DPSat1 ${Int[${WeaveArray[${i}].Arg[2,|]}]}
            /varset DPSWeaveSpell ${WeaveArray[${i}].Arg[1,|]}
            DEBUGN \at Cast DPSWeaveSpell:(${DPSWeaveSpell}) at (${DPSat1}%)"
			/if (${DPSat1}==0) /return
			/if (${ConditionsOn} && ${DPSCOn}) {
				/if (${If[${WeaveCond[${i}]},0,1]}) {
					/continue
				}
			}
			/if (${Me.ItemReady[${WeaveArray[${i}].Arg[1,|]}]}) {
	    		/if (${Me.Subscription.NotEqual[gold]} && ${FindItem[=${DPSWeaveSpell}].Prestige}) {
				|/echo cant cast ${DPSWeaveSpell} cause its prestige and we are not gold
				/continue
			}
			/varset isitem 1
	    }
	    /if (${Me.AltAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} || ${isitem} || ${Me.CombatAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} ||  ${Me.AbilityReady[${WeaveArray[${i}].Arg[1,|]}]}) {
			/if (${Spawn[${TarID}].PctHPs} <= ${DPSat1}) {
				/call CastWhat "${DPSWeaveSpell}" ${TarID} "WeaveStuff"
				/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
					/echo -- Weaved: ${DPSWeaveSpell}
				}
				/return 1
			}
		} 
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: Mash Buttons
| -------------------------------------------------------------------------------------    
    Sub MashButtons(sentFrom)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
		/if (${BandolierOn}) {
			/call DoBandolier
		}
		/if (${OhShitOn} && ${sentFrom.NotEqual[ohshit]}) {
			/call OhShitStuff "MashButtons"
		}
		/if (${CallCustomFunc}) {
			/call CustomFunc "${CustomFuncName}"
		}
        /declare i int local 0
        /declare MashThis string local
        /for i 1 to ${MashArray.Size}
            /varset MashThis ${MashArray[${i}].Arg[1,|]}
            /if (${MashThis.Length}==0 || ${MashThis.Equal[null]}) /return
			/if (${ConditionsOn} && ${DPSCOn}) {
				|/echo COND${i}: ${MashCond[${i}]}
				/if (${If[${MashCond[${i}]},0,1]}) {
					/continue
				}
			}
			/if (${FindItem[=${MashThis}].ID} && ${Me.ItemReady[${MashThis}]}) {
				/useitem "${MashThis}"
				/call WaitCast "Mash" ${FindItem[=${MashThis}].CastTime}
                /if (${MuleDebug}) /echo #1 Mashing >> ${MashThis} <<
				/continue
            }
			/if (${Me.AltAbility[${MashThis}]} && ${Me.AltAbilityReady[${MashThis}]} && ${Me.AltAbility[${MashThis}].Type}!=5 && ${MashThis.NotEqual[twincast]}) { 
                /alt act ${Me.AltAbility[${MashThis}].ID}
				/delay 2
                /if (${MuleDebug}) /echo #2 Mashing >> ${MashThis} <<
				/continue
            }
			/if (${Me.CombatAbility[${MashThis}]}) {
				/if (!${Me.CombatAbilityTimer[${MashThis}]}) {
					/if (${Me.CombatAbilityReady[${MashThis}]}) {
						/if (${Spell[${MashThis}].EnduranceCost} < ${Me.Endurance}) {
							/if (${Spell[${MashThis}].TargetType.Equal[Single]}) {
								/if (${Target.Distance3D} < ${Spell[${MashThis}].Range}) {
                    				/call CastDisc "${MashThis}" 0
                    				/if (${MuleDebug}) /echo #3 Mashing >> ${MashThis} <<
								} else {
									/echo I would mash >> ${MashThis} << but target is out of range (${Target.Distance3D}) so I can't.
									/stick ${Math.Calc[${Spell[${MashThis}].Range} - 10].Int} moveback
									|delayremove
									/delay 2s ${Target.Distance} < ${Spell[${MashThis}].Range}
									/if (${Stick.Active}) /stick off
								}
							} else {
								/call CastDisc "${MashThis}" 0
                    			/if (${MuleDebug}) /echo #4 Mashing Self >> ${MashThis} <<
							}
						}
					}
				}
				/continue
            }
			/if (${Me.Ability[${MashThis}]} && ${Me.AbilityReady[${MashThis}]}) {
				/if (FACING && ${Target.LineOfSight} && !${Me.Stunned}) {
					/if (!${${MashThis.Replace[ ,]}Timer}) {
						/doability "${MashThis}"
						/doevents TooFarAbility
						/if (${Macro.Return.Equal[TooFar]}) /varset ${MashThis.Replace[ ,]}Timer ${${MashThis.Replace[ ,]}Timer.OriginalValue}
						|delayremove/delay 2
						/if (${MuleDebug}) /echo #5 Mashing >> ${MashThis} <<
					}
				}
            }
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: CombatPet
| -------------------------------------------------------------------------------------
    Sub CombatPet
        DEBUGCOMBAT CombatPet: Enter"
        /if (${PetAttack} || ${DPSPaused}) /return
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Me.Pet.ID} && !${Me.Pet.Combat}) {
			/pet attack ${MyTargetID}
			/pet swarm
			/if (${MuleDebug}) /echo Pet attacking at \ag${Macro.CurLine}
			}
        /if (${Me.Pet.ID} && (${PetAttack} || ${Me.Pet.Combat})) /return
        /call CombatTargetCheck
        /if (${Spawn[${MyTargetID}].CachedBuff[^Mezzed].Duration} == 0 && !${Me.Pet.Combat}) {
            /if (${Select[${Role},pettank,pullerpettank]}) {
                /if ((${Me.Pet.Stance.NotEqual[FOLLOW]}) && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) || (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) {
					/pet follow
				}
            }
			|Lemons: Gonna force some good practices on players, since they seem to suck more at the game. If available, Pet owners will force their pet behind the mob with a bit of math. Copied from some of my personal stuff, hope it still works. 
			|This line checks to see if my pet is facing the opposite direction of the mob. Are they looking at each other
			/if (${Me.AltAbilityReady[3816]} && !${Me.Casting.ID} && !${UsedReloc} && ((${Me.Pet.Heading.Clock} < ${Math.Calc[${Spawn[${MyTargetID}].Heading.Clock} - 3]}) || (${Me.Pet.Heading.Clock} > ${Math.Calc[${Spawn[${MyTargetID}].Heading.Clock} + 3]}))) {
			|This line checks to see if my pet is facing me	
				/if ((${Me.Pet.Heading.Clock} <= ${Math.Calc[${Me.Heading.Clock} - 3]}) || (${Me.Pet.Heading.Clock} >= ${Math.Calc[${Me.Heading.Clock} + 3]})) {
						/squelch /face away id ${MyTargetID}
						/delay 1s
						/alt activate 3816
					} else {
						/squelch /face id ${MyTargetID}
						/delay 1s
						/alt activate 3816
					}
				/delay 1s ${Me.Casting.ID}
				/delay 1s !${Me.Casting.ID}
				/echo Repositioning pet behind mob 
				/varset UsedReloc TRUE
				}
			/if (${MuleDebug}) /echo Pet attacking at \ag${Macro.CurLine}
            /pet attack ${MyTargetID}
            /pet swarm
            |/delay 10
            | Set timer to check if pet is attacking every 3s 
            /varset PetAttack 30
        } else {
            /if (${Spawn[${MyTargetID}].CachedBuff[^Mezzed].Duration} > 0 && ${Select[${Role},pettank,pullerpettank]} && ${PetBreakMezSpell.NotEqual[null]}) /call BreakMez
        }
        DEBUGCOMBAT CombatPet: Leave"
	/return

| -------------------------------------------------------------------------------------
| SUB: BreakMez - Writtten by Trehuggindruid for MuleAssist
| -------------------------------------------------------------------------------------
    Sub BreakMez   
        /if (${PetBreakMezSpell.Equal[null]}) /return
        DEBUGCOMBAT BreakMez: Enter"
        /declare PetBreakMezTargetID int local ${MyTargetID}
        /echo ATTEMPTING TO BREAK MEZ ON: (${Target.CleanName}) ID:(${PetBreakMezTargetID})
        :TryMezBreak
        DEBUGCOMBAT Break Mez with: - ${PetBreakMezSpell}"
        /call CastWhat "${PetBreakMezSpell}" ${PetBreakMezTargetID} BreakMez        
        |--- DO NOT CHANGE THIS CONDITION!!!!!!
        /if (${Target.Mezzed.ID}) {
            DEBUGCOMBAT Mez NOT broken, trying again!"
            /goto :TryMezBreak
        } else {
            /varset PetAttack 0
            /echo + Mez broken !
            /if (${Me.Pet.ID} && !${Me.Pet.Combat}) {
				/pet attack ${MyTargetID}
				/if (${MuleDebug}) /echo Pet attacking at \ag${Macro.CurLine}
				}
        }
        DEBUGCOMBAT BreakMez: Leave"
    /return 
| -------------------------------------------------------------------------------------
| SUB: CombatReset
| -------------------------------------------------------------------------------------
    Sub CombatReset(sentFrom)
	DEBUGCOMBAT CombatReset ${sentFrom} at\agLine#:${Macro.CurLine}"
	DEBUGDPS CombatReset ${sentFrom} at\agLine#:${Macro.CurLine}"
	DEBUGMOVE CombatReset  ${sentFrom}"
	|/echo CombatReset sent from ${sentFrom}
	/declare a int local 0
	/if (${CharmPetID} == ${MyTargetID} && !${Spawn[${CharmPetID}].ID} || ${Spawn[${CharmPetID}].Type.Equal[CORPSE]}) {
		/if (${Me.Class.Name.Equal[Enchanter]} && !${Spawn[${CharmPetID}].ID} && ${CharmPetID}) {
			/echo We killed my pet. RIP Smooshers.
			}
		/varset CharmPetID 0
	}
	/if (${Me.Pet.ID}) {
		/pet ${PetHold} on
		/pet back
	}
	/varset CombatStart 0
	/varset MercAssisting 0
	/varset Attacking 0
	/varset UsedReloc FALSE
	/varset HideCorpseFlag FALSE
	/call DPSTimerReset "CombatReset"
	/if ((${AssistID} == ${MyTargetID}) || !${Spawn[${AssistID}].ID} || ${Spawn[${AssistID}].Type.Equal[Corpse]} && ${AssistID}) /varset AssistID 0
	/if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 10) {
		DEBUGMOVE Calling Dowemove combatreset"
		/call DoWeMove "CombatReset" 1
		}
		/varset MeleeHit 0
		/call SmartMerc
        /if (${DPSMeter}) /doevents YouHit
        /declare DPSCalcPct int local 0
        /declare DPSCalc string local
        /declare DPSTCalc string local
        /declare DPSMyDam string local
        /declare DPSPCalc string local
        /declare DPSPTCalc string local
        /declare DPSMyPetDam string local
        /declare DPSMeAndPetDam string local
        /declare DPSMPCalc string local
        /declare DPSMPTCalc string local
        DEBUGCOMBAT CombatReset: Enter"
		/if (${MyTargetID} && ${CombatStart} && ${DPSMeter}) {
            /echo SLAIN >> ${MyTargetName} << 
            /echo EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /popup SLAIN >> ${MyTargetName} << EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /if (!${DPSLastTime}) {
                /echo DPS Meter: Was a timing error skipping DPS Meter
            } else {
                | My damage calculation
				/if (${Bool[${Plugin[MQ2DamageParser]}]}==TRUE) {
					/varset DPSTotal ${Damage.Individual[${MyTargetID}]}
					/if (${Pet.ID}) {
						/varset DPSPetTotal ${Damage.Individual[${MyTargetID},${Pet.ID}]}
					}
					/if (${Damage.Total[${MyTargetID}]} && ${DPSTotal}) {
						/varset DPSCalcPct ${Math.Calc[${DPSTotal} / ${Damage.Total[${MyTargetID}]} * 100]}
						/if (${Bool[${Plugin[MQ2EQBC]}]}) {
							/call BCTell ${MainAssist} "I did ${DPSCalcPct} percent of all damage. Total DPS Average over ${Damage.TotalFightingTime.TotalSeconds} seconds: ${Damage.Average}"
						}
					}
				}
                /varset DPSCalc ${Math.Calc[${DPSTotal}/${DPSLastTime}]}
                /call CommaMeBro ${DPSCalc}
                /if (${Macro.Return.Length}) /varset DPSMyDam ${Macro.Return}
                /call CommaMeBro ${DPSTotal}
                /if (${Macro.Return.Length}) /varset DPSTCalc ${Macro.Return}
                /call CommaMeBro ${Damage.Total[${MyTargetID}]}
                /if (${Macro.Return.Length}) /varset DPSMPCalc ${Macro.Return}
                /echo \aw DPS Meter (${MyTargetID}) - \ay You did: \at ${DPSTCalc} out of ${DPSMPCalc} Total Damage (${DPSCalcPct}%) - \ay Fight Time: \aw ${DPSLastTime}s - \ay DPS: \ag ${DPSMyDam}
                | My pet damage calculation
                /if (${DPSPetTotal}) {
                    /varset DPSPCalc ${Math.Calc[${DPSPetTotal}/${DPSLastTime}]}
                    /call CommaMeBro ${DPSPCalc}
                    /if (${Macro.Return.Length}) /varset DPSMyPetDam ${Macro.Return}
                    /call CommaMeBro ${DPSPetTotal}
                    /if (${Macro.Return.Length}) /varset DPSPTCalc ${Macro.Return}
                    /echo \aw DPS Meter - \ay Pet Total Damage: \at ${DPSPTCalc} \ay - Pet DPS: \ag ${DPSMyPetDam}
                    | Me + pet damage calculation
                    /varset DPSMPCalc ${Math.Calc[(${DPSTotal}+${DPSPetTotal})/${DPSLastTime}]}
                    /call CommaMeBro ${DPSMPCalc}
                    /if (${Macro.Return.Length}) /varset DPSMeAndPetDam ${Macro.Return}
                    /call CommaMeBro ${Math.Calc[${DPSTotal}+${DPSPetTotal}]}
                    /if (${Macro.Return.Length}) /varset DPSMPTCalc ${Macro.Return}
                    /echo \aw DPS Meter - \ay You + Pet Total Damage: \at ${DPSMPTCalc} \ay - DPS: \ag ${DPSMeAndPetDam}
                }
                /popup Total Damage: ${DPSTCalc} - Fight Time: ${DPSLastTime}s - DPS: ${DPSMyDam}
                /if (${Defined[ParseDPS]} || ${DPSWriteOn}) {
                    /ini "Muleassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-${Me.Class}-${Me.Level}" "Total Damage: ${DPSTCalc} - Fight Time: ${DPSLastTime}s - DPS: ${DPSMyDam}"
                    /if (${DPSPetTotal}) {
                        /ini "Muleassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-MyPet" "My Pet Total Damage: ${DPSPTCalc} - Pet DPS: ${DPSMyPetDam}"
                        /ini "Muleassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-Combined" "Me + Pet Total Damage: ${DPSMPTCalc} - Combined DPS: ${DPSMeAndPetDam}"
                    }
                }
            }
        }
        /declare i int local 0
        /declare j int local
        /call MobRadar ${MeleeDistance} CombatReset
        /for j 1 to 50
            /if (${AddsArray[${j},1].Equal[${MyTargetID}]}) /call RemoveFromArray AddsArray ${j}
            /if (${MobCount}==0) /call RemoveFromArray AddsArray ${j}
            /if (${MezOn} && ${j}<=13) {
                /if (${MezArray[${j},1].Equal[${MyTargetID}]} || (!${Spawn[${MezArray[${j},1]}].ID} && !${MezArray[${j},3].Equal[NULL]}) || ${Spawn[${MezArray[${j},1]}].Type.Equal[CORPSE]}) /call RemoveFromArray MezArray ${j}
                |/if (${MezCount[${j}]}==0) /call RemoveFromArray MezArray ${j}
            }
        /next j
        /if (${MezOn}) {
            /if (${MezImmuneIDs.Find[|${MyTargetID}]}) /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MyTargetID},]}
            /varset j 1
            /while (${Bool[${MezImmuneIDs.Arg[${j},|].Length}]}) {
                /if (!${Bool[${Spawn[${MezImmuneIDs.Arg[${j},|]}].ID}]} || ${Spawn[${MezImmuneIDs.Arg[${j},|]}].Type.Equal[corpse]} ) {
                    /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MezImmuneIDs.Arg[${j},|]},]}
                } else {
                    /varcalc j ${j}+1
                }
            }
        }
        /varset AggroTargetID2 0
        /varset MyTargetID 0
		/varset MTIDSetAt ${Macro.CurLine}
        /varset MyTargetName
        /varset ValidTarget 0
        /varset Pulled 0
        /varset NamedCheck 0
		|/echo LemonsDebug: ${CombatStart} Is CombatStart
      
        /if (${Me.Pet.ID} && ${Me.Pet.TargetOfTarget.ID}) {
            /varset PetAttack 0
            /pet back off
            /if (${PetHoldOn}) /pet ${PetHold} on
        }
        /if (${Defined[DPSTimeStart${MyTargetID}]}) /deletevar DPSTimeStart${MyTargetID}
        /varset DPSLastTime 0
        /varset DPSTotal 0
        /varset DPSTarget 0
        /varset DPSPetTotal 0
        /varset DPSCounter 0
        /varset BurnActive 0
		/if (${Role.Find[pull]}) /call PullReset
        /squelch /attack off
		/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
        /squelch /target clear
        /if (!${TwistOn}) {
			/if (${MeleeTwistOn}) /varset DPSTwisting 0
			}
        /if (${IAmABard}) /call DoBardStuff
        /call ClearOutAlerts 2
        /varset TankTimer 30s
		/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
        /squelch /target clear
        DEBUGCOMBAT CombatReset: Leave"
        /varset PetFollowTimer 60s
        |no... don't fucking reset events globally EVER, this is the job of each event sub, doing it here will ruin all other events that has not yet been processed.
		|/doevents flush
        /if (${Stick.Active} && !${ChaseAssist}) /stick off
        /if (${Select[${Me.Class.ShortName},ROG]}) /call Roguestuff
    /return
| -------------------------------------------------------------------------------------
| SUB: Reset DPS Timers after a mob death or mob switch. Is this even used anymore?
| -------------------------------------------------------------------------------------
Sub DPSTimerReset(sentFrom)
	/if (${DPSOn}) {
		/declare a int local
		DEBUGDPS Reset DPS Timers from ${sentFrom}
		/for a 1 to ${DPS.Size}
			/if (${Int[${DPS[${a}].Arg[2,|]}]}<101) { 
				/varset DPSTimer${a} 0
				/varset FDTimer${a}  0
				DEBUGDPS LemonsDebug: Setting DPSTimer${a} to ${DPSTimer${a}}"
		}
		/next a
	}
/return
| -------------------------------------------------------------------------------------
| SUB: Check for Adds
| -------------------------------------------------------------------------------------
    Sub CheckForAdds(CalledFrom)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
		/if (${Me.XTarget}==0) {
			|NOT your job, don't aggro stuff in camp, ever.
			|If this is needed add a new role for it,
			|call it, Addchecker or something.
			|It is my oppinion that the pulls should
			|be handled in the pull sub only,
			|and if there is a VALID mob in camp, it will be pulled from it.
			/return
		}
        DEBUGN  CheckForAdds: Enter from ${CalledFrom}"
        /call MobRadar ${MeleeDistance} CheckForAdds
        DEBUGN MobCount:${MobCount}"
        | If no mobs, in a DMZone or pulling Leave
        /if (${MobCount}<=1)  /return  
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Pulling}) /return
        /if (!${DPSOn} && !${MeleeOn}) /return
        /if ((${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius})) /return
        /if (${IAmDead}) /return        
        /if (${ChainPull}==2 || ${DPSPaused}) /return
        | If I have a valid living target in camp radius Leave
        /if (!${Target.ID} && ${MyTargetID} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<${CampRadius}) {
            /if (${MuleDebug}) /echo Targeting a mob 9: ${Spawn[${MyTargetID}]}
			/target id ${MyTargetID}
            /return
        }
        | Spam Adds in camp
        /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<=${CampRadius} && !${MyTargetID} && !${AddSpam}) {
            /popup Add(s) in camp detected          
            /if ((${MainAssist.Equal[${Me}]} || ${Select[${Role},tank,pullertank,pettank,pullerpettank]})) /call BroadCast r "Add(s) in camp detected"      
            /if (${Select[${Role},pullertank,pullerpettank]}) /varset Pulled 0
            /varset AddSpam 5s
			/if (${Target.ID}) /squelch /target clear
        }
        | Prevent puller from stalling if adds in camp and still returning from pulling mob.
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Pulled} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=15) /return
        /if (!${Target.ID} && ${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]}) {
		/if (${MuleDebug}) /echo Targeting a mob 10: ${Spawn[${AggroTargetID}]}
		/squelch /target ID ${Spawn[${AggroTargetID}].ID}
	}
        /if (${Target.Type.NotEqual[npc]} && ${Target.ID}) {
			/if (${MuleDebug}) /echo Targeting clear at\agLine#:${Macro.CurLine}
            /squelch /target clear
            /return
        }
        DEBUGN CheckForAdds: Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: AggroCheck
| -------------------------------------------------------------------------------------
Sub AggroCheck(int aID)
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
	DEBUGCOMBAT AggroCheck Enter ${aID}"
    /if (${Me.Level} < 20) /goto :leaveAggro
    /if (${Target.Type.Equal[corpse]}) /goto :leaveAggro
    /if (${Defined[ParseDPS]}) /goto :leaveAggro
    /declare i int local 0
	/declare j int local
    /declare AggroSpell string local
    /declare AggroGLT string local
    /declare AggroPCT int local    
    /declare AggroTarget string local
    /declare AggroTID int local
	/for i 1 to ${Aggro.Size}
		/varset AggroSpell ${Aggro[${i}].Arg[1,|]}
		/varset AggroPCT ${Aggro[${i}].Arg[2,|]}
		/varset AggroGLT ${Aggro[${i}].Arg[3,|]}
		/varset AggroTarget ${Aggro[${i}].Arg[4,|]}
		DEBUGCOMBAT AggroCheck ${i} out of ${Aggro.Size} ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell}"
		DEBUGCOMBAT TankAll ID and i ${aID}&& ${i} == 1 ${AggroSpell} ${AggroTarget}"
		/if (${aID} && ${i} == 1) {
			DEBUGCOMBAT TankAllMobs sent from with id ${aID} on ${Spawn[${aID}]} and i is ${i}"
			/call CastWhat "${AggroSpell}" ${aID} Aggro
		}
		/if (${ConditionsOn} && ${DPSCOn} && ${If[${AggroCond[${i}]},0,1]}) /goto :NextAggro
		/if ((${AggroGLT.Equal[<]} && ${Me.PctAggro}<${AggroPCT}) || (${AggroGLT.Equal[>]} && ${Me.PctAggro}>${AggroPCT}) && (${Me.SpellReady[${AggroSpell}]} || ${Me.AbilityReady[${AggroSpell}]} || (${Me.CombatAbilityReady[${AggroSpell}]} && !${Me.ActiveDisc.ID}))) {
			DEBUGCOMBAT Trying to control Aggro: ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell}"
			/if (${Select[${AggroTarget},null,Mob]} || ${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}<${MeleeDistance} && !${aID}) {
				/varset AggroTID ${MyTargetID}
			} else /if (${Select[${AggroTarget},null,Mob]} || ${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}<${MeleeDistance} && ${aID}) {
				DEBUGCOMBAT Aggro: AggroTID is set to the ID sent in: ${aID}"
				/varset AggroTID ${aID}
			}
			/if (${AggroTarget.Equal[Me]}) /varset AggroTID ${Me.ID}
			/if (${AggroTarget.Equal[MA]}) /varset AggroTID ${Spawn[=${MainAssist}].ID}
			/if (${AggroTarget.Equal[Pet]}) /varset AggroTID ${Me.Pet.ID}
			/if (${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}<${MeleeDistance}) /goto :NextAggro
			DEBUGCOMBAT Aggro: Calling CastWhat ${AggroSpell} ${AggroTID} | MTID:${MyTargetID}"
			/call CastWhat "${AggroSpell}" ${AggroTID} Aggro
			/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
				DEBUGCOMBAT Casting >> ${AggroSpell} << to control AGGRO on ${Spawn[${AggroTID}].CleanName}."
				/if (${AggroGLT.Equal[>]}) {
					/if (!${AggroOffTimer}) {
					   /if (${Me.Feigning} || ${Me.Invis}) /varset AggroOffTimer 20
					}
				}
				/return
			}  
		}
		:NextAggro
	/next i 
	:leaveAggro
    DEBUGCOMBAT AggroCheck Leave"
/return
| -------------------------------------------------------------------------------------
| SUB: TankAllMobs
| -------------------------------------------------------------------------------------
Sub TankAllMobs
	/declare j int local
	/declare i int local
	/declare mMobID int local
	/declare numMobs int local
	/varset numMobs TANKMOBS
	/if (!${Select[${Role},tank,pullertank,hunter]}) /return
	DEBUGCOMBAT TankAll: I'm the correct role and numMobs is ${numMobs}"
	/for j 1 to ${numMobs}
		/varset TankAllTimer ${TankAllTimer.OriginalValue}
		DEBUGCOMBAT TankAll: TankMobs is ${numMobs} on ${j}"
		/varset mMobID ${NearestSpawn[${j},${If[${ReturnToCamp},npc loc ${CampXLoc} ${CampYLoc} radius ${CampRadius} targetable zradius 10,npc radius ${CampRadius} targetable zradius 10]}].ID}
		DEBUGCOMBAT TankAll: Mob #${j} out of ${numMobs} for mMobID ${mMobID} | (${Spawn[${mMobID}]}) (${Spawn[${mMobID}].AssistName})"
		DEBUGCOMBAT TankAll: (Am I it's AssistName?:${Spawn[${mMobID}].AssistName.NotEqual[${Me}]} && ${Spawn[${mMobID}]}'s AssistName: ${Spawn[${Spawn[${mMobID}].AssistName}].ID} && PlayerState: ${Spawn[${mMobID}].PlayerState})"
		/if (${Spawn[${mMobID}].AssistName.NotEqual[${Me}]} && ${Spawn[${Spawn[${mMobID}].AssistName}].ID} && ${Spawn[${mMobID}].PlayerState}) {
			DEBUGCOMBAT I'm not the target of ${Spawn[${mMobID}]} ${mMobID}. Their target is ${Spawn[${mMobID}].AssistName}"
			:getAggro
			|/echo j${j} target of ${mMobID} ${Spawn[${mMobID}]} AssistName:(${Spawn[${mMobID}].AssistName} && Spawn AssistName:${Spawn[${Spawn[${mMobID}].AssistName}]} && Player State:${Spawn[${mMobID}].PlayerState}) timer ${TankAllTimer}
			/if (${Me.Hovering}) /return
			DEBUGCOMBAT TankAll: getAggro top on ${j} out of ${numMobs} for New TargetIDP:${mMobID} and actual TID: ${Target} ${Target.ID}"
			/if (${MyTargetID} == ${mMobID}) {
				DEBUGCOMBAT TankAll: This mob ${Target} ${Target.ID}(${mMobID}) is already my main target ${MyTargetID}, don't need to use TankAll"
				/continue
			}
			/if (!${Spawn[${Spawn[${mMobID}].AssistName} group].ID} && !${Spawn[${Spawn[${mMobID}].AssistName} raid].ID}) {
				DEBUGCOMBAT TankAll: Target isn't aggroed my group or raid, leaving ${Target} alone | ${Target.AssistName} !${Spawn[${Target.AssistName} group].ID} && !${Spawn[${Target.AssistName} raid].ID}. "
				/continue
			}
			/if (${Spawn[${mMobID} noalert 3].ID} || ${MobsToIgnore.Find[${Spawn[${mMobID}].CleanName}]}) {
				DEBUGCOMBAT TankAll: ${Target} is on noalert ignore list 3 ${Spawn[${mMobID} noalert 3]} || ${MobsToIgnore.Find[${Spawn[${mMobID}].CleanName}]}"
				/continue
			}
			/if (${Select[${Spawn[${mMobID}].Animation},26,32,71,72,17,111,129]}) {
				DEBUGCOMBAT TankAll: Mob is probably mezzed, not gonna try to get aggro Name:${Spawn[${mMobID}]} ID:${mMobID} Anim:${Spawn[${mMobID}]}"
				/continue
			}
			/target id ${mMobID}
			/delay 2s ${Target.ID} == ${mMobID}
			/delay 2s ${Target.BuffsPopulated}
			/if (!${Ini[Animation.ini,${Me},${Target.Mezzed},${Spawn[${mMobID}].Animation}].Length}) {
				/ini Animation.ini "${Me}" "${Target.Mezzed}" "${Spawn[${mMobID}].Animation}"
			} else /if (${Ini[Animation.ini,${Me},${Target.Mezzed},${Spawn[${mMobID}].Animation}].NotEqual[${Spawn[${mMobID}].Animation}]}) {
				/ini Animation.ini "${Me}" "${Target.Mezzed}" "${Spawn[${mMobID}].Animation}"
			}	
			/if (!${Ini[Animation.ini,${Me},${Target.Rooted},${Spawn[${mMobID}].Animation}].Length}) {
				/ini Animation.ini "${Me}" "${Target.Rooted}" "${Spawn[${mMobID}].Animation}"
			} else /if (${Ini[Animation.ini,${Me},${Target.Rooted},${Spawn[${mMobID}].Animation}].NotEqual[${Spawn[${mMobID}].Animation}]}) {
				/ini Animation.ini "${Me}" "${Target.Rooted}" "${Spawn[${mMobID}].Animation}"
			}			
			/if (${Me.Combat}) {
				DEBUGCOMBAT TankAll:Turning off attack since it looks like I'll need to get the aggro on ${Target} ${Target.ID}(${mMobID}) ${Spawn[${mMobID}].AssistName}"
				/attack off
			}
			/if (${Target.ID} != ${mMobID}) {
				DEBUGCOMBAT TankAll: Couldn't targe the mob ${mMobID} ${Spawn[${mMobID}]} | ${Target} ${Target.ID}"
				/continue
			}
			/if (${Target.Mezzed.ID}) {
				DEBUGCOMBAT TankAll: ${Target} is mezzed, don't need to get aggro"
				/continue
			}
			/if (${Target.Rooted.ID}) {
				DEBUGCOMBAT TankAll: ${Target} is rooted, don't need to get aggro"
				/continue
			}			
			DEBUGCOMBAT TankAll: Trying to get aggro on ${Target} ${Target.ID} while MTID is ${MyTargetID}"
			/if (!${Me.Combat}) {
				/attack on
				/delay 1s ${Me.Combat}
				DEBUGCOMBAT I'm not attacking, trying to turn on attack on ${Target} ${Target.ID} who is ${Target.Distance}ft"
			}
			/if (${UseMQ2Melee}) {
				/killthis ${mMobID}
				/if (WITHINCAMP && ${Target.Distance} > 13 && ${Target.Distance} < ${Math.Calc[2*${CampRadius}]}) {
					DEBUGCOMBAT Naving to ${Target} WITHINCAMP && ${Target.Distance} > 13 && ${Target.Distance} < ${Math.Calc[2*${CampRadius}]}"
					/stick off
					/play off
					/nav target
					/delay 7 ${Target.Distance} < 14
				}
				/if (${Me.AbilityReady[taunt]}) /doability taunt
				/if (${Navigation.Active}) /nav stop
				/call AggroCheck ${mMobID}
				/if ((${Spawn[${mMobID}].AssistName.NotEqual[${Me}]} && ${Target.ID} == ${mMobID}) || ${TankAllTimer}) /goto :getAggro
			} else {
				/if (WITHINCAMP && ${Target.Distance} > 13 && ${Target.Distance} < ${Math.Calc[2*${CampRadius}]}) {
					DEBUGCOMBAT Naving to ${Target} WITHINCAMP && ${Target.Distance} > 13 && ${Target.Distance} < ${Math.Calc[2*${CampRadius}]}"
					/stick off
					/play off
					/delay 2
					/nav target
					/delay 7 ${Target.Distance} < 12
					DEBUGMOVE Stick"
					/stick ${StickHow}
				}
				/face fast
				/if (${Me.AbilityReady[taunt]}) /doability taunt
				/if (!${Me.Combat}) {
					/attack on
					/delay 1s ${Me.Combat}
					DEBUGCOMBAT I'm not attacking, trying to turn on attack on ${Target} ${Target.ID} who is ${Target.Distance}ft"
				}
				/if (${Navigation.Active}) /nav stop
				/call AggroCheck ${mMobID}
				DEBUGCOMBAT TankAll: Did it work? (${Spawn[${mMobID}].AssistName.Equal[${Me}]})
				/if (!${Spawn[${mMobID}].AssistName.Equal[${Me}]} && ${Target.ID} == ${mMobID} && !${TankAllTimer}) /goto :getAggro
			}
			
		}
	|/echo j${j} I am already target of ${mMobID} ${Spawn[${mMobID}]} or is mezzed: (${Spawn[${mMobID}].AssistName} && ${Spawn[${Spawn[${mMobID}].AssistName}]} && ${Spawn[${mMobID}].PlayerState})
	/next j
	/delay 1s
/stick unpause	
/if (!${Me.Combat}) {
	/attack on
	/delay 1s ${Me.Combat}
	DEBUGCOMBAT I'm not attacking, trying to turn on attack on ${Target} ${Target.ID} who is ${Target.Distance}ft"
}
/return
| -------------------------------------------------------------------------------------
| SUB: WaitCast
| -------------------------------------------------------------------------------------
Sub WaitCast(string sentFromWC, int casttime, wSpell)
	/declare bFirstCheck int local 0
	/varset GemStuckTimer 20s
	/declare cTimer timer local ${Math.Calc[${casttime}+20]}
	DEBUGCAST WaitCast Enter WaitCast SF:${sentFromWC} | Ct:${casttime} | Sp:${wSpell} | ct:${cTimer}"
:rewaitcast
	DEBUGCAST WaitCast Rewait casttime:${casttime} Name:${Me.Casting}"
	/if (${MapTheZone}) /call ZoneMap FALSE med
	/if (${Me.BardSongPlaying}) {
		/delay 1
		/if (${Window[CastingWindow].Open}==FALSE) {
			DEBUGCAST WaitCast returning from waitcast because im a bard and im not technically casting right now, just playing songs."
			|delayremove/delay 1
			/return
		}
	}
	/if (${Me.Hovering}) /return
	/if (${Window[SpellBookWnd]}) {
		DEBUGN Standing at\agLine#:${Macro.CurLine}"
		/windowstate spellbookwnd close
		/delay 1
	}
	/if (${sentFromWC.Equal[SingleHeal]} && ((${CastingInterruptOn}) || ${InterruptHeals} < 100)) {
		/call KACheckHP ${wSpell}
	} else /if (${Select[${sentFromWC},dps,gom,burn]} > 0 && ${CastingInterruptOn}) {
		|/echo checking castinginterrupt for ${sentFromWC} \agLine#:${Macro.CurLine}
		/call KACheckDPS
		/if (${CastResult.Equal[CAST_CANCELLED]}) {
			DEBUGCAST WaitCast Casting Interrupted mob is dead. \agLine#:${Macro.CurLine}"
			/return
		}
	} else /if (${Select[${sentFromWC},buffs,buffs-nomem]} > 0 && ${CastingInterruptOn}) {
		/call KACheckBUFFS
	} else /if (${CastingInterruptOn} && ${MezOn} && !${Select[${sentFromWC},ohshitstuff,mez,CharmStuff]}) {
        /varset MezBroke 0
        /doevents MezBroke
        }
	/if (${bFirstCheck}==0 && ${casttime}!=0 && !${Me.Casting.ID}) {
		/varset bFirstCheck 1
		/delay 5 ${Me.Casting.ID}
	}
	/if (${casttime}!=0) /delay 3 ${Me.Casting.ID}
	DEBUGCAST WaitCast casttime is ${casttime} and CID:${Me.Casting.ID} N:${Me.Casting} cT: ${cTimer} BardSong:${Me.BardSongPlaying}"
	:waitcasttime
  |/if (!${Int[${Math.Calc[${Time.Second} % 10]}]}) /echo WaitCast Checking interrupt Heal ${Me.CastTimeLeft} < 800 && (${Target.PctHPs}>${SHealPct} || ${Target.PctHPs} >= ${InterruptHeals}) && ${sentFromWC.Equal[SingleHeal]} && ${Me.Casting.ID}) ${sentFromWC}
   /if (${sentFromWC.Equal[SingleHeal]}) {
	   /if (${Me.CastTimeLeft} < 800 && (${Target.PctHPs} >= ${InterruptHeals}) && ${Me.Casting.ID}) {
			/echo Interrupting cause target ${Target} ${Target.PctHPs} is at or above ${InterruptHeals} or ${SHealPct} WaitCast
			/stopcast
			|delayremove
			/delay 2
			/varset CastResult CAST_SUCCESS
			DEBUGN CheckHP2: ${Target.PctHPs} ${SHealPct}"
			DEBUGHEALS KACheckHP Interrupting because the target's ${Target.PctHPs} ${SHealPct} HP is past the InterruptHeals point ${Target.PctHPs}>${SHealPct} || ${Target.PctHPs}>= ${InterruptHeals}"
		   }
		|/if (${casttime}!=0 && ${Me.Casting.ID} && ${cTimer} && !${Me.BardSongPlaying}) /goto :waitcasttime
		}
	  |/if (!${BuffMode} && ${Role.Find[tank]} && ${AggroTargetID} && ${sentFromWC.Find[buff]}) {
	|	/echo Crap, I've got agro and I'm the tank! Stopping cast
	|	/stopcast
	|	/varset CastResult CAST_SUCCESS
	|	/return
	 | }
	/if (${Me.Casting.ID} && !${Me.BardSongPlaying}) {
		|you haven't recovered yet...
		/delay 1
		/if (${GemStuckTimer}==0) {
			DEBUGCAST WaitCast Stuck gems"
			/echo OUR GEMS ARE STUCK!
			/delay 1s
			/if (${GemStuckAbility.NotEqual[NULL]}) {
				/if (${Me.AltAbilityReady[${GemStuckAbility}]}) {
					/alt act ${Me.AltAbility[${GemStuckAbility}].ID}
					/delay 5s ${Me.SpellInCooldown}==FALSE
					/stopcast
				} else {
					/echo wating for ${GemStuckAbility} to be ready so we can unstick the gems
					/varset GemStuckTimer 2s
				}
			} else {
				/echo Your GemStuckAbility is set to NULL in the General section, so I cant unstick you.
				/varset GemStuckTimer 2s
			}
		}
		/goto :rewaitcast
	}
	/if (${Stick.Status.Equal[pause]}) {
		/afollow off
		/stick unpause
		}
	/if (${AdvPath.Paused} && !${Stick.Active}) /afollow unpause
	| Lets reuse the timer for a weavecheck
	/varset GemStuckTimer 5s
	DEBUGCAST WaitCast set CastResult to CAST_SUCCESS"
	/varset CastResult CAST_SUCCESS
	/for bFirstCheck 1 to 13
		/if (${Me.Gem[${bFirstCheck}].ID}) {
			/if (${Me.GemTimer[${bFirstCheck}]}==0) {
				/if (!${Me.SpellReady[${bFirstCheck}]}) {
					|/echo [${Time}] ok we found a gem that we can wait for
					:gemwait
					| Well this means we can weave like crazy so lets do that then...
					/if (${sentFromWC.Equal[DPS]}) {
						/call WeaveStuff ${Target.ID}
					}
					/if (${GemStuckTimer}==0 || (${sentFromWC.Find[pull]} && ${AggroTargetID})) {
						/doevents CastFailed
						/doevents CastResist
						/doevents CastMezImmune
						/doevents CastInterrupted
						/if (${Stick.Paused} || ${Navigation.Status.Equal[Paused]}) /delay 1
						DEBUGCAST WaitCast Leaving"
						/return ${CastResult}
					}
					/delay 1
					/if (${Me.SpellReady[${bFirstCheck}]}) {
						|/echo [${Time}] finished waiting lets return
						/doevents CastFailed
						/doevents CastResist
						/doevents CastMezImmune
						/doevents CastInterrupted
						/if (${Stick.Paused} || ${Navigation.Status.Equal[Paused]}) /delay 1
						DEBUGCAST WaitCast Leaving"
						/return ${CastResult}
					}
					/if (!${sentFromWC.Find[Heal]}) /goto :gemwait
				}
			}
		}
	/next bFirstCheck
	/doevents CastFailed
	/doevents CastResist
	/doevents CastMezImmune
	/doevents CastInterrupted
	DEBUGCAST WaitCast Leaving Waitcast with result ${CastResult}
	/if (${Stick.Paused} || ${Navigation.Status.Equal[Paused]}) /delay 2
	/return ${CastResult}

|--------------------------------------------------------------------------------------
| SUB: CastCommand
|--------------------------------------------------------------------------------------
        Sub CastCommand(string WhatSkill,int WhatID,int CastOnCorpse)
        |/call MuleSpew "${Macro.CurSub}" "${Macro.CurLine}" "Enter"
        /declare CommandText string local ${WhatSkill.Replace[command:,]}
		/declare CommandParams string local
		/if (${CommandText.Find[ ]}) {
			/varset CommandParams ${CommandText.Mid[${Math.Calc[${CommandText.Find[ ]}+1]},400]}
			/varset CommandText ${CommandText.Left[${Math.Calc[${CommandText.Find[ ]}-1]}]}
			|/echo command has a space in it. Command is now ${CommandText} and Params are ${CommandParams}
			|/mqp on
		}
        |/call MuleSpew "${Macro.CurSub}" "${Macro.CurLine}" "I will run ${CommandText} now"
        |/echo I will run ${CommandText} now ${Macro.CurSub}\agLine#:${Macro.CurLine}
        /docommand ${CommandText} ${CommandParams}
        /delay 2
        /varset CastResult CAST_SUCCESS
        |/call MuleSpew "${Macro.CurSub}" "${Macro.CurLine}" "Leave"
    /return ${CastResult} 
| -------------------------------------------------------------------------------------
| SUB: IsDisc - Kaen01
| -------------------------------------------------------------------------------------	
Sub IsDisc(string name) 
	|Lemons: Is it a disc that needs to be up in your CA window?
    /if (${Spell[${name}].IsSkill} && ${Spell[${name}].Duration} && !${Spell[${name}].StacksWithDiscs}) /return TRUE
/return FALSE	
| -------------------------------------------------------------------------------------
| SUB: CastWhat 5th added to not recast if the spell is interrupted 
| -------------------------------------------------------------------------------------
    Sub CastWhat(string castWhat,int castTargetID,string sentFromCW,int bDontCheckShit,int DontRecast, string passedType)
		/declare MyGemTimer timer local
		DEBUGCAST CastWhat Enter ${castWhat} ${castTargetID} ${sentFromCW} ${bDontCheckShit} ${DontRecast} \agLine#:${Macro.CurLine}"
		/if (${OhShitOn} && ${sentFromCW.NotEqual[OhShitStuff]}) {
			/if (!${bDontCheckShit}) {
				|DEBUGCAST Checking shit in CastWhat called from ${sentFromCW}"
				/call OhShitStuff "CastWhat"
			} else {
				DEBUGCAST Not checking shit we got called from it, dont want recursive calls..."
			}
		}
		/if (${Me.Hovering}) {
			/echo \ar Can't cast while I'm a ghost.
			DEBUGCAST CastW Can't cast while I'm a ghost."
			/return Dead
			}
		/if (${Me.Invulnerable.ID}) {
			/if (${Select[${Me.Class.ShortName},CLR,DRU,SHM]}) {
				/call GetHostilesOnXTarget
				/if (${Macro.Return} > 0) {
					/call BroadCast o "I'M INVULNERABLE !!! need to remove this crap so i can heal..."
					/removebuff ${Me.Invulnerable}
					/delay 5 !${Me.Invulnerable.ID}
				}
			}
		}
		/if (${CallCustomFunc}) {
			/call CustomFunc "${CustomFuncName}"
		}
		DEBUGCAST CastWhat: castWhat ${castWhat} CastonName: ${Spawn[id ${castTargetID}].CleanName} castTargetID - ${castTargetID} \awFrom: ${sentFromCW}"
		/declare WasTwisting bool local ${Twist}
		/varset CastResult CAST_NO_RESULT
		|***********************************| Check for command: |***************************************|
		/if (${castWhat.Find[command:]}) {
			DEBUGCAST CastW It's a command"
			/if (!${Me.Standing}) {
				DEBUGN going to stand"
				/if (!${standTimer}) /stand
				/delay 1s ${Me.Standing}
				/if (!${Me.Standing}) {
					DEBUGN Returning cause I'm not standing"
					/return Sitting
				}
			}
			|/beep
			|/popup gonna run ${castWhat} NOW!
			DEBUGCAST I am gonna run ${castWhat} NOW!"
			/call CastCommand "${castWhat}"
            |Kaen01::Resetting sittomedtimer after a cast.
            /varset SitToMedTimer ${SitToMedTimer.OriginalValue}
			/return ${CastResult}
		}
		|***********************************| SKILLS |***************************************|
		| Check for Skills
		/if (${Me.AbilityReady[${castWhat}]} && ${Me.SkillCap[${castWhat}]}) {
			DEBUGCAST CastW It's a skill"
			/if (!${Me.Standing}) {
				DEBUGN going to stand"
				/if (!${standTimer}) /stand
				/delay 1s ${Me.Standing}
				/if (!${Me.Standing}) {
					DEBUGN Returning cause I'm not standing"
					/return Sitting
				}
			}
			DEBUGCAST CastW CASTING Ability ${sentFromCW} -> ${castWhat} <- \agLine#:${Macro.CurLine}"
            /doability "${castWhat}"
            /call WaitCast ${sentFromCW} 0
            /if (!${Me.AbilityReady[${castWhat}]}) /varset CastResult CAST_SUCCESS
            /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
            |Kaen01::Resetting sittomedtimer after a cast.
            /if (${CastResult.Equal[CAST_SUCCESS]}) /varset SitToMedTimer ${SitToMedTimer.OriginalValue}
            /return ${CastResult}
		} else /if (${Me.SkillCap[${castWhat}]}) {
			/return ${CastResult}
		}
        |***********************************| COMBAT ABILITIES | ***************************************|
        | - Check & cast if Combat ability/disc
        /if (${Me.CombatAbility[${castWhat}]} && !${Me.CombatAbilityTimer[${castWhat}]} && ${Me.CombatAbilityReady[${castWhat}]} && ${Spell[${castWhat}].EnduranceCost}<${Me.Endurance}) {
			/if (${FindItemCount[${Spell[${castWhat}].ReagentID[1]}]} < ${Spell[${castWhat}].ReagentCount[1]} && ${Spell[${castWhat}].ReagentID[1]} != -1) {
				DEBUGCAST Can't cast the disc ${castWhat} cause I don't have ${Spell[${castWhat}].ReagentID[1]}
				/return NoReagent
			}
            DEBUGCAST CastWhat: ${castWhat} \ayCombat ability/disc/discipline: CombatAbility:${Me.CombatAbility[${castWhat}]} CombatAbilityTimer:!${Me.CombatAbilityTimer[${castWhat}]} CombatAbilityReady:${Me.CombatAbilityReady[${castWhat}]}"
			/if (${WasTwisting}) {
				/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
				/squelch /twist stop
				/varset TwistStop ${Macro.CurLine}
				/delay 20 !${Twist}
			}
			DEBUGCAST CastWhat: \ayCombat ability/disc/discipline: ${castWhat} spell duration: ${Spell[${castWhat}].Duration.TotalSeconds} - discid: ${Me.ActiveDisc.ID}"
			/call IsDisc "${castWhat}"
			DEBUGCAST CastWhat: Is it a Discipline with a duration in the CA window || I have no disc running? ${Macro.Return} || !${Me.ActiveDisc.ID}"
			/if ((${Macro.Return} && !${Me.ActiveDisc.ID}) || !${Me.ActiveDisc.ID} || !${Macro.Return}) {
                /if (${Target.ID}!=${castTargetID} && ${Spawn[id ${castTargetID}].ID}) {
                    /if (${MuleDebug}) /echo Targeting a mob 11: ${Spawn[${castTargetID}]}
					/target id ${castTargetID}
                    /delay 10 ${Target.ID}==${castTargetID}
                }
				/if (!${Me.Standing}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return Sitting
					}
				}
				/echo \ay CASTING Disc ${sentFromCW} -> \ag ${castWhat} \ax<-
				/call CastDisc "${castWhat}" 0
				|Lemons: Wtf. We're just calling castdisc without ever checking for endurance costs and assuming it worked when it came back...Newsflash, I'm drunk and some discs costs endurance. 
                /varset CastResult CAST_SUCCESS
            }
            /if (${WasTwisting} && !${Twist}) {
                |delayremove/delay 1s
                /squelch /twist
            }
			/delay 2 !${Me.CombatAbilityReady[${castWhat}]}         
            DEBUGCAST CastWhat: \ayLeave from DISC ${CastResult}"
            /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
            |Kaen01::Resetting sittomedtimer after a cast.
            /if (${CastResult.Equal[CAST_SUCCESS]}) /varset SitToMedTimer ${SitToMedTimer.OriginalValue}
            /return ${CastResult}
        }
        |***********************************| ITEMS |***************************************|
        | - Check & cast if item
		|***********************************| Check for item: |***************************************|
		/if (${castWhat.Find[item:]}) {
			DEBUGCAST CastW It's an item"
			|/beep
			/declare ItemText string local ${castWhat.Replace[item:,]}
			/varset castWhat ${FindItem[=${ItemText}].Name}
			/popup gonna cast an item ${castWhat} NOW!
			/echo \ay Casting an item \ao ${castWhat} \ayNOW!
		}

        /if (${FindItem[=${castWhat}].ID} && ${Me.ItemReady[${castWhat}]} && ${FindItem[=${castWhat}].Clicky.Spell.ID}) {
			/if (${passedType.NotEqual[item]} && ${sentFromCW.Find[beg]}) {
				DEBUGCAST CastW We have the item ${castWhat} but its from beg and the flag is ${passedType}"
				/goto :skipitem
			}
			DEBUGCAST CastW We have the item ${castWhat} | ${FindItem[=${castWhat}]}"
			DEBUGCAST [${Time}] \ayItemFound ${FindItem[=${castWhat}].ID} Ready: ${Me.ItemReady[${castWhat}]}"
            | Prevent casting of Prestige items on silver and F2P accounts
            /if (${Me.Subscription.NotEqual[gold]} && ${FindItem[=${castWhat}].Prestige}) /return Gold

            /if (${IAmABard}) {
                /if ((${WasTwisting} || (!${Me.SpellReady[1]} && !${Me.SpellReady[2]} && !${Me.SpellReady[3]} && !${Me.SpellReady[4]}) || ${Twist.Twisting}) && ${FindItem[=${castWhat}].CastTime}) {
					DEBUGCAST Stopping twist"
					/echo stopping twist \agLine#:${Macro.CurLine}
                    /twist stop
                    /delay 1s !${Twist}
                    /stopsong
					/varset TwistStop ${Macro.CurLine}
                    /delay 40 (!${Twist} && !${Me.Casting.ID} && (${Me.SpellReady[1]} && ${Me.SpellReady[2]} && ${Me.SpellReady[3]} && ${Me.SpellReady[4]})) 
					DEBUGCAST Twist status is ${Twist} MCID:${Me.Casting.ID}"					
                }
				/if (${Target.ID}!=${castTargetID} && ${Spawn[id ${castTargetID}].ID}) {
					DEBUGCAST Targeting a mob 12: ${Spawn[${castTargetID}]}"
					/if (${MuleDebug}) /echo Targeting a mob 12: ${Spawn[${castTargetID}]}
					/target id ${castTargetID}
					/delay 10 ${Target.ID}==${castTargetID}
				}
				/if (!${Me.Standing}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return Sitting
					}
				}
				DEBUGCAST CASTING ITEMB ${sentFromCW} -> ${castWhat}"
				/echo \ayCASTING ITEMB ${sentFromCW} -> \ao${castWhat} \ay<-
				/if (${Select[${sentFromCW},OOGBuffs,OOGBuffs-nomem]}) {
					/varcalc castedOOGs ${castedOOGs}+1				
					/echo \agOOG [${Time}] Buff ${castWhat} on ${Target.Class} ${Target} (${Spawn[${castTargetID}]}). #of OOGBuffs casted is ${castedOOGs}
					DEBUGBUFF OOG [${Time}] Buff ${castWhat} on ${Target.Class} ${Target} (${Spawn[${castTargetID}]}). #of OOGBuffs casted is ${castedOOGs}"
				}
                /useitem ${castWhat}
				/if (${FindItem[=${castWhat}].CastTime}) /delay 5 ${Me.Casting.ID}
				/call WaitCast ${sentFromCW} ${FindItem[=${castWhat}].CastTime}
				DEBUGCAST Back from WaitCast"
                /varset CastResult CAST_SUCCESS
                /if (${WasTwisting} && !${Twist}) {
					/if (${MuleDebug}) /echo Resuming twist at \ag${Macro.CurLine}
                    /twist
                }
                /doevents
                /return ${CastResult}
            }
            /if (${Target.ID}!=${castTargetID} && ${Spawn[id ${castTargetID}].ID}) {
				DEBUGCAST Targeting ${castTargetID}"
                /if (${MuleDebug}) /echo Targeting a mob 12: ${Spawn[${castTargetID}]}
				/target id ${castTargetID}
                /delay 10 ${Target.ID}==${castTargetID}
            }
			/echo \ayCASTING ITEM ${sentFromCW} -> \ao${castWhat} \ay<-
            /useitem "${castWhat}"
			DEBUGCAST Cast: Item used with timers of ${FindItem[=${castWhat}].Clicky.Spell.MyCastTime}>0 || ${FindItem[=${castWhat}].Clicky.CastTime}>0"
			/if (${FindItem[=${castWhat}].Clicky.Spell.MyCastTime}>0 || ${FindItem[=${castWhat}].Clicky.CastTime}>0) {
				|delayremove
				/delay 1
				/delay 5 ${Me.Casting.ID}
			}
			DEBUGCAST Cast: Calling Item Waitcast with ${sentFromCW} ${FindItem[=${castWhat}].CastTime} ${FindItem[=${castWhat}].Clicky}"
			/call WaitCast ${sentFromCW} ${FindItem[=${castWhat}].CastTime} "${FindItem[=${castWhat}].Clicky}"
			/varset CastResult CAST_SUCCESS
			DEBUGCAST Cast: CastWhat Leave item cast result ${CastResult}"
            /doevents
            |Kaen01::Resetting sittomedtimer after a cast.
            /varset SitToMedTimer ${SitToMedTimer.OriginalValue}
            /return ${CastResult}
        }
		:skipitem
        |***********************************| ALTERNATE ABILITIES |***************************************|
        | - Check & cast if AA | do not cast if it is a focus aa (${Me.AltAbility[${castWhat}].Type}!=5) for a spell of same name !!!!!!!                
        /if (${Me.AltAbility[${castWhat}]} && ${Me.AltAbilityReady[${castWhat}]} && ${Me.AltAbility[${castWhat}].Type}!=5 && ${castWhat.NotEqual[twincast]} && (!${Spell[${AltAbility[${castWhat}].Spell}].ReagentID} || ${FindItemCount[${Spell[${AltAbility[${castWhat}].Spell}].ReagentID[1]}]} >= ${Spell[${AltAbility[${castWhat}].Spell}].ReagentCount[1]}))  { 
            /if (${Select[${castWhat},Banestrike,15073]} && !${Banestrike.Find[|${Target.Race}|]} && ${Spawn[${MyTargetID}].Distance3D}>70 && ${CombatStart}) /return Banestrike
            DEBUGCAST CastWhat: \ayStart of AbilityCheck and exceptions."
            /if (${Target.ID}!=${castTargetID} && ${Spawn[id ${castTargetID}].ID}) {
				/if (${MuleDebug}) /echo Targeting a mob 13: ${Spawn[${castTargetID}]}
                /target id ${castTargetID}
                /delay 10 ${Target.ID}==${castTargetID}
            }
			/if (!${Me.Standing}) {
				DEBUGN going to stand"
				/if (!${standTimer}) /stand
				/delay 1s ${Me.Standing}
				/if (!${Me.Standing}) {
					DEBUGN Returning cause I'm not standing"
					/return Sitting
				}
			}
			/if (${Select[${sentFromCW},OOGBuffs,OOGBuffs-nomem]}) {
				/varcalc castedOOGs ${castedOOGs}+1			
				/echo \agOOG [${Time}] Buff ${castWhat} on ${Target.Class} ${Target} (${Spawn[${castTargetID}]}). #of OOGBuffs casted is ${castedOOGs}
			}	
			DEBUGCAST CastW CASTING AA ${sentFromCW} -> ${castWhat} ${Me.AltAbility[${castWhat}].Spell.CastTime}ms <- \agLine#:${Macro.CurLine}"			
			/echo \ayCASTING AA ${sentFromCW} -> \at${castWhat} ${Me.AltAbility[${castWhat}].Spell.CastTime}ms \ay<- 
            /alt act ${Me.AltAbility[${castWhat}].ID}
			/if (${Me.AltAbility[${castWhat}].Spell.MyCastTime}) {
				/call WaitCast ${sentFromCW} ${Me.AltAbility[${castWhat}].Spell.MyCastTime} "${Me.AltAbility[${castWhat}].Spell}"
			} else {
				/call WaitCast ${sentFromCW} 1000 "${Me.AltAbility[${castWhat}].Spell}"
			}
			/delay 2 !${Me.AltAbilityReady[${castWhat}]}
            /if (${Me.AltAbilityReady[${castWhat}]}) {
                /varset CastResult CAST_RECOVER
            } else {
                /varset CastResult CAST_SUCCESS
            }
            /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
            |Kaen01::Resetting sittomedtimer after a cast.
            /if (${CastResult.Equal[CAST_SUCCESS]}) /varset SitToMedTimer ${SitToMedTimer.OriginalValue}            
            /return ${CastResult}
        }
        | Always use AA if it exists for Voice of Thule}
        /if (${castWhat.Equal[Voice of Thule]} && ${Me.AltAbility[Voice of Thule]}) /return VoT
        |***********************************| SPELLS |***************************************|
        | - Check & cast if spell
		DEBUGCAST Checking if we have ${castWhat}"
		/if (${Me.Book[${castWhat}]} && (${IAmABard} || !${IAmABard} && ${Spell[${castWhat}].Mana} <= ${Me.CurrentMana})) {
			DEBUGCAST CastW It's a spell"
			DEBUGCAST \aySpellCheck HaveSpell:${Me.Book[${castWhat}]} HaveMana:${Spell[${castWhat}].Mana}<=${Me.CurrentMana}"
            | Avoid confusion between spells and items of the same name. e.g. mage Wand of Phantasmal Modulation
			|Lemons: If we have an item that has the same name as the spell itself and we don't have the spell in our book, then we can leave. If we have both, then we try to cast the spell.
            /if (${FindItem[=${castWhat}].ID} && !${Me.Book[${FindItem[${castWhat}].Spell}]}) /return NoItem
            | Mem spell if not memmed
            /if (${Target.ID}!=${castTargetID} && ${Spell[${castWhat}].TargetType.NotEqual[Self]} && ${Spawn[id ${castTargetID}].ID}) {
				DEBUGCAST CastW Need to target ${Spawn[${castTargetID}]}"
                /if (${MuleDebug}) /echo Targeting a mob 14: ${Spawn[${castTargetID}]} \agLine#:${Macro.CurLine}
				/if (${castTargetID} == ${Me.ID}) {
					/if (${Spell[${castWhat}].HasSPA[0]} && ${Spell[${castWhat}].TargetType.Find[group]}) {
					} else {
					/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
					/target id ${castTargetID}
					/delay 10 ${Target.ID}==${castTargetID}
					}
				} else {
				/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
				/target id ${castTargetID}
				/delay 10 ${Target.ID}==${castTargetID}
				}
            }
            /if (!${Target.CanSplashLand} && ${Spell[${Me.Book[${Me.Book[${castWhat}]}].ID}].TargetType.Equal[Free Target]}) {
				DEBUGCAST CastW Splash spell wouldn't land, exiting castwhat"
               /if (${MuleDebug}) /echo Splash Spell will not cast at targets location. Skipping ${castWhat} \agLine#:${Macro.CurLine}
               /return SplashFail
            }
			/if (${Spell[${castWhat}].SpellType.Find[beneficial]} && ${Spell[${castWhat}].Duration} > 0) {
				DEBUGCAST CastW This is a beneficial spell with a duration. Delay until we know their buffs. \agLine#:${Macro.CurLine}"
				/if (${MapTheZone}) /call ZoneMap FALSE med
				/delay 2s ${Target.BuffsPopulated} > 0
				|delayremove/delay 2
				/if (${ActNatural}) /delay 15
				DEBUGCAST CastW (!${Spell[${castWhat}].StacksSpawn[${castTargetID}]} || (${Target.BuffDuration[${castWhat}]} > 180 && (!${Select[${sentFromCW},BuffBeg,OhShitstuff,OOGBuffs-nomem]} || (${sentFromCW.Equal[OOGBuffs-nomem]} && !${Select[${Zone.ShortName},poKnowledge,guildlobby,guildhall]})))) \agLine#:${Macro.CurLine}"
				/if (!${Spell[${castWhat}].StacksSpawn[${castTargetID}]}) {
					DEBUGCAST CastW Not going to cast ${castWhat} because it doesnt stack on ${Spawn[${castTargetID}]}\agLine#:${Macro.CurLine}"
					/goto :skipbuff
				}
				|15.3.3 Is the OOGBuffs-nomem tag the thing making them double stack buffs in raid OOG? Why did I not want to check if it existed?
				/if (${Target.BuffDuration[${castWhat}]} > 180 && !${Select[${sentFromCW},BuffBeg,OhShitstuff]}) {
					DEBUGCAST CastW Not going to cast ${castWhat} the duration ${Spawn[${castTargetID}].CachedBuff[${castWhat}].Duration} > 180 \agLine#:${Macro.CurLine}"
					/goto :skipbuff
				}
				|Lemons: See if we've checked if it will stick, or if we already checked.
				/if (!${StickChecked}) {
					/call WillItStick "${castWhat}" ${castTargetID}
					/if (${Macro.Return.Find[bad]}) {
						DEBUGCAST CastW Not going to cast ${castWhat} cause WillItStick was ${Macro.Return} for ${Spawn[${castTargetID}].CleanName} ${Spawn[${castTargetID}].Level} \agLine#:${Macro.CurLine}"
						/goto :skipbuff
					}
				}
			}
			DEBUGCAST CastW should we be able to cast it? (${Me.GemTimer[${castWhat}]}==0 && !${IAmABard} && (!${Spell[${castWhat}].ReagentID} || ${FindItemCount[${Spell[${castWhat}].ReagentID[1]}]} >= ${Spell[${castWhat}].ReagentCount[1]}))"
            /if (${Me.GemTimer[${castWhat}]}==0 && !${IAmABard} && (!${Spell[${castWhat}].ReagentID} || ${FindItemCount[${Spell[${castWhat}].ReagentID[1]}]} >= ${Spell[${castWhat}].ReagentCount[1]})) {
				DEBUGCAST CastW It's a spell and we should be able to cast it"
				|/if (${Bool[${Me.Gem[${castWhat}]}]}==FALSE) {
				|	|need to mem it first
				|	/memorize "${castWhat}" gem${MiscGem}
				|	/delay ${Spell[${castWhat}].RecastTime.TotalSeconds}s
				|	/delay 2s ${Bool[${Me.Gem[${castWhat}]}]}==TRUE
				|	/delay 1s
				|}
				/if (${sentFromCW.Find[Pull]}) {
					DEBUGCAST CastW It's a spell and we were sent from Pull"
		            |/echo not gonna cast twice even if resist, cause this IS a pull cast...
					/echo \ay[${Time}] CASTING SPELL ${sentFromCW} -> \am${castWhat} \ay<- 
					/if (!${Me.Gem[${castWhat}]}) {
						/echo I was told to cast ${castWhat} from ${sentFromCW} but I don't have it memmed! \agLine#:${Macro.CurLine}
						| Prevent tanks trying to mem spells during combat. Since this could be the only heal, it will try to mem a heal during combat. Mem your heals if you don't like it. 
						/if (${Attacking} && ${MainAssist.Equal[${Me}]} || ${HealsOn} && ${AggroTargetID} && !${sentFromCW.Find[Heal]}) {
							DEBUGCAST CastW Pull It's a spell but I'm not gonna memorize it now cause it's not a heal and we are attacking"
							/echo I can't memorize ${castWhat} right now \agLine#:${Macro.CurLine}
							/return MidCombat
						}
						/if (${Cursor.ID}) /call CheckCursor
						/if (${MiscGemRemem} && ${MiscGemLW} && ${Spell[${castWhat}].RecastTime.TotalSeconds}>30 && ${ReMemWaitLong.Equal[null]}) {
							/varset ReMemWaitLong ${castWhat}
							DEBUGCAST CastW calling MemSpell in CastWhat with MiscGemLW 1 for ${castWhat} \agLine#:${Macro.CurLine}"
							/call MemSpell "${castWhat}" ${MiscGemLW} 0
							/echo Returning after memming the spell? \agLine#:${Macro.CurLine}
							/return ${CastResult}
						}
						/varset ReMemWaitShort ${castWhat}
						DEBUGCAST CastW Pull calling MemSpell in CastWhat with MiscGem 2 for ${castWhat} \agLine#:${Macro.CurLine}"
						/if (${MuleDebug}) /echo [${Time}] Pre Memspell for ${castWhat} \agLine#:${Macro.CurLine}
						/if (${sentFromCW.Find[Heal]}) /call BroadCast r "I don't have my heal spell ${castWhat} ready! You should save it. Trying to mem...hold on!~"
						/call MemSpell "${castWhat}" ${MiscGem} 0 ${sentFromCW}
						DEBUGCAST CastW PullBack from MemSpell 2"
						/delay 10 ${Me.GemTimer[${castWhat}]}!=0
						/if (${Me.GemTimer[${castWhat}]}!=0) /varset MyGemTimer 15s
						|If the memming process gets interupted for whatever reason except mob agro, we're stuck in here for a hard 35s.
						:gemdelay
						|DEBUGCAST CastW PullIn Gemdelay waiting for spell to be ready"
						/if (${Me.SpellReady[${castWhat}]} == FALSE || ${Me.GemTimer[${castWhat}]}!=0) {
							/if (${MyGemTimer}!=0) {
								/goto :gemdelay
							}
						}
						DEBUGCAST CastW Pull Post Memspell for ${castWhat}  \agLine#:${Macro.CurLine}"
						/delay 2
					}
					:retryduetofizzle
					/if (!${Me.Standing}) {
						DEBUGN going to stand"
						/if (!${standTimer}) /stand
						/delay 1s ${Me.Standing}
						/if (!${Me.Standing}) {
							DEBUGN Returning cause I'm not standing"
							/return Sitting
						}
					}
					DEBUGCAST CastW Pull calling MemSpell in CastWhat with MiscGemLW 1 for ${castWhat} \agLine#:${Macro.CurLine}"
					/cast ${Me.Gem[${castWhat}]}
					/if (${Spell[${castWhat}].MyCastTime} > 0) {
						/delay 5 ${Me.Casting.ID}
					}
					|Lemons: GetHostilesOnXTarget check is to see if the spell cast. Even if it didn't, we still got agro so we can move on. 
					/call WaitCast ${sentFromCW} ${Spell[${castWhat}].MyCastTime} "${Spell[${castWhat}]}"
					/call GetHostilesOnXTarget
					/if (${Macro.Return} > 0 && !${BuffMode}) {
						/varset CastResult CAST_SUCCESS
						/return ${CastResult}
					}
					|Lemons: No changes, but I think this should check and see if we got agro so we don't sit there trying to cast even if we did agro them. Haven't used pulling with spells enough to know yet.
					/if (${CastResult.Equal[CAST_FIZZLED]}) {
						/echo we fizzled trying to pull, not good gonna need to retry... \agLine#:${Macro.CurLine}
						|/beep
						/if (${Spell[${castWhat}].Mana} < ${Me.CurrentMana}) {
							/goto :retryduetofizzle
						}
					}
				/goto :donecast
				} 
				DEBUGCAST CastW We weren't sent from Pull, so do normal casting"
					/if (${Spell[${castWhat}].SpellType.Equal[Detrimental]} && ${Target.ID} && ${Target.Type.Equal[NPC]}) {
						DEBUGCAST CastW It's a detrimental spell"
						/if (${MoveCloserIfNoLOS} && !${Me.Rooted.ID}) {
							/if (!${Target.LineOfSight}) {
								/echo CASTING SPELL ${sentFromCW} -> ${castWhat} GOING TO FAIL: NO LOS <- \agLine#:${Macro.CurLine}
								/if (${Bool[${Plugin[MQ2Nav]}]} && ${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.PathExists[id ${MainAssistID}]} && !${Me.ID} == ${MainAssistID}) {
									/if (${Spawn[=${MainAssist}].Distance3D} < 150 && ${Target.Distance3D} < 150) {
										|/beep
										/if (${Me.Rooted.ID}) {
											/return Rooted
										}
										/call BCTExec ${Spawn[=${MainAssist}].Name} "/popup ${Me.Class} Needs to move closer in CastWhat"
										/echo I am assisting but I cant see the mob lets move closer \agLine#:${Macro.CurLine}
										|/call Bind_ToggleVariable ReturnToCamp off
										|/call Bind_ToggleVariable ChaseAssist off
        								/if (${MoveTo.Moving}) /moveto off
										/if (${Stick.Active}) /squelch /stick off
										/if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.Playing}) {
											/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
											/play off
 										}
										/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
										DEBUGMOVE Naving to MainAssist"
	            						/nav id ${Spawn[=${MainAssist}].ID}
										/varset LastMove ${Macro.CurLine}
										/delay 1s ${Navigation.Active}==TRUE
										/delay 5s ${Navigation.Active}==FALSE
										|delayremove/delay 1s
										/return Moveorsomething
									}
								}
	    					}
						}
						/if (!${Target.LineOfSight}) {
							DEBUGCAST CastW I have no LoS for this detrimental spell ${castWhat} on ${Target}! \agLine#:${Macro.CurLine}"
							/varset CastResult NoLOS
							/return ${CastResult}
						}
					} else {
						DEBUGCAST CastW Cast message: [${Time}] CASTING SPELL ${sentFromCW} -> ${castWhat} <- \agLine#:${Macro.CurLine}"
						/if (${MuleDebug}) /echo [${Time}] CASTING SPELL ${sentFromCW} -> ${castWhat} <- \agLine#:${Macro.CurLine}
					}
					:remem
					/if (!${Me.Gem[${castWhat}]}) {
						/echo \ar I was told to cast ${castWhat} from ${sentFromCW} but I don't have it memmed!2 \agLine#:${Macro.CurLine}
						DEBUGCAST I don't have ${castWhat} memmed coming from ${sentFromCW} while my target is ${Target.ID} and sent in is ${castTargetID}"
						| Prevent tanks trying to mem spells during combat. Since this could be the only heal, it will try to mem a heal during combat. Mem your heals if you don't like it. 
						/if (${Attacking} && ${MainAssist.Equal[${Me}]} || ${HealsOn} && ${AggroTargetID} && !${sentFromCW.Find[Heal]} && !${BuffMode}) {
							/echo I can't memorize ${castWhat} right now \agLine#:${Macro.CurLine}
							DEBUGCAST I can't memorize ${castWhat}. ${Attacking} && ${MainAssist.Equal[${Me}]} || ${HealsOn} && ${AggroTargetID} && !${sentFromCW.Find[Heal]}"
							/return Midcombat
						}
						/if (${Cursor.ID}) /call CheckCursor
						/if (${MiscGemRemem} && ${MiscGemLW} && ${Spell[${castWhat}].RecastTime.TotalSeconds}>30 && ${ReMemWaitLong.Equal[null]}) {
							/varset ReMemWaitLong ${castWhat}
							DEBUGCAST CastW calling MemSpell in CastWhat with MiscGemLW 1 for ${castWhat} \agLine#:${Macro.CurLine}"
							/call MemSpell "${castWhat}" ${MiscGemLW} 0
							DEBUGCAST Returning after memming the spell cause it's a long recast time and we have to wait \agLine#:${Macro.CurLine}"
							/return ${CastResult}
						}
						/varset ReMemWaitShort ${castWhat}
						DEBUGCAST CastW calling MemSpell in CastWhat with MiscGem 2 for ${castWhat} \agLine#:${Macro.CurLine}"
						/if (${sentFromCW.Find[Heal]}) /call BroadCast r "I don't have my heal spell ${castWhat} ready! You should save it. Trying to mem...hold on!~"
						/call MemSpell "${castWhat}" ${MiscGem} 0 ${sentFromCW}
						DEBUGCAST CastW Return from MemSpell | ${Me.GemTimer[${castWhat}]} != 0...${Math.Calc[${Spell[${castWhat}].RecastTime.TotalSeconds} + .2]} \agLine#:${Macro.CurLine}"
						/delay 15 ${Me.GemTimer[${castWhat}]} != 0
						|/echo ${Me.GemTimer[${castWhat}]} != 0.....${Math.Calc[${Spell[${castWhat}].RecastTime} + 2]} \agLine#:${Macro.CurLine}
						/if (${Me.GemTimer[${castWhat}]}!=0) /varset MyGemTimer ${Math.Calc[${Spell[${castWhat}].RecastTime.TotalSeconds} + .2]}s
						|If the memming process gets interupted for whatever reason except mob agro, we're stuck in here for a hard 35s. Not anymore. 
						|/echo ${MyGemTimer} is mygemtimer
						/if (${MyGemTimer.OriginalValue} > 2 && ${Me.CombatState.Equal[COMBAT]}) {
							DEBUGCAST Returning from CastWhat cause the timer takes too long ${castWhat}"
							/return Longmem
						}
						:gemdelay2
						|/if (${Me.SpellReady[${castWhat}]} == FALSE || ${Me.GemTimer[${castWhat}]}!=0) {
							/if (${MyGemTimer}!=0) {
								/call GetHostilesOnXTarget
								/if (${Macro.Return} > 0 && !${BuffMode} && ${sentFromCW.Find[buff]}) {
									/varset CastResult CAST_SUCCESS
									/return ${CastResult}
								}
								/goto :gemdelay2
							}
						|}
						DEBUGCAST CastW Post Memspell for ${castWhat}  \agLine#:${Macro.CurLine}"
						|delayremove/delay 1
					}
                    :checkland
					|Lemons: Next two lines are to address the moving interupts if you were trying to move a character to a mob and cast a spell at the same time. They will now cast their spell if it meets the requirements then move. Need to move all /casts to one location instead of having them peppered throughout. 
					/if (${MoveTo.Moving} || ${Stick.Status.NotEqual[OFF]}) {
						/stick pause
						/delay 3 !${Navigation.Velocity}
					}
					/if (${AdvPath.Status} != 0) {
						/afollow pause
						/delay 3 !${Navigation.Velocity}
					}
					/if (!${Spell[${castWhat}].ID} && ${Me.Book[${castWhat}]}) {
						DEBUGCAST I don't have ${castWhat} memmed for some reason, gonna try again. (!${Spell[${castWhat}].ID} && ${Me.Book[${castWhat}].ID})"
						/goto :remem
					}
					/if (${sentFromCW.Find[buffs]} && !${Select[${sentFromCW},OOGBuffs,OOGBuffs-nomem]}) /echo casting buff ${castWhat} on ${Target.Class} ${Target} \agLine#:${Macro.CurLine}
					/if (!${Me.Standing}) {
						DEBUGN going to stand"
						/if (!${standTimer}) /stand
						/delay 1s ${Me.Standing}
						/if (!${Me.Standing}) {
							DEBUGN Returning cause I'm not standing"
							/return Sitting
						}
					}
					/if (${Select[${sentFromCW},OOGBuffs,OOGBuffs-nomem]}) {
						/varcalc castedOOGs ${castedOOGs}+1					
						/echo \agOOG [${Time}] Buff \at${castWhat} \axon ${Target.Class} \ay${Target} \ax(${Spawn[${castTargetID}]}). #of OOGBuffs casted is ${castedOOGs}
						DEBUGCAST OOG [${Time}] Buff ${castWhat} on ${Target.Class} ${Target} (${Spawn[${castTargetID}]}). #of OOGBuffs casted is ${castedOOGs}"
					}
					/call Cast "${castWhat}" "${sentFromCW}" "${castTargetID}"
					DEBUGCAST CastW Going to WaitCast"
					/call WaitCast "${sentFromCW}" ${Spell[${castWhat}].MyCastTime} "${Spell[${castWhat}]}"
					DEBUGCAST CastW Back From WaitCast ${Macro.Return}"
					:skipbuff
					/if (!${bDontCheckShit} && ${OhShitOn} && ${sentFromCW.NotEqual[OhShitStuff]} && !${sentFromCW.Equal[CharmStuff]}) {
						|DEBUGCAST Checking shit in CastWhat called from ${sentFromCW}"
						/call OhShitStuff CastLoop 1 1
					}
					/if (${MapTheZone}) /call ZoneMap FALSE med
					/doevents CastResist
					/doevents CastFailed
					/doevents CastInterrupted
                    /if ((${CastResult.Equal[CAST_FIZZLED]} || ${CastResult.Equal[CAST_RESIST]}) && !${DontRecast} && ${CastRetries} < ${NumFails}) {
						/varcalc NumFails ${NumFails}+1
						DEBUGCAST CastW Cast Fizzled or Resist"
						|Better not get locked in here if we are fighting...
						|Lemons: GetHostilesOnXTarget check is causing every spell to look like a success. Not needed in non-pull code. 
						/if (${Spell[${castWhat}].Mana} < ${Me.CurrentMana} && !${Me.Hovering} && ${Spell[${castWhat}].ID}) {
							/echo \ar spell ${CastResult} i need to try to cast it again \agLine#:${Macro.CurLine}
							/delay 2s ${Me.GemTimer[${castWhat}]}==0
							DEBUGCAST CastW Going to try and cast it again"
							/if (${Me.GemTimer[${castWhat}]}==0) /goto :checkland
						}
					}
				/varset NumFails 0
				/if (${Stick.Status.Equal[PAUSED]}) /stick unpause
                DEBUGCAST CastWhat \aycast Spell result: ${CastResult}"
				/if (${CastingInterruptOn}) {
					/if (${CastResult.Equal[CAST_CANCELLED]}) {
						/if (${Select[${sentFromCW},dps,gom,singleheal]} > 0) {
							/echo \ar Your Spell: ${castWhat} was aborted due to interrupt conditions in castwhat. \agLine#:${Macro.CurLine}
						}
					}
				}
                | READ THIS. For some reason Cast.Result is still equal to CAST_SUCCESS after /stopcast, maybe macro to fast for plugin to update.
                | So checking for CastResult NotEqual CAST_CANCELLED fixes the issue, and fixes the casting on corpse messages even though the spell was canceled. 
				|Lemons: Interrupted spell casts were being reset in two places. CastFailed event returns Fizzled only. Manual interrupts use Cancelled.
                /if (${CastResult.NotEqual[CAST_CANCELLED]} && ${CastResult.NotEqual[CAST_FIZZLED]} && ${CastResult.NotEqual[CAST_RESIST]} && ${CastResult.NotEqual[CAST_Interrupted]}) /varset CastResult CAST_SUCCESS
                /if (${sentFromCW.NotEqual[BuffBeg]}) /doevents
                |Remem spell originally in Miscgem slot except if combat or just rezd
                /if (${MiscGemRemem}) {
					DEBUGCAST CastW MiscGemRemem is active so I need to mem the spell again"
                    |We need to check if the spell just cast was swaped out and other spell needs to bo rememed.
                    |Need a way to carry a flag so remem will be done out of combat after the spell has been cast.
                    /if (${CastResult.Equal[CAST_SUCCESS]}) {
                        |Is it the MiscGem?
                        /if (${castWhat.Equal[${ReMemWaitShort}]}) {
                            /varset ReMemCast 1
                        |Is it the MiscGemLW
                        } else /if (${castWhat.Equal[${ReMemWaitLong}]}) {
                            /varset ReMemCastLW 1
                        }
                    }
                    /if (${MiscGemRemem}==1 || ${MiscGemRemem}==2) {
                        /if (!${Me.Gem[${ReMemMiscGem}]} && ${ReMemCast} && !${CombatStart} && !${Me.Buff[Resurrection Sickness].ID} && !${sentFromCW.Find[-nomem]}) {
                            /if (${Cursor.ID}) /call CheckCursor
                            |/memorize "${ReMemMiscGem}" gem${MiscGem}
							/if (${MuleDebug}) /echo calling MemSpell in CastWhat 3 for ${ReMemMiscGem}
                            /if (!${sentFromCW.Find[Heal]}) /call MemSpell "${ReMemMiscGem}" ${MiscGem} 0
                            /varset ReMemCast 0
                            /varset ReMemWaitShort null
                        }
                    }
                    |Remem spell originally in Long Wait Gem slot
                    /if ((${MiscGemRemem}==1 || ${MiscGemRemem}==3) && ${MiscGemLW} && ${ReMemWaitLong.NotEqual[null]} && !${sentFromCW.Find[-nomem]}) {
                        /if (${ReMemCastLW} && !${Me.Buff[Resurrection Sickness].ID}) {
                            /if (${Cursor.ID}) /call CheckCursor
                            /if (${MuleDebug}) /echo calling MemSpell in CastWhat 4 for ${ReMemMiscGemLW}
							/call MemSpell "${ReMemMiscGemLW}" ${MiscGemLW} ${Int[${Me.Gem[${ReMemMiscGemLW}]}]}
                            /varset ReMemCastLW 0
                            /varset ReMemWaitLong null
                        }
                    }
                }
            }
			:donecast
			DEBUGCAST CastW donecast"
            /if (${IAmABard} && ${Me.GemTimer[${castWhat}]}==0) {
				DEBUGCAST I'm a bard and my spell is ready ${Me.GemTimer[${castWhat}]}"
                |/delay 2
                /if (${Me.GemTimer[${castWhat}]}!=0) {
					/return Bardtimer
				}
				/echo \ay Twist \ag${castWhat} \ayonce Line#:${Macro.CurLine}
				|Lemons: Testing fixes for some weird bard behavior with mq2twist
                /squelch /twist once ${Me.Gem[${castWhat}]}
				|/cast "${castWhat}"
				/delay 5 ${Me.Casting.Name.Equal[${castWhat}]}
				|/if (!${Me.Casting.Name.Equal[${castWhat}]}) {
				|	DEBUGCAST I tried to sing ${castWhat} but it didn't work, gonna try again"
				|	/if (!${Me.GemTimer[${castWhat}]} && ${Target.ID} == ${castTargetID} && ${Target.Distance} < 200) /goto :donecast
				|}
                /delay ${Spell[${castWhat}].MyCastTime}ms
				/delay 1
                /varset CastResult CAST_SUCCESS
            }
        }
        /if (${WasTwisting} && !${Twist}) /squelch /twist
        DEBUGCAST CastWhat Leave \ay${CastResult}"
        /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
        |Kaen01::Resetting sittomedtimer after a cast.
        /if (${CastResult.Equal[CAST_SUCCESS]}) /varset SitToMedTimer ${SitToMedTimer.OriginalValue}        
    /return ${CastResult}
	
| -------------------------------------------------------------------------------------
| SUB: Cast Just cast the damn thing, and make sure you're casting it
| -------------------------------------------------------------------------------------	
Sub Cast(castWhat,sentFromC,int castTargetID)
	DEBUGCAST Cast: ${castWhat} ${sentFromC}"
	/declare castTimer timer local 10
	/if (${castWhat.Find[Rk.]} && ${Me.SpellRankCap} < 3) {
		/if (${castWhat.Find[Rk. II]} && ${Me.SpellRankCap} < 2) {
			/varset castWhat ${castWhat.Left[${Math.Calc[${castWhat.Find[Rk.]}-2]}]}
		} else /if (${castWhat.Find[Rk. III]} && ${Me.SpellRankCap} == 2) {
			/varset castWhat ${castWhat.Left[${Math.Calc[${castWhat.Find[Rk.]}-2]}]} Rk. II
		}
	}
	/if (${Target.ID}!=${castTargetID} && ${Spell[${castWhat}].TargetType.NotEqual[Self]} && ${Spawn[id ${castTargetID}].ID}) {
		/if (${MuleDebug}) /echo Targeting a mob 14b: ${Spawn[${castTargetID}]} \agLine#:${Macro.CurLine}
		|Lemons: Don't target yourself when you're casting a group spell. IE Paladin group heals
		/if (${castTargetID} == ${Me.ID}) {
			/if (${Spell[${castWhat}].HasSPA[0]} && ${Spell[${castWhat}].TargetType.Find[group]}) {
			} else {
				/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
				/target id ${castTargetID}
				/delay 10 ${Target.ID}==${castTargetID}
			}
		} else {
			/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
			/target id ${castTargetID}
			/delay 10 ${Target.ID}==${castTargetID}
			}
	}
	/delay 2s ${Me.SpellReady[${castWhat}]}
	/if (!${Me.SpellReady[${castWhat}]} && ${Me.CombatState.Equal[Combat]}) /return
	:cast
	DEBUGCAST Casting ${castWhat}
	/cast "${castWhat}"
	/if (${MapTheZone}) /call ZoneMap FALSE med
	/delay 2
	DEBUGCAST Sub Cast: ${Me.Casting.ID} != ${Spell[${castWhat}].ID} && !${Me.SpellReady[${castWhat}]})"
	|Lemons: We can still get stuck in this loop for the full gemready time if we don't capture our Me.Casting.ID for spells with very short casting time (< 2/10). Might need to change the last line to check for spells less than or equal to 1/10
	/if (${Me.Casting.ID} != ${Spell[${castWhat}].ID} && !${Me.SpellReady[${castWhat}]} && ${Me.Gem[${castWhat}]} && ${Target.Type.NotEqual[corpse]} && ${Spell[${castWhat}].MyCastTime}>250) /goto :cast
	|/echo Cast: "${castWhat}" \agLine#:${Macro.CurLine}
	/if (${Spell[${castWhat}].MyCastTime}!=0) /delay 5 ${Me.Casting.ID}

	DEBUGCAST Cast: Going to WaitCast "${sentFromC}" ${Spell[${castWhat}].MyCastTime}"
/return
| -------------------------------------------------------------------------------------
| SUB: WillItStick Lemons: Call this to see if the buff you send in is able to be cast on your target 
| -------------------------------------------------------------------------------------	
Sub WillItStick(castWhat,int castTargetID)
	/varset StickChecked 1
	/if (${Spell[${castWhat}].Level} <= 50) {
		DEBUGBUFF This beneficial spell ${castWhat} should land on everyone"
	} 
	/if (${Spell[${castWhat}].Level} == 51) {
		/if (${Spawn[${castTargetID}].Level} < 40) {
			DEBUGBUFF Target needs to be at least lvl 40 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} >= 52 && ${Spell[${castWhat}].Level} <= 53) {
		/if (${Spawn[${castTargetID}].Level} < 41) {
			DEBUGBUFF Target needs to be at least lvl 41 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} >= 54 && ${Spell[${castWhat}].Level} <= 55) {
		/if (${Spawn[${castTargetID}].Level} < 42) {
			DEBUGBUFF Target needs to be at least lvl 42 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} >= 56 && ${Spell[${castWhat}].Level} <= 57) {
		/if (${Spawn[${castTargetID}].Level} < 43) {
			DEBUGBUFF Target needs to be at least lvl 43 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} >= 58 && ${Spell[${castWhat}].Level} <= 59) {
		/if (${Spawn[${castTargetID}].Level} < 44) {
			DEBUGBUFF Target needs to be at least lvl 44 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} >= 60 && ${Spell[${castWhat}].Level} <= 61) {
		/if (${Spawn[${castTargetID}].Level} < 45) {
			DEBUGBUFF Target needs to be at least lvl 45 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} >= 62 && ${Spell[${castWhat}].Level} <= 63) {
		/if (${Spawn[${castTargetID}].Level} < 46) {
			DEBUGBUFF Target needs to be at least lvl 46 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} >= 64 && ${Spell[${castWhat}].Level} <= 65) {
		/if (${Spawn[${castTargetID}].Level} < 47) {
			DEBUGBUFF Target needs to be at least lvl 47 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} > 65 && ${Spell[${castWhat}].Level} <= 95) {
		/if (${Spawn[${castTargetID}].Level} < 61) {
			DEBUGBUFF Target needs to be at least lvl 61 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} > 95 && ${Spell[${castWhat}].Level} <= 100) {
		/if (${Spawn[${castTargetID}].Level} < 66) {
			DEBUGBUFF Target needs to be at least lvl 66 for ${castWhat}"
			/return BadStick
		}
	|I need to check if its 66, 71, or 65, 70. Need a lvl 66 toon. 
	} 
	/if (${Spell[${castWhat}].Level} > 100 && ${Spell[${castWhat}].Level} <= 105) {
		/if (${Spawn[${castTargetID}].Level} < 71) {
			DEBUGBUFF Target needs to be at least lvl 71 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} > 105 && ${Spell[${castWhat}].Level} <= 110) {
		/if (${Spawn[${castTargetID}].Level} < 76) {
			DEBUGBUFF Target needs to be at least lvl 76 for ${castWhat}"
			/return BadStick
		}
	} 
	/if (${Spell[${castWhat}].Level} > 110 && ${Spell[${castWhat}].Level} <= 115) {
		/if (${Spawn[${castTargetID}].Level} < 81) {
			DEBUGBUFF Target needs to be at least lvl 81 for ${castWhat}"
			/return BadStick
		}
	}
/return GoodStick
| -------------------------------------------------------------------------------------
| SUB: KACheckHP
| -------------------------------------------------------------------------------------
    Sub KACheckHP(kaSpell)
       /if (!${Int[${Me.Casting.ID}]}) /return
       /if (${Target.Type.Equal[npc]} && ${Me.Casting.ID} && ${Spell[${kaSpell}].SpellType.NotEqual[Detrimental]}) {
			/echo Interrupting cause you can't heal NPCs
           /stopcast
		   |delayremove
		   /delay 1
		   /doevents flush CastFailed
           /varset CastResult CAST_SUCCESS
		   /doevents flush CastFailed
           DEBUGN CheckHP1: ${Target.Type}"
       }
       /if (${Me.CastTimeLeft} < 800 && (${Target.PctHPs}>${SHealPct} || ${Target.PctHPs} >= ${InterruptHeals} && ${Me.Casting.ID})) {
			/echo Interrupting cause target is at or above ${InterruptHeals} 2
           /stopcast
		   |delayremove
		   /delay 1
		   /doevents flush CastFailed
           /varset CastResult CAST_SUCCESS
		   /doevents flush CastFailed
           DEBUGN CheckHP2: ${Target.PctHPs} ${SHealPct}"
		   DEBUGHEALS KACheckHP Interrupting because the target's HP is past the InterruptHeals point ${Target.PctHPs}>${SHealPct} || ${Target.PctHPs}>= ${InterruptHeals}"
       }
    /return
| -------------------------------------------------------------------------------------
| SUB: KACheckDPS
| -------------------------------------------------------------------------------------
    Sub KACheckDPS
	/if (!${Int[${Me.Casting.ID}]}) /return
	/if (${Target.Type.Equal[pc]}) /return
	/if (${Target.PctHPs} < 1 || ${Target.Type.Equal[corpse]} || !${Target.ID} || ${Me.XTarget}==0 || !${Me.XTarget[${Target.CleanName}].ID} && ${Me.Casting.ID}) {
		/echo Interrupting cause target is dead (${Target.PctHPs} < 1 || ${Target.Type.Equal[corpse]} || !${Target.ID} || ${Me.XTarget}==0 || !${Me.XTarget[${Target.CleanName}].ID} && ${Me.Casting.ID})
		/stopcast
		|delayremove
		/delay 1
		/doevents flush CastFailed
		/varset CastResult CAST_SUCCESS
		/doevents flush CastFailed
		DEBUGN CheckDPS1: ${Target.PctHPs} ${Target.Type} ${Int[${Target.ID}]}"
	}
	/if (${HealsOn}) {
		/if (${Spawn[=${MainAssist}].PctHPs}<50 && ${Spawn[=${MainAssist} ${MainAssistType}].ID} && ${Spawn[=${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} && ${Me.Casting.ID}) {
			/echo Interrupting cause target is at or above ${InterruptHeals} 3
			/stopcast
			|delayremove
			/delay 1
			/doevents flush CastFailed
			/varset CastResult CAST_SUCCESS
			/doevents flush CastFailed
			DEBUGN CheckDPS2: ${HealsOn}  ${Spawn[=${MainAssist}].PctHPs} ${Spawn[=${MainAssist} ${MainAssistType}].ID}  ${Spawn[=${MainAssist} ${MainAssistType}].Type}"
		}
	}
    /return       
| -------------------------------------------------------------------------------------
| SUB: KACheckBUFFS
| -------------------------------------------------------------------------------------
	Sub KACheckBUFFS
		/if (!${Int[${Me.Casting.ID}]}) /return
		/if (${Me.Casting.Range}==0 && ${Me.Casting.AERange}==0) /return
		/if ((${Int[${Target.ID}]} && ${Int[${Target.PctHPs}]}<1) || ${Target.Type.Equal[corpse]} || (!${Int[${Target.ID}]} && ${Select[${Me.Casting.TargetType},self,pet,pet1,pet2]}==0 && ${Me.Casting.ID})) {
			/echo Interrupting cause (${Int[${Target.ID}]} && ${Int[${Target.PctHPs}]}<1) || ${Target.Type.Equal[corpse]} || (!${Int[${Target.ID}]} && ${Select[${Me.Casting.TargetType},self,pet,pet1,pet2]}==0))\agLine#:${Macro.CurLine}
			/stopcast
			|delayremove
			/delay 1
			/doevents flush CastFailed
			/varset CastResult CAST_SUCCESS
			/doevents flush CastFailed
			DEBUGCAST CheckBUFFS2: ${Int[${Target.PctHPs}]} ${Target.Type}  ${Int[${Target.ID}]} ${Me.Casting} ${Me.Casting.TargetType}"
		}
		/if ((${Me.Casting.MyRange}>0 && ${Target.Distance}>${Me.Casting.MyRange}) || (${Me.Casting.AERange}>0 && ${Target.Distance}>${Me.Casting.AERange} && ${Me.Casting.ID})) {
			/echo Interrupting cause ${Me.Casting.MyRange}>0 && ${Target.Distance}>${Me.Casting.MyRange}) || (${Me.Casting.AERange}>0 && ${Target.Distance}>${Me.Casting.AERange}\agLine#:${Macro.CurLine}
			/stopcast
			|delayremove
			/delay 1
			/doevents flush CastFailed
			/varset CastResult CAST_SUCCESS
			/doevents flush CastFailed
			DEBUGCAST CheckBUFFS3: ${Int[${Me.Casting.ID}]}  ${Target.Distance} ${Me.Casting.MyRange} ${Me.Casting.AERange} ${Me.Casting}"
		}
	/return       
| -------------------------------------------------------------------------------------
| SUB: CheckCasting
| -------------------------------------------------------------------------------------
    Sub CheckCasting(int CCTime)
    /if (${IAmABard}) /return
    /declare n int local 0
    /declare CCTimer timer local ${CCTime}
    /if (!${CCTimer}) {
		/varset CCTimer 30s
	}
	:NotReady
    /if (${CCTimer}==0) /return
    /delay 1
    /if (${Me.Casting.ID}) {
		/goto :NotReady
	}
    /if (${Bool[${Plugin[MQ2Cast]}]}) {
		/if (${Cast.Status.Equal[C]}) {
			/goto :NotReady
		}
	}
	/for n 1 to 13
		/if (${Me.Gem[${n}].ID}) {
			/if (${Me.GemTimer[${n}]}==0) {
				/if (!${Me.SpellReady[${n}]}) {
					|/echo [${Time}] ok we found a gem that we can wait for
					/delay 5s ${Me.SpellReady[${n}]}
					|/echo [${Time}] finished waiting lets return
				}
			}
		}
	/next n
    /return    
| -------------------------------------------------------------------------------------
| SUB: Do We Move
| -------------------------------------------------------------------------------------
    Sub DoWeMove(string sentFromDM, int p2_flag)
		DEBUGMOVE Entered DoWeMove"
		/if (${BandolierOn}) {
			/call DoBandolier
			}
		/if (!${ReturnToCamp} && !${ChaseAssist}) {
			/if (${MuleDebug}) /echo returning from DoWeMove ${sentFromDM} because ReturnToCamp and ChaseAssist was 0
			DEBUGMOVE DoWeMove: Leave"
			/return
		}
		/if (${Role.Equal[manual]}) /return
		/if (${Navigation.Active} && ${Me.Moving} && ${Navigation.Velocity}) {
			DEBUGMOVE DoWeMove: Leave"
			/return
		}
		/if (${Me.Hovering}) /return
		|/declare MoveTimeout timer local 0
        /declare StuckCount int local 0 
        /declare X1 int local
        /declare Y1 int local
        /declare scatterDistance int local
        /declare CampYRandom int local
        /declare CampXRandom int local
        | Stop sticking if mobs are on xtarget
		|Lemons: Now, if I'm following, I'll actually keep following until it's time to kill stuff. 
        |/if (${SpawnCount[npc xtarhater]} && !${Role.Find[pull]} && ${p2_flag}!=3 && ${MainAssist.NotEqual[${Me}]}) {
	    |/echo 1. Returning from DoWeMove ${sentFromDM} ${SpawnCount[npc xtarhater]} ${Role.Find[pull]} ${MainAssist.NotEqual[${Me}]}
        |   /if (${Stick.Active}) {
		|		DEBUGMOVE Not gonna be an idiot and move during fight cause I dont have to.
        |        /stick off
        |       /moveto off
		|		/if (${Bool[${Plugin[mq2advpath]}]}==TRUE) {
		|			/play off
 		|		}
		|		/if (${Bool[${Plugin[mq2navigation]}]}==TRUE || ${Bool[${Plugin[mq2nav]}]}==TRUE) {
		|			/if (${Navigation.Active}) {
		|				/if (${MuleDebug}) /echo 1 stopping nav 
		|				/echo Stopping nav \agLine#:${Macro.CurLine}
		|				/nav stop
		|			}
		|		}
		|	}
		|	/return
		|}
        /doevents
        /if (${sentFromDM.NotEqual[EndMacroIf]}) /call EndMacroIf
        /declare ZDist float local 0
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 30s
        /if (${Target.ID} && ${Target.Type.Equal[npc]}) {
            /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        }
        /declare circleDirection string local
		/if (${ReturnToCamp} && ${ChaseAssist}) {
			/echo Can't both follow and stay in camp. Setting ReturnToCamp to 0 and keeping ChaseAssist 1
			/varset ReturnToCamp 0
			}
        DEBUGN DoWeMove: Enter"
        | - Shuts off ReturnToCamp if a toon moves a big distance defined by CampRadiusExceed ie CoH !${Pulled} || ${Pulling}
		|Lemons: Resetting Exceed distance to be equal to MaxRadius while pulling if it's smaller.
		/if (${MaxRadius} > ${CampRadiusExceed}) /varset CampRadiusExceed ${MaxRadius}+1
        /if (${ReturnToCamp}) {
            DEBUGMOVE DoWeMove:(ReturnToCamp) My distance from camp is: (${Math.Distance[${CampYLoc},${CampXLoc}]})."
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadiusExceed} && !${Role.Find[hunter]} && !${Role.Find[puller]}) {
                DEBUGMOVE DoWeMove:(ReturnToCamp) CampRadiusExceed turning off ReturnToCamp."
                /varset ReturnToCamp 0
                /echo Leashing exceeded distance of ${CampRadiusExceed} turning off ReturnToCamp
                /return
            }
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 11) {
				|Lemons: Don't return to a singular point when we have multiple mobs in camp. Just chill till we are killing something.
				/if (${Me.XTarget} && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
					DEBUGMOVE DoWeMove: Leave"
					/return
				}
                DEBUGMOVE DoWeMove:(ReturnToCamp) Distance to camp > 10 and no adds in camp. ${Math.Distance[${CampYLoc},${CampXLoc}]} ${CampRadius} ${Medding}"
                | Prevent puller roles from returning to camphere spot and just pull from where they are if in camp radius.
                /if ((${p2_flag}==3 || ${Select[${Role},puller,pullertank,pullerpettank]}) && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius} && !${Medding}) {
					DEBUGMOVE 2 returning from DoWeMove ${sentFromDM} because ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}"
					/return
				}
                /if ((${p2_flag}==3 || ${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) {
                    |---------------------------------------------- MQ2Nav ---------------------------------------------------------------------|
                    /if (${mq2navloaded} && ${Navigation.PathExists[locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}]} && ${ReturnToCamp}) {
						/if (${Navigation.MeshLoaded} && ${UseNav}  && ${PullMoveUse.Equal[nav]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
							DEBUGMOVE DoWeMove:(ReturnToCamp) Distance to camp > 10, MQ2Navigation return to camp."
							/if (${Navigation.Active}) {
								/echo stopping nav right before :NotInCamp
								/nav stop
							}
						:NotInCamp
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering} || ${Me.Rooted.ID}) {
                                /if (${Navigation.Active}) {
									/echo Stopping nav \agLine#:${Macro.CurLine}
									/nav stop
								}
								DEBUGMOVE I'm Dead or Rooted and cant move"
                                /return
                            }
							/if (!${Navigation.Active}) {
								
								DEBUGMOVE going back to camp... \agLine#:${Macro.CurLine}"
								/nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
								/delay 1s ${Navigation.Active}==TRUE
								|/delay 5s ${Navigation.Active}==FALSE
							}
						:NavActive
							/if (${OhShitOn}) {
								/call OhShitStuff "Move"
							}
							/if (${Me.Mount.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]} < 75 || (${Me.Mount.ID} && ((${DismountDuringFights} && ${Me.CombatState.Equal[COMBAT]}) || !${TravelOnHorse}) && ${Math.Distance[${CampYLoc},${CampXLoc}]} < 100)) {
								/echo MQ2Nav does not work well with mounts. Dismounting.
								/dismount
							}
							/if (${Me.Sitting}) {
								DEBUGN going to stand"
								/if (!${standTimer}) /stand
								/delay 5 ${Me.Standing}
								/if (!${Me.Standing}) {
									DEBUGN I'm not standing, still gonna try to move"
								}
							}
							/if (${Navigation.Active}) {
                                /varset X1 ${Int[${Me.X}]}
                                /varset Y1 ${Int[${Me.Y}]}   
                                | PullerPetTank - send in pet to attack on my way back to camp if not too far from camp.
                                /if (${Select[${Role},pullerpettank]} && ${Pulled}) {
                                    /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                        /call CombatPet
                                    } else {
                                        /pet back off
                                    }
                                }     
								/delay 10 ${Navigation.Active}==FALSE
								/if (${Navigation.Active}) {
									| Check for getting stuck on geometry
									/if (${Int[${Me.X}]}==${X1} && ${Int[${Me.Y}]}==${Y1}) {
										/varcalc StuckCount (${StuckCount})+1
										/if (${StuckCount}>=3) {
											/if (${Navigation.Active}) {
												/echo Stopping nav \agLine#:${Macro.CurLine}
												/nav stop
											}
											/call Stuck
											/varset StuckCount 0
										}
									}
								}
							}                                
							DEBUGMOVE DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} >= ${CampRadius} Timer: ${DWMTimer}"
							/if (${Navigation.Active} && ${DWMTimer} >= 1) {
								/delay 10 ${Navigation.Active}==FALSE
								/goto :NavActive
							}
							/if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) {
								/delay 10 ${Navigation.Active}==FALSE
								/goto :NotInCamp
							}
						}
                    |---------------------------------------------- MQ2AdvPath ---------------------------------------------------------------------|
                    } else /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]} && ${mq2advpathloaded}) {
                        /play ${PullPath} reverse nodoor smart
                        DEBUGMOVE DoWeMove: /play ${PullPath} reverse nodoor smart"
					:RunningThePathBack
                        /doevents
                        /if (${IAmDead} || ${Me.Hovering}) {
							/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
                            /play off
							DEBUGMOVE DoWeMove: Leave"
                            /return
                        }
                        |delayremove/delay 5 
                        /varset DWMWPCurrent ${AdvPath.NextWaypoint}
                        DEBUGMOVE DoWeMove: ReturnToCamp WP#: ${DWMWPCurrent}"
						/if (${DWMWPCurrent}>=2 && ${DWMTimer}>=1) {
							/goto :RunningThePathBack
						}
                    } 
                } 
                DEBUGMOVE DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15, MQ2MoveUtils return to camp."
                /doevents
				/if (${Scatter} && ${Zone.Outdoor}) {
                    | Randomize camp x,y by +- so toons don't always retun to exact same spot and help to look less botted.
                    /varset scatterDistance ${Math.Rand[${Scatter}]}
                    /if (${Math.Rand[2]}) {
                        /varcalc CampYRandom ${CampYLoc}-${scatterDistance}
                    } else {
                        /varcalc CampYRandom ${CampYLoc}+${scatterDistance}
                    }  
                    /if (${Math.Rand[2]}) {
                        /varcalc CampXRandom ${CampXLoc}-${scatterDistance}
                    } else {
                        /varcalc CampXRandom ${CampXLoc}+${scatterDistance}
                    }
                } else {
                   /varset CampYRandom ${CampYLoc}
                   /varset CampXRandom ${CampXLoc}
				   DEBUGMOVE CampYRandom is now ${CampYRandom} from ${CampYLoc}"
				   DEBUGMOVE CampXRandom is now ${CampXRandom} from ${CampXLoc}"
                }                
                DEBUGMOVE DoWeMove: Camp Location Info: Scatter: ${Scatter} YRandom: ${CampYRandom} XRandom: ${CampXRandom}"
				|/varset MoveTimeout 60s
				/if (!${Me.Sitting}) {
					/if (${Stick.Status.Equal[ON]}) /stick off
				}
			:StillMoving
				/if (${IAmDead} || ${Me.Hovering}) {
					/if (${MuleDebug}) /echo moveto 4
					/if (${MoveTo.Moving}) /moveto off
					|/echo 2. returning from DoWeMove ${sentFromDM} because I'm dead
					DEBUGMOVE DoWeMove: Leave"
					/return
				}
				/if ((!${Me.Moving} || !${MoveTo.Moving}) && (!${Stick.Status.Equal[ON]})) {
					/if (${Math.Distance[${CampYRandom},${CampXRandom}]} > ${ReturnToCampAccuracy}) {
						/if (${DismountDuringFights}==1) {
							/if (${Me.Mount.ID} && !${TravelOnHorse}) {
								/echo getting off the horse because DismountDuringFights=1
								/dismount
							}
						}
						/if (${Me.Rooted.ID}) {
							DEBUGMOVE DoWeMove: Leave rooted"
							/return
						} 
						/if (${mq2navloaded}) {
							/if (${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.Active}==FALSE && ${Navigation.PathExists[locyxz ${CampYRandom} ${CampXRandom} ${CampZLoc}]} && !${Role.Find[Hunter]}) {
								/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
								/echo trying to get within ${ReturnToCampAccuracy} feet of the camp (${Math.Distance[${CampYRandom},${CampXRandom}]} ft) \agLine#:${Macro.CurLine}
								/nav locyxz ${CampYRandom} ${CampXRandom} ${CampZLoc}
							}
						} else {
							/moveto mdist ${ReturnToCampAccuracy}
							DEBUGMOVE Moveto "
							/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
							/moveto loc ${CampYRandom} ${CampXRandom}
							/delay 1s ${MoveTo.Moving}
							/delay 1s ${MoveTo.Stopped}
							/if (${MuleDebug}) /echo  MoveTo \agLine#:${Macro.CurLine}
						}
						/if (${OhShitOn}) {
							/call OhShitStuff "Move"
						}
					}
				}
				/if (${Select[${Role},pullerpettank]} && ${Pulled}) {
					/if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
						/call CombatPet
					} else {
						/pet back off
					}
				}     
                |delayremove/delay 1
				/if (${OhShitOn}) {
					/call OhShitStuff "Move"
				}
				/if (${DWMTimer}==0 && ${ReturnToCamp}) {
					/if (${mq2navloaded}) {
						/if (${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.Active}) {
							/beep
							/echo [${Time}] I might be stuck
							/call BCTExec ${ChaseName} "/popup its possible ${Me} Stuck"
							/delay 1s
							/call Bind_ShakeLoose
							DEBUGMOVE DoWeMove: Leave"
							/return
						}
					}
				}
				/if (${mq2navloaded} && ${DWMTimer}>=1) {
					/if (${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.Active}) {
						/goto :StillMoving
					}
				} 
				/if ((${MoveTo.Moving} || ${Me.Moving}) && ${DWMTimer}>=1) {
					/goto :StillMoving
				}
                /if (${MoveTo.Moving} && ${Math.Distance[${CampYRandom},${CampXRandom}]} > ${ReturnToCampAccuracy}) {
					/goto :StillMoving
				}
                /delay 5 !${Me.Moving}
                | Move down if Z distance more than 3 due to levitation
                /if (${Target.ID} && ${Select[${Target.Type},npc,corpse]}) {
					/call ZAxisCheck ${ZDist} 3.1
				}
                /if (${Select[${Role},hunter,hunterpettank]}) {
					/varset ReturnToCamp 0
				}
            }
        }
        /if (${ChaseAssist} && (((!${CombatStart}) || (${CombatStart} && !${AutoFireOn} && !${StayAwayToCast})) || ${CombatStart} && ${Spawn[=${ChaseName}].Distance} > 100)) {
            DEBUGN ChaseAssist"
            DEBUGMOVE DoWeMove:(ChaseAssist) My distance from (${ChaseName}) is: (${Spawn[=${ChaseName}].Distance})."
			DEBUGMOVE DoWeMove: (${JustZoned}==0 && (${Spawn[=${ChaseName}].Distance} > ${CampRadiusExceed}) || (${Math.Calc[${Spawn[=${ChaseName}].Z}-${Me.Z}]}>100 && ${Math.Calc[${Spawn[=${ChaseName}].Z}-${Me.Z}]}<100))"
            /if (${JustZoned}==0 && (${Spawn[=${ChaseName}].Distance} > ${CampRadiusExceed}) || (${Math.Calc[${Spawn[=${ChaseName}].Z}-${Me.Z}]}>100 && ${Math.Calc[${Spawn[=${ChaseName}].Z}-${Me.Z}]}<100)) {
				DEBUGMOVE DoWeMove Exceeded distance from ${ChaseName} for break distance"
				/if (!${Navigation.MeshLoaded} && ${UseNav} ) {
					DEBUGMOVE ChaseAssist exceed camp check with no mesh"
					/varset ChaseAssist 0
					/echo ChaseAssist distance exceeded: Turning off ChaseAssist
					/call BroadCast r "Hey! I got left behind please run me to MA"
				} else {
					|Lemons: Nav is just ass when it comes to water. Let's see what we can change to make it use stick uw. 15.1.1w
					DEBUGMOVE ChaseAssist Exceed but Nav Mesh loaded"
					/if (!${Navigation.Active} && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]}) {
						/if (!${Me.FeetWet}) {
							DEBUGMOVE Not in water, so gonna nav to MA"
							|well, we have a mesh, lets just run to main assist, there is no reason not to...
							|/call BroadCast r "Hey! I got left behind, using /nav id to get to MA!"
							/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
							/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
							DEBUGMOVE Naving to ${ChaseName}"
							/nav id ${Spawn[=${ChaseName}].ID}
							/varset LastMove ${Macro.CurLine}
							/delay 1s ${Navigation.Active}==TRUE
							/delay 5s ${Navigation.Active}==FALSE
							/goto :donefollowing
						} else {
							/if (${Navigation.Active}) {
								/echo Stopping nav \agLine#:${Macro.CurLine}
								/nav stop
							}
							DEBUGMOVE I'm in water so I'm gonna use Stick \ag${Macro.CurLine}"
							/if (${Me.Sitting}) {
								DEBUGN going to stand"
								/if (!${standTimer}) /stand
								/delay 5 ${Me.Standing}
								/if (!${Me.Standing}) {
									DEBUGN I'm not standing, still gonna try to move"
								}
							}
							/if (${Stick.StickTarget} != ${Spawn[=${ChaseName}].ID} || ${Stick.Status.Equal[OFF]}) {
								/stick uw id ${Spawn[=${ChaseName}].ID}
								DEBUGMOVE Stick"
							}
							/goto :donefollowing
						}
					}
				}
			}
			DEBUGMOVE DoWeMove: MA too far? (${Spawn[=${ChaseName}].Distance} > ${ChaseDistance} && ${Spawn[=${ChaseName}].Distance} < ${CampRadiusExceed})"
            /if (${Spawn[=${ChaseName}].Distance} > ${ChaseDistance} && ${Spawn[=${ChaseName}].Distance} < ${CampRadiusExceed}) {
                DEBUGMOVE ChaseAssist MA distance check. ${Spawn[=${ChaseName}].Distance} > ${ChaseDistance} && ${Spawn[=${ChaseName}].Distance} < ${CampRadiusExceed}"
				
                /if (${Spawn[=${ChaseName}].Type.Equal[Pet]}) {
					/if (${MuleDebug}) /echo Targeting a mob 15k
                    /target id ${Spawn[=${ChaseName}].Master.ID}
                    /delay 10 ${Target.ID}==${Spawn[=${ChaseName}].Master.ID}
					|Lemons: Adding logic to use advpath instead of moveutils to follow main assist. 
					/if (!${Navigation.Active} && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]}) {
						DEBUGMOVE Nav path exists and MA too far away"
						/if (!${Me.FeetWet}) {
							|well, we have a mesh, lets just run to main assist, there is no reason not to...
							|/call BroadCast r "Hey! I got left behind, using /nav id to get to MA!"
							/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
							/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
							DEBUGMOVE Naving to ${ChaseName}"
							/nav id ${Spawn[=${ChaseName}].ID}
							/varset LastMove ${Macro.CurLine}
							/delay 1s ${Navigation.Active}==TRUE
							/delay 5s ${Navigation.Active}==FALSE
							/goto :donefollowing
						} else {
							/if (${Navigation.Active}) {
								/echo Stopping nav \agLine#:${Macro.CurLine}
								/nav stop
							}
							DEBUGMOVE I'm in water so I'm gonna use Stick \ag${Macro.CurLine}"
							/if (${Me.Sitting}) {
								DEBUGN going to stand"
								/if (!${standTimer}) /stand
								/delay 5 ${Me.Standing}
								/if (!${Me.Standing}) {
									DEBUGN I'm not standing, still gonna try to move"
								}
							}
							/if (${Stick.StickTarget} != ${Spawn[=${ChaseName}].ID} || ${Stick.Status.Equal[OFF]}) {
								/stick uw id ${Spawn[=${ChaseName}].ID}
								DEBUGMOVE Stick"
							}
							/goto :donefollowing
						}
					} 
					/if (${AdvPath.Active} && ${Spawn[${AdvPath.Monitor}].ID} != ${Spawn[=${ChaseName}].Master.ID} && !${Me.Combat} && ${UseAdvPath}) {
						/afollow spawn ${Spawn[=${ChaseName}].Master.ID}
						/varset LastMove ${Macro.CurLine}
						/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
						/if (${MuleDebug}) /echo Following the master of the MA Pet\agLine#:${Macro.CurLine}
						/goto :donefollowing
					} else /if (${Spawn[=${ChaseName}].Master.ID} != ${Me.ID} && !${AdvPath.State}) {
						/if (${Me.FeetWet}) {
							/if (${Navigation.Active}) {
								/echo Stopping nav \agLine#:${Macro.CurLine}
								/nav stop
							}
							DEBUGMOVE Stick"
							/stick ${ChaseDistance} uw id ${Target.ID} loose
						} else {
							DEBUGMOVE Stick"
							/stick ${ChaseDistance} id ${Target.ID} loose
						}
					}
                } else /if (${Spawn[=${ChaseName}].Type.Equal[mercenary]} && ${Spawn[=${ChaseName}].Owner.ID} != ${Me.ID} && !${Me.Combat}) {
					/if (${MuleDebug}) /echo Targeting id ${Spawn[=${ChaseName}].Owner.ID}, owner of Merc MA.\agLine#:${Macro.CurLine}
					/if (!${Navigation.Active} && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]}) {
						|well, we have a mesh, lets just run to main assist, there is no reason not to...
						|/call BroadCast r "Hey! I got left behind, using /nav id to get to MA!"
						/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
						/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
						DEBUGMOVE Naving to ${ChaseName}"
						/nav id ${Spawn[=${ChaseName}].ID}
						/varset LastMove ${Macro.CurLine}
						/delay 1s ${Navigation.Active}==TRUE
						/delay 5s ${Navigation.Active}==FALSE
						/goto :donefollowing
					} 
					/if (${AdvPath.Active} && ${Spawn[${AdvPath.Monitor}].ID} != ${Spawn[=${ChaseName}].Owner.ID} && ${UseAdvPath}) {
						/afollow spawn ${Spawn[=${ChaseName}].Owner.ID}
						/varset LastMove ${Macro.CurLine}
						/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
						/if (${MuleDebug}) /echo Following the owner of the MA Merc\agLine#:${Macro.CurLine}
						/goto :donefollowing
					} else /if (${Spawn[=${ChaseName}].Owner.ID} != ${Me.ID} && !${AdvPath.State}) {					
                    /if (${Me.FeetWet}) {
						/if (${Navigation.Active}) {
							/echo Stopping nav \agLine#:${Macro.CurLine}
							/nav stop
						}
						/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
						/target id ${Spawn[=${ChaseName}].Owner.ID}
						/delay 1s ${Target.ID}==${Spawn[=${ChaseName}].Owner.ID}
						DEBUGMOVE Stick"
                        /stick ${ChaseDistance} uw id ${Target.ID} loose
						/goto :donefollowing
                    } else {
						/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
						/target id ${Spawn[=${ChaseName}].Owner.ID}
						/delay 1s ${Target.ID}==${Spawn[=${ChaseName}].Owner.ID}
						DEBUGMOVE Stick"
                        /stick ${ChaseDistance} id ${Target.ID} loose
						}
                    }
                } else /if (${Spawn[=${ChaseName}].Owner.ID} != ${Me.ID} && !${AdvPath.Length} && !${Me.Combat}) {
					DEBUGMOVE Regular Move"
					/if (${UseNav} && ${Spawn[=${ChaseName}].ID} != ${Me.ID} && (!${Navigation.Active} || !${Navigation.Velocity}) && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]}) {
						/if (!${Me.FeetWet}) {
							DEBUGMOVE Naving to spawn generic \agLine#:${Macro.CurLine}"
							|well, we have a mesh, lets just run to main assist, there is no reason not to...
							/if (${MuleDebug} || ${DebugMove}) /echo  nav \agLine#:${Macro.CurLine}
							/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
							DEBUGMOVE Naving to ${ChaseName}"
							/nav id ${Spawn[=${ChaseName}].ID}
							/varset LastMove ${Macro.CurLine}
							/delay 1s ${Navigation.Active}==TRUE
							/delay 5s ${Navigation.Active}==FALSE
							/goto :donefollowing
						} else {
							/if (${Navigation.Active}) {
								/echo Stopping nav \agLine#:${Macro.CurLine}
								/nav stop
							}
							DEBUGMOVE I'm in water so I'm gonna use Stick \agLine#:${Macro.CurLine}"
							/if (${Me.Sitting}) {
								DEBUGN going to stand"
								/if (!${standTimer}) /stand
								/delay 5 ${Me.Standing}
								/if (!${Me.Standing}) {
									DEBUGN I'm not standing, still gonna try to move"
								}
							}
							/if (${Stick.StickTarget} != ${Spawn[=${ChaseName}].ID} || ${Stick.Status.Equal[OFF]}) {
								/stick uw id ${Spawn[=${ChaseName}].ID}
								DEBUGMOVE Stick"
							}
							/goto :donefollowing
						}
					} else /if (${AdvPath.Active} && ${Spawn[${AdvPath.Monitor}].ID} != ${Spawn[=${ChaseName}].ID} && ${Spawn[=${ChaseName}].ID} != ${Me.ID} && ${UseAdvPath} && !${Navigation.Active} && !${Stick.Active}) {
						DEBUGMOVE Generic Move Check AdvPath \ag${Macro.CurLine}"
						/if (${MuleDebug}) /echo Following ${Spawn[=${ChaseName}].ID}\agLine#:${Macro.CurLine}
						DEBUGMOVE DoWeMove: Does a nav path exist to the MA? ${Navigation.Active} && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]}"
						/if (!${Navigation.Active} && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]} && ${UseNav}) {
							/if (!${Me.FeetWet}) {
								DEBUGMOVE Generic Nav move in DoWeMove with no wet feet \agLine#:${Macro.CurLine}"
								|well, we have a mesh, lets just run to main assist, there is no reason not to...
								|/call BroadCast r "Hey! I got left behind, using /nav id to get to MA!"
								/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
								/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
								DEBUGMOVE Naving to ${ChaseName}"
								/nav id ${Spawn[=${ChaseName}].ID}
								/varset LastMove ${Macro.CurLine}
								/delay 1s ${Navigation.Active}==TRUE
								/delay 5s ${Navigation.Active}==FALSE
								/goto :donefollowing
							} else {
								/if (${Navigation.Active}) {
									/echo Stopping nav \agLine#:${Macro.CurLine}
									/nav stop
								}
								DEBUGMOVE I'm in water so I'm gonna use Stick \agLine#:${Macro.CurLine}"
								/if (${Me.Sitting}) {
									DEBUGN going to stand"
									/if (!${standTimer}) /stand
									/delay 5 ${Me.Standing}
									/if (!${Me.Standing}) {
									DEBUGN I'm not standing, still gonna try to move"
								}
								}
								/if (${Stick.StickTarget} != ${Spawn[=${ChaseName}].ID} || ${Stick.Status.Equal[OFF]}) {
									/stick uw id ${Spawn[=${ChaseName}].ID}
									DEBUGMOVE Stick"
								}
								/goto :donefollowing
							}
						}
						DEBUGMOVE Using AdvPath to follow \agLine#:${Macro.CurLine}"
						/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
						/echo afollow to ${ChaseName} ${Spawn[=${ChaseName}].ID} | ${AdvPath.State} && ${Spawn[${AdvPath.Monitor}].ID} != ${Spawn[=${ChaseName}].ID} && ${Spawn[=${ChaseName}].ID} != ${Me.ID} && ${UseAdvPath} ${Macro.CurLine}
						/afollow spawn ${Spawn[=${ChaseName}].ID}
						/varset LastMove ${AdvPath.State} && ${Spawn[${AdvPath.Monitor}].ID} != ${Spawn[=${ChaseName}].ID} && ${Spawn[=${ChaseName}].ID} != ${Me.ID} && ${UseAdvPath} | ${Macro.CurLine}
						/if (${MuleDebug}) /echo Following the MA\agLine#:${Macro.CurLine}
						/goto :donefollowing
						
					} else /if (${Spawn[=${ChaseName}].ID} != ${Me.ID} && !${AdvPath.State} && !${Navigation.Active}) {
						/if (${Me.Sitting}) {
							DEBUGN going to stand"
							/if (!${standTimer}) /stand
							/delay 5 ${Me.Standing}
							/if (!${Me.Standing}) {
								DEBUGN I'm not standing, still gonna try to move"
							}
						}
					   /if (${Me.FeetWet}) {
							/if (${Navigation.Active}) {
								/echo Stopping nav \agLine#:${Macro.CurLine}
								/nav stop
							}
							/stick ${ChaseDistance} uw id ${Spawn[=${ChaseName}].ID} loose
							DEBUGMOVE Stick"
						} else {
						   /stick ${ChaseDistance} id ${Spawn[=${ChaseName}].ID} loose
						   DEBUGMOVE Stick"
						}
					}
				}
            }
        }
		:donefollowing
		/if (${OhShitOn}) {
			/call OhShitStuff "Move"
		}
        DEBUGMOVE DoWeMove: Leave"
    /return
|-------------------------------------------------------------------------------------
| SUB: Stuck
| -------------------------------------------------------------------------------------
    Sub Stuck
	/if (${Me.Hovering}) /return
    /declare strafedir string local
           | - We're stuck, back off a second, move left or right (randomly) for 1 second
           /if (${IAmDead}) /return
            /keypress back hold
            /delay 10
            /keypress back
            /if (${Math.Rand[2]}) {
                /varset strafedir STRAFE_LEFT
            } else {
                /varset strafedir STRAFE_RIGHT
            }
            /keypress ${strafedir} hold
            /delay 10
            /keypress ${strafedir}
    /return
| -------------------------------------------------------------------------------------
| SUB: SitIfNotBard
| -------------------------------------------------------------------------------------
	Sub SitIfNotBard(string sentFrom)
		DEBUGN SitIfNotBard Start"
		/if (${MuleDebug}) /echo Enter sit from ${sentFrom}
		/if (!${MedOn}) {
			DEBUGN SitIfNotBard MedOn isn't on so I'm not sitting."
			/return
		}
		/if (${Me.Moving} || ${Navigation.Velocity}) /return
		/if (${IAmABard}) {
			/if (${Twist} && !${Me.HaveExpansion[Gates of Discord]}) {
				DEBUGN SitIfNotBard: I don't have TSS expansion, so no point in sitting"
				/varset bardShouldBeSitting FALSE
				/return
			}
			/if  (!${Me.Gem[${Twist.Current}].HasSPA[12]} && ${Me.HaveExpansion[Gates of Discord]} && (${Me.PctMana} < ${MedStart} || ${Me.PctEndurance} < ${MedStart}) && (${Me.CombatState.Equal[RESTING]} || ${Me.CombatState.Equal[ACTIVE]}) && !${TwistingInvis}) {
				/twist stop
				/stopsong
				/varset TwistStop ${Macro.CurLine}
				|So we don't spam on/off
				/varset Twisting 1
				/varset bardShouldBeSitting TRUE
				/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
				DEBUGN SitIfNotBard: Stopping twist and setting Twisting to 1 so I can sit"
			} else {
				/if (${MuleDebug}) /echo Leaving sit as a bard
				/varset bardShouldBeSitting FALSE
				DEBUGN SitIfNotBard: Leaving cause This wasn't True: (!${Me.Gem[${Twist.Current}].HasSPA[12]} && ${Me.HaveExpansion[Gates of Discord]} && (${Me.PctMana} < ${MedStart} || ${Me.PctEndurance} < ${MedStart}) && (${Me.CombatState.Equal[RESTING]} || ${Me.CombatState.Equal[ACTIVE]}))"
				/return
			}
			/if (!${Me.HaveExpansion[Gates of Discord]}) {
				DEBUGN SitIfNotBard: Returning from sit cause I don't have OOC med and I'm not twisting."
				/varset Twisting 0
				/varset bardShouldBeSitting FALSE
				/return
			}
		}
		|DEBUGN SitIfNotBard: Leaving if I'm still singing/casting ${Me.Casting}"
		|/if (${Me.Casting.ID}) /return
		DEBUGN SitIfNotBard Sitting timer ${sitTimer}"
		/if (${MuleDebug}) /echo Should sit
		|/echo going to sit \agLine#:${Macro.CurLine}
		/if (!${sitTimer}) {
			/sit
			/delay 2s ${Me.Sitting}
			/varset sitTimer ${sitTimer.OriginalValue}
			/if (${MuleDebug}) /echo sitTimer is now ${sitTimer} from ${sitTimer.OriginalValue}
		}
		DEBUGN SitIfNotBard: Leaving"
	/return
| -------------------------------------------------------------------------------------
| SUB: DoWeMed
| -------------------------------------------------------------------------------------
    Sub DoWeMed
		/if (${Me.Hovering}) /return
        /if (!${MedOn}) /return
        /if (${AggroTargetID}) /return
        DEBUGN DoWeMed Enter"
		/declare Med2On int local 0
        /declare MedForceOn int local 0
        /declare MedStat1 string local ${MedStat}
        /declare j int local 0
        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
        /if (!${Me.Moving}) {
            /if (${Select[${Me.Class.ShortName},BRD,BST,PAL,RNG,SHD]} && ${Me.Pct${MedStat2}} < ${MedStart} && ${Me.Pct${MedStat}} > ${MedStart})  {
				|Lemons 15.2.6 This is getting spam called (on a bard). Not sure why, but the message isn't important. No command is issued. 
				|/echo i need to med \agLine#:${Macro.CurLine}
                /varset MedStat1 ${MedStat}
                /varset MedStat ${MedStat2}
                /varset Med2On 1
            } else /if (${Select[${Me.Class.ShortName},BRD,BST,PAL,RNG,SHD]} && ${Me.Pct${MedStat2}} < 90)  {
				/if (${Select[${Role},tank,assist]}) {
					/echo i need to med \agLine#:${Macro.CurLine}
					/varset MedStat1 ${MedStat}
					/varset MedStat ${MedStat2}
					/varset Med2On 1
					/varset MedForceOn 1
				}
            }
            /if (${Group.MainAssist.ID} && ${Group.MainAssist.Sitting}) {
                /if (!${MASitTime}) {
                    /varset MASitTime 300            
                } else /if (${MASitTime} < 260) {
                   /varset MedForceOn 1
                }
            } else {
                /varset MASitTime 0
            }
            /if (${Me.Pct${MedStat}} < ${MedStart} || (${ChainPullHold}==2 && ${Me.Pct${MedStat}} < 100) || (${MedForceOn} && ${Me.Pct${MedStat}} < 90 && !${Role.Find[puller]}) || (${MedForceOn} && ${Me.PctHPs} < 90)) {
                |/echo time to sit the fuck down \agLine#:${Macro.CurLine} 
				|/echo LemonsDebug: ${Me.Pct${MedStat}} < ${MedStart} || (${ChainPullHold}==2 && ${Me.Pct${MedStat}} < 100) || (${MedForceOn} && ${Me.Pct${MedStat}} < 90 && !${Role.Find[puller]}) || ${Me.PctHPs} < 85)
				/squelch /tar clear
                /varset Medding 1
                /if (${Attacking}) /call CombatReset DoWeMed
                /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
					/call BroadCast t "PULLER-> My ${MedStat} is below ${MedStart}% time to med. ${MedStat} ${Me.Pct${MedStat}} ${ChainPullHold} Line#:${Macro.CurLine}"
                }
				| bards twisting while others fighting negate fast med 
                /if (${IAmABard} && ${AggroTargetID}) {
					/if (!${Me.Gem[${Twist.Current}].HasSPA[12]}) {
						/if (${Twist}) {
							/squelch /twist stop
							/stopcast
							/varset TwistStop ${Macro.CurLine}
							/delay 10 ${Me.BardSongPlaying}==FALSE
							/if (${MuleDebug}) /echo Stopping twist ${Macro.CurLine}
						}
						/if (${MuleDebug}) /echo Med Twisting at ${Macro.CurLine}
						/squelch /twist ${TwistMed}
					}
                }
				/if (${Select[${Role},manual]}) /return
                /if (${Medding} && !${Me.XTarget}) {
					/echo Medding until ${MedStat} is at 100% \agLine#:${Macro.CurLine}
				}
				/call RogDragging
				DEBUGN DoWeMed Check if done medding (${Me.Pct${MedStat}} == 100 && ${Me.PctHPs} >= 85)"
				/if (${Me.Pct${MedStat}} == 100 && ${Me.PctHPs} >= 85) /goto :done_medding
                |/if (${Me.Pct${MedStat}} < ${MedStart}) /call BroadCast t "My ${MedStat} is below ${MedStart}% time to med. Line#:${Macro.CurLine}"
            :wait_for_resume
				/if (${MapTheZone}) /call ZoneMap FALSE Med
				/doevents
				/if ((${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > ${ReturnToCampAccuracy}) || ${ChaseAssist}) {
					/call DoWeMove "DoWeMed 1"
				}
				/if (${Me.XTarget}) {
					/varset Medding 0
					/if (${bardShouldBeSitting}) /varset bardShouldBeSitting FALSE
					/return
				}
				/if (${IAmABard}) {
					/if (${TwistingInvis} && !${Me.Gem[${Twist.Current}].HasSPA[12]}) /call Bind_BardInvis
					/if ((${Bool[${TwistMed}]} && ${Int[${TwistMed}]}) && ${TwistOn} && ((${Me.PctMana} > ${MedStart} && ${MedOn}) || !${Me.HaveExpansion[Gates of Discord]})) {
						/if ((!${Select[${Twist.Current},${TwistMed}]} || !${Twist}) && !${Me.Gem[${Twist.Current}].HasSPA[12]} && !${Me.Invis} && !${bardShouldBeSitting}) {
							/echo time to twist ${TwistMed} med \agLine#:${Macro.CurLine}
							/if (!${Me.Mount.ID} && !${Me.Standing}) {
								DEBUGN going to stand"
								/if (!${standTimer}) /stand
								/delay 1s ${Me.Standing}
								/if (!${Me.Standing}) {
									DEBUGN Returning cause I'm not standing"
									/return
								}
							}
							/squelch /twist ${TwistMed}
						}
					}
				}
				/if (${MuleDebug}) /echo Med: Calling sitifnotbard (!${Me.Mount.ID} && !${Me.Sitting} && (!${Navigation.Active} && ${Stick.Status.Equal[OFF]} && !${AdvPath.State}) && (${Me.Pct${MedStat}} < 100 || ${Me.PctHPs} < 90) && (!${SitToMed} || ${Me.CombatState.NotEqual[COMBAT]}))
				DEBUGN Med: Calling sitifnotbard (!${Me.Mount.ID} && !${Me.Sitting} && (!${Navigation.Active} && ${Stick.Status.Equal[OFF]} && !${AdvPath.State}) && (${Me.Pct${MedStat}} < 100 || ${Me.PctHPs} < 90) && (!${SitToMed} || ${Me.CombatState.NotEqual[COMBAT]}))"
				/if (!${Me.Mount.ID} && !${Me.Sitting} && (!${Navigation.Active} && ${Stick.Status.Equal[OFF]} && !${AdvPath.State}) && (${Me.Pct${MedStat}} < 100 || ${Me.PctHPs} < 90) && (!${SitToMed} || ${Me.CombatState.NotEqual[COMBAT]})) {
					/call SitIfNotBard DoWeMed
				}                  
				DEBUGN Med: ${MedStat} ${MedStat1} ${MedStat2}"
				/if (${BandolierOn}) {
					/call DoBandolier
				}
				/delay 1
				/call CheckCasting 50
				|delayremove/delay 1
				/call WaitSubs "DoWeMed"
				/call CheckForCombat 1 DoWeMed
				/if (${AutoRezOn}) /call RezCheck
				/if (${AggroTargetID}) {
					/if (${Med2On}) {
						/varset MedStat ${MedStat1}
					}
					/varset Medding 0
					/if (${bardShouldBeSitting}) /varset bardShouldBeSitting FALSE
					/return
				}
			DEBUGN ${Me.Pct${MedStat}} < 100 || ${Me.PctHPs} < 90, ${Me.Sitting}"
			/if (${Me.Pct${MedStat}} < 100 || ${Me.PctHPs} < 90) {
				DEBUGN  Not done medding yet"
				/goto :wait_for_resume
			}
			|/echo LemonsDebug: ${Me.Pct${MedStat}} < 100 || ${Me.PctHPs} < 90) /goto :wait_for_resume
				
            :done_medding
				|/echo im after done medding
                /if (${Med2On}) {
					|/varset Med2On 0
					/varset MedStat ${MedStat1}
					|/goto :wait_for_resume
				}
                /varset Medding 0
                /if (!${Me.Standing}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return
					}
				}
				/if (${IAmABard}) {
					/if (${Bool[${TwistMed}]}) {
						/if  (!${Me.Gem[${Twist.Current}].HasSPA[12]}) {
							/twist stop
							/stopsong
							/varset TwistStop ${Macro.CurLine}
							/varset Twisting 0
							/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
						}
					}
				}
            }
            /if (${Select[${Role},pullerpettank,puller,hunter,hunterpettank]} && ${Me.PctHPs} <= 50) {
                /echo Medding to 100% health \agLine#:${Macro.CurLine}
                /if (!${Me.Mount.ID} && !${Me.Sitting}) {
					/call SitIfNotBard DoWeMed2
				}
			:WaitFor100
                /doevents
                /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > ${ReturnToCampAccuracy}) {
                    /call DoWeMove "DoWeMed 2"
                }
                /delay 1
                /call CheckCasting 50
                |delayremove/delay 1
				/call WaitSubs
				/call CheckForCombat 1 DoWeMed
				/call GetHostilesOnXTarget
				/if (${Macro.Return} > 0) {
					/varset Medding 0
					/if (${bardShouldBeSitting}) /varset bardShouldBeSitting FALSE
					/return
				}
				/if (${AggroTargetID}) {
					/varset Medding 0
					/if (${bardShouldBeSitting}) /varset bardShouldBeSitting FALSE
					/return
				}

				/if  (${Me.PctHPs}<100) /goto :WaitFor100
				/if (!${Me.Mount.ID} && !${Me.Standing}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return
					}
				}
            }
            /if (${Select[${Role},pullerpettank,hunterpettank]} && !${Me.Invis} && (${Me.Pet.PctHPs} <= 50 || ${PetForceHealOnMed})) {
                | Check pet is at full health before pulling.  
                /echo Waiting on pet to full health before next pull        
				/if (${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100) {                
					:WaitingOnPetHealth
                    /for j ${SingleHeal.Size} downto 1
                        /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /goto :NextPetHeal
                        /if (${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
							DEBUGN DoPetMedStuff (${SingleHeal[${j}].Arg[3,|].Find[PET]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range})"
							/call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Med
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /call BroadCast o "${Heals[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} << 0"
                                /varcalc PetHealTimer${j} (${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration.TotalSeconds}*${DurationMod})*10
                            }
                            /varset j 1
                        }
                        :NextPetHeal
                    /next j
                    /if (${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100 && !${AggroTargetID}) {
                        /delay 1
                        /goto :WaitingOnPetHealth
                    }
                }  
            }             
        }
		/if (${bardShouldBeSitting}) /varset bardShouldBeSitting FALSE
        DEBUGN DoWeMed Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: MuleSpew
| -------------------------------------------------------------------------------------
	Sub MuleSpew(string thesub, int theline, string themsg)
		/if (${thesub.Find[GroupBuff]} > 0) {
			/varset thesub GroupBuff
		} else /if (${thesub.Find[CacheBuffs]} > 0) {
			/varset thesub CacheBuffs
		} else /if (${thesub.Find[CheckAura]} > 0) {
			/varset thesub CheckAura
		} else /if (${thesub.Find[CastWhat]} > 0) {
			/varset thesub CastWhat
		}
		|/echo MuleSpew ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGN ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGBUFF ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGDPS ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGCAST ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGCOMBAT ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGHEALS ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGMOVE ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGMEZ ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGPET ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGPULL ${thesub} ${themsg} ${theline}:: Mulespew"
		DEBUGTARGETCHOICE TargetChoice:${thesub} ${themsg} ${theline}:: Mulespew"
	/return

| -------------------------------------------------------------------------------------
| SUB: GroupBuff ${i} "${SpellToCast}" "${BuffSub}" "${2ndPart}" "${3rdPart}" "${5thPart}" "${SpellRange}"
| -------------------------------------------------------------------------------------
	Sub GroupBuff(int i, string SpellToCast, string BuffSub, string 2ndPart, string 3rdPart, string 5thPart, int SpellRange, int bDoMGB)
		DEBUGBUFF i = ${i} SpellToCast = ${SpellToCast} BuffSub = ${BuffSub} 2ndPart = ${2ndPart} 3rdPart = ${3rdPart} 5thPart = ${5thPart} SpellRange = ${SpellRange}"
		/declare j int local
		/declare TheBuffee int local
		/declare h int local
		/declare BuffList[6] int local 0
		/declare numBuffArray int local 0
		/declare silverBuff string local

		/if (${2ndPart.Find[Dual]}) {
			/varset BuffSub ${3rdPart}
			DEBUGBUFF GroupBuff resetting BuffSub to the name of the buff cause it's Dual tagged | ${BuffSub}"
		}
		/if (${BuffSub.Find[Rk. ]} && ${Me.SpellRankCap} < 2) {
			/varset silverBuff ${BuffSub.Left[${Math.Calc[${BuffSub.Find[Rk.]}-2]}]}
		} else {
			/varset silverBuff ${BuffSub}
		}
		|First we create an array of all the members who need a buff by GroupMember#
		/for j 0 to ${Group}
			DEBUGBUFF Checking if Group Member ${j} has ${silverBuff} on with a count of ${numBuffArray}."
			/call GetHostilesOnXTarget
			/if (${Macro.Return} > 0 && !${BuffMode}) {
				/return 100
			}
			/varset TheBuffee ${Group.Member[${j}].ID}
			| Check if party member is alive in zone and within spell range and spell timer does not exist
			/if (!${TheBuffee}) {
				DEBUGBUFF Skipping because Group Member ${j} ID is invalid"
				/continue
			}
			/if (${Spawn[${Group.Member[${j}]}].Distance} >= ${SpellRange}) {
				DEBUGBUFF Skipping ${2ndPart} buff because Group Member ${j} is out of range."
				/continue
			}
			/if (${Buff${i}GM${j}} && ${Spawn[${Group.Member[${j}].ID}].CachedBuff[${silverBuff}].Duration.TotalSeconds} > 30) {
				DEBUGBUFF Skipping ${silverBuff} buff on Group Member ${j} because BuffTimer${j} is ${Buff${i}GM${j}}"
				/continue
			}
			/if (${ConditionsOn}) {
				/if (${BuffsCOn}) {
					/if (${If[${BuffsCond[${i}]},0,1]}) {
						DEBUGBUFF Skipping Mem${j} ${silverBuff} because BuffsCond${i} (${BuffsCond[${i}]}) ${BuffsCond[${i}].Replace[$,#]} returned FALSE"
						/continue
					} else {
						DEBUGBUFF Cond: ${BuffsCond[${i}]} ${BuffsCond[${i}].Replace[$,#]} for ${silverBuff} Returned TRUE , moving on."
					}
				}
			}
			/if (${2ndPart.Equal[Me]} && ${Group.Member[${j}].ID}!=${Me.ID}) {
				DEBUGBUFF Skipping ${2ndPart} buff on Group Member ${j} because 2ndPart is ME AND Group Member ${j} is NOT ME"
				/continue
			}
			/if (${Select[${2ndPart},class,dualclass]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},${5thPart}]}==0) {
				DEBUGBUFF Skipping ${2ndPart} buff because Group Member ${j} is not the correct class for ${silverBuff}."
				/continue
			}
			DEBUGBUFF #${j} 2nd:${2ndPart} | Class:${Group.Member[${j}].Class.ShortName}"
			/if ((${2ndPart.Equal[caster]} && ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${2ndPart.Equal[Melee]} && ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) {
				DEBUGBUFF Skipping ${2ndPart} buff because Group Member ${j} is not the correct class for ${silverBuff}."
				/continue
			}
			/if (${Me.CurrentMana} < ${Spell[${Buffs[${i}]}].Mana}) {
				DEBUGBUFF Skipping ${Buffs[${i}]} because ${Me.CurrentMana} is less than ${Spell[${Buffs[${i}]}].Mana}."
				/continue
			}
			/if (${2ndPart.Equal[!MA]} && ${Group.Member[${j}].ID}==${Spawn[${MainAssistType} ${MainAssist}].ID}) {
				DEBUGBUFF Skipping ${silverBuff} because 2ndPart is !MA and Group Member ${j} is the MA"
				/continue
			}
			/if (${2ndPart.Equal[!ME]} && ${Group.Member[${j}].ID}==${Me.ID}) {
				DEBUGBUFF Skipping ${silverBuff} because 2ndPart is !ME and Group Member ${j} is ME"
				/continue
			}
			/if (${Cursor.ID}) /call CheckCursor
			/if (${AggroTargetID} && !${BuffMode}) {
				/return 100
			}
			/if (${Group.Member[${j}].ID}==${Me.ID}) {
				|Well, its me, I know my own buffs no need to use cached here...
				DEBUGBUFF Checking if I have ${silverBuff} on me"
				/if (${Me.Buff["${silverBuff}"].ID} || ${Me.Song["${silverBuff}"].ID}) {
					DEBUGBUFF Skipping ${silverBuff} because it's already on Me, no need to buff it right now."
					/continue
				} else /if (!${Spell[${silverBuff}].Stacks}) {
					DEBUGBUFF GroupBuff The spell doesn't stack on me"
					/continue
				} else {
					DEBUGBUFF Well, I do NOT have ${silverBuff} on Me and it stacks, moving on"
					/goto :yes
				}
			} 
			/call CacheBuffs ${Group.Member[${j}].ID}
			DEBUGBUFF Checking if Group.Member ${j} has ${silverBuff} on him"
			/if (${Spawn[${Group.Member[${j}].ID}].CachedBuff[${silverBuff}].ID}) {
				/if (${Spawn[${Group.Member[${j}].ID}].CachedBuff[${silverBuff}].Duration.TotalSeconds} > 30) {
					DEBUGBUFF Skipping ${silverBuff} because it's already on Group Member ${j}, no need to buff it right now."
					/continue
				}
			} else {
				DEBUGBUFF Group.Member ${j} DOES NOT have ${silverBuff} on them ${Spawn[${Group.Member[${j}].ID}].CachedBuff[${silverBuff}].ID}, moving on"
			}
			/if (!${Spell[${silverBuff}].StacksSpawn[${Group.Member[${j}].ID}]}) {
				DEBUGBUFF Skipping ${SpellToCast} because it DOES NOT stack on Group Member ${j}."
				/continue
			}
			:yes
			/varcalc numBuffArray ${numBuffArray}+1
			/varset BuffList[${numBuffArray}] ${j}
			DEBUGBUFF Added ${Group.Member[${j}]} to needs buff ${silverBuff}. BuffList${numBuffArray} is set to ${BuffList[${numBuffArray}]}."
		/next j
	
		|Now we can check if we have enough mana to cast the buff on the number of people who need it. 
		|Lemons: Ya know what? Fuck this. "O, I don't have the mana to buff everyone instantly, so I'm not gonna do it". Fucking dumb. 
		|/if (${Spell[${SpellToCast}].TargetType.Find[single]}) {
		|	/if (${Me.CurrentMana} < (${Spell[${SpellToCast}].Mana} * ${numBuffArray})) {
		|		DEBUGBUFF Skipping ${SpellToCast} because I dont have enough mana."
		|		/return 0
		|	}
		|	DEBUGBUFF Single Type Group Buff Check for ${SpellToCast} Starts now."
		|}

		DEBUGBUFF Now should be casting buffs. Number of members who need the buff is ${numBuffArray}"
		|Now that we created an array of group members who need the buff, we will actually buff them. 
		/for h 1 to ${numBuffArray}
			/if (${ChaseAssist} && !${BuffWhileChasing}) {
				DEBUGBUFF Chaseassist is now on and I'm not supposed to buff while chasing"
				/return
			}
			/if (${numBuffArray} < 1) {
				DEBUGBUFF Leaving Buffing cause the buff array didn't have any entries"
				/return 0
				}
			/if ((${Spell[${SpellToCast}].MyRange}>0 && ${Group.Member[${BuffList[${h}]}].Distance}>${Spell[${SpellToCast}].MyRange}) || (${Spell[${SpellToCast}].AERange}>0 && ${Group.Member[${BuffList[${h}]}].Distance}>${Spell[${SpellToCast}].AERange})) {
				DEBUGBUFF ${BuffList[${h}]} is too far away ((${Spell[${SpellToCast}].MyRange}>0 && ${Group.Member[${BuffList[${h}]}].Distance}>${Spell[${SpellToCast}].MyRange}) || (${Spell[${SpellToCast}].AERange}>0 && ${Group.Member[${BuffList[${h}]}].Distance}>${Spell[${SpellToCast}].AERange}))"
				/continue
				}
			/if (${Target.ID}!=${Group.Member[${BuffList[${h}]}].ID}) {
				DEBUGBUFF Targeting: Group Member ${BuffList[${h}]} entry #${h}"
				/if (${MuleDebug}) /echo Targetin at\agLine#:${Macro.CurLine}
				/target id ${Group.Member[${BuffList[${h}]}].ID}
				/delay 1s ${Target.ID}==${Group.Member[${BuffList[${h}]}].ID}
				|It's possible they could have gotten this buff already even if we get here due to cachedbuff being stale
				|So better do one final check, we cant get songs at this point and that sucks of course but it's all we got for now...
				/delay 3s ${Target.BuffsPopulated}
				/delay 3s ${Target.CachedBuffCount}!=-1
				/if (${Target.Buff[${silverBuff}].ID}) {
					DEBUGBUFF Skipping ${silverBuff} because it's already on Group Member ${BuffList[${h}]}, no need to buff it right now."
					/continue
				}
			}
			/delay 3s ${Me.SpellInCooldown}==FALSE
			DEBUGBUFF Buffing ${SpellToCast} on Group Member ${BuffList[${h}]}."
			/if (${bDoMGB}) {
				:activatemgb2
				/if (${Me.AltAbilityReady[Mass Group Buff]}) {
					DEBUGBUFF Trying to activate MGB"
					/alt act 35
					/delay 1
					/goto :activatemgb2
				}
			}
			/call CastWhat "${SpellToCast}" ${Group.Member[${BuffList[${h}]}].ID} Buffs-nomem
			/if (${Spell[${SpellToCast}].TargetType.Find[Group v]}) {
				DEBUGBUFF ${Spell[${SpellToCast}]} is a group buff, clearing cachedbuffs"
			}
			/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
				DEBUGBUFF Buffing ${SpellToCast} on Group Member ${BuffList[${h}]}."
				/if (${2ndPart.Find[Dual]}) {
					DEBUGBUFF Assigning $Buffs[${i}]} as ${3rdPart} (3rdPart) of ${2ndPart} tag for actual duration for WriteBuffs"
					/varset Buffs[${i}] ${3rdPart}
				}
				DEBUGBUFF Setting Buff${i}GM${BuffList[${h}]} to (${Spell[${Buffs[${i}]}].Duration.TotalSeconds}*${DurationMod})*10 ${Math.Calc[(${Spell[${Buffs[${i}]}].Duration.TotalSeconds}*${DurationMod})*10]}"
				/varcalc Buff${i}GM${BuffList[${h}]} (${Spell[${Buffs[${i}]}].Duration.TotalSeconds}*${DurationMod})*10
				/doevents flush Worn_off
				/varset WriteBuffsTimer 0
				/call WriteBuffs
				/if (${Spell[${SpellToCast}].TargetType.Find[Group v]}) {
					DEBUGBUFF Returning because I just cast a group buff and everyone should have it"
					/return 0
				}
				/if (${Group}==${BuffList[${h}]}) {
					DEBUGBUFF Returning 0 because ${Group}==${BuffList[${h}]}"
					/return 0
				}
			}
		/next h
	/return 0
| -------------------------------------------------------------------------------------
| SUB: CheckBuffs
| -------------------------------------------------------------------------------------
    Sub CheckBuffs
		|/echo checking buffs
		/if (${Me.Hovering}) /return
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/call GetHostilesOnXTarget
        /if (${Macro.Return} > 0 && !${BuffMode}) {
			DEBUGBUFF Mobs on XTar, not gonna buff."
			/return
		}
        /if (!${BuffsOn}) /return
        /if (${IAmDead}) /return
        /if (${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) {
			DEBUGBUFF I'm Invis, not gonna buff"
			/return
		}
		/if (${ChaseAssist} && !${BuffWhileChasing}) {
			DEBUGBUFF Returning from CheckBuffs at 4298 cause ${BuffWhileChasing} BuffWhileChasing"
			/return
		}
		/declare bufftype string local spell
        /declare i int local 0
        /declare j int local 0
        /declare k int local 0
        /declare l int local 0
		/declare x int local 0
        /declare FullText string local 0
        /declare SpellToCast string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0
        /declare 4thPart string local 0
        /declare 5thPart string local 0
        /declare SpellRange int local 100
        /declare MATargetID int local
        /declare BookSpellTT string local 0
        /declare BuffSub string local
        /declare bDoMGB int local 0
		/declare TheBuffee int local
		/declare FullOOG string local
		/declare RaidFlag bool local FALSE
		/declare FellowFlag bool local FALSE
		/declare RangeFlag bool local FALSE
		/declare RangeRange int local 0
		/declare SkipFlag bool local FALSE
		/declare silverBuff string local

		/if (${PowerSource.NotEqual[NULL]} && ${Bool[${Me.Inventory[powersource].Name.Length}]} && !${Me.Inventory[powersource].Power}) {
           /call CheckCursor
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /if (${Cursor.Name.Equal[${PowerSource}]}) /destroy
           /delay 5s ${Cursor.Equal[Null]}
        }
	    /if (${MountOn} && !${Me.Mount.ID} && ${Me.CanMount} && ${Me.CombatState.NotEqual[COMBAT]} && !${ChaseAssist}) {
			|DEBUGBUFF time to mount up! Zone.Outdoor is ${Zone.Outdoor}" 
			/call CastMount
		}
		|Initial check so we don't waste time with large entries if we're in combat or something. 
		/call GetHostilesOnXTarget
		/if ((${Macro.Return} > 0 && !${BuffMode}) || ${ReadBuffsTimer}) {
			/if (!${ReadBuffsTimer} || !${Int[${Math.Calc[${ReadBuffsTimer.Value} % 10]}]}) DEBUGBUFF Leaving checkbuff cause I'm in combat or Timer: ${ReadBuffsTimer}"
			/return
		}
		/for j 1 to ${Buffs.Size}
			/if (${Math.Calc[${Buffs[${j}].Arg[2,:].Count[,]} + 1]} > ${x}) {
				/varset x ${Math.Calc[${Buffs[${j}].Arg[2,:].Count[,]} + 1]}
			}
		/next j
		
		|/echo /declare OOGArray[${x}] string local \agLine#:${Macro.CurLine}
		/declare OOGArray[${x}] string local
		|/echo ${OOGArray.Size} is OOGArray Size. Should be ${x} \agLine#:${Macro.CurLine}

        | Call Buffs Array
        /for i 1 to ${Buffs.Size}
			/call GetHostilesOnXTarget
			/if (${MapTheZone}) /call ZoneMap FALSE med
			/if (${Macro.Return} > 0 && !${BuffMode}) {
				DEBUGBUFF lets get out of here if we are under attack, it makes no sense to continue under that circumstance...${Buffs[${i}]} ${FullText}"
				/return
			}
			/if (${ChaseAssist} && !${BuffWhileChasing}) {
				DEBUGBUFF Chaseassist is now on and I'm not supposed to buff while chasing"
				/return
			}
			/varset bufftype unknown
			/varset bDoMGB 0
			/doevents
            /if (${ChaseAssist} && !${CombatStart}) {
				/call DoWeMove "CheckBuffs"
			}
            /if (${HealsOn}) /call CheckHealth
            /if (${AutoRezOn}) {
				/call RezCheck
				| Don't buff if there are still corpses to rez
				/if (${SpawnCount[group pccorpse radius 100]}) {
					/if (${Select[${Me.Class.ShortName},CLR,DRU,SHM,PAL]}!=0) {
						/if (${Me.Level} >= 12) {
							DEBUGBUFF There are group members dead, I won't buff until they are all here."
							/return
						}
					}
				}
			}
			| Combat check to skip all buffs
            /if (${Me.CombatState.Equal[COMBAT]} && !${BuffMode}) {
				DEBUGBUFF CombatState is ${Me.CombatState} and I'm not in BuffMode ${BuffMode}, not gonna buff. "
				/return
				}
            /if (${AggroTargetID} && !${BuffMode}) /return
            /if (${IAmDead}) /return
            /if (${ReadBuffsTimer}) /return
			|DEBUGBUFF OOGArray set to a max size of ${x}"
			/if (${Group.AnyoneMissing}==TRUE && !${Raid.Members}) {
				DEBUGBUFF There are group members missing, I won't buff until they are all here."
				/return
			}
			| If its a group spell cast on mercs - owner
			/if (${Spawn[=${MainAssist}].Type.Equal[mercenary]} && ${Spell[${Buffs[${i}]}].TargetType.Find[group v]}) { 
				/varset MATargetID ${Spawn[=${MainAssist}].Owner.ID}
			} else /if (${Select[${Role},hunterpettank,pettank,pullerpettank]} ) {
				/varset MATargetID ${Me.Pet.ID}
			} else {
				/varset MATargetID ${Spawn[=${MainAssist}].ID}
			}
            | If Buffs=NULL skip to next buff
            /if (${Buffs[${i}].Equal[null]} || ${Buffs[${i}].Arg[3,|].Equal[0]} || ${Buffs[${i}].Arg[2,|].Equal[0]}) {
				/goto :SkipBuff
			}
			|Lemons: The buff array is being set to 0 somewhere. This is a bandaid on a dam, but at least we'll reset it.
			/if (${Buffs[${i}].Equal[0]}) {
				DEBUGBUFF Buff ${i} is set to 0 for some reason! Trying to reset it from ini..."
				|/call BroadCast r "Buff ${i} is set to 0 for some reason! Trying to reset it from ini..."
				/varset Buffs[${i}] ${Ini[${IniFileName},Buffs,Buffs${i}]}
				DEBUGBUFF Buffs[${i}] set to ${Buffs[${i}]}"
			}
            | Check for combat and skip redundant subs called in combat routines.
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to the buff
			/if (${Buffs[${i}].NotEqual["${Parse[2,${Ini[${IniFileName},Buffs,Buffs${i}]}]}"]} && !${Buffs[${i}].Find[Rk. ]}) {
				/varset Buffs[${i}] ${Parse[2,${Ini[${IniFileName},Buffs,Buffs${i}]}]}
				DEBUGBUFF Buffs: Reset Buffs${i} from Buffs[${i}] to ${Parse[2,${Ini[${IniFileName},Buffs,Buffs${i}]}]}"
			}
            /if (${Buffs[${i}].Arg[2,|].Length}) {
                /varset FullText ${Buffs[${i}]}
                /varset SpellToCast ${Buffs[${i}].Arg[1,|]}
                /varset 2ndPart ${Buffs[${i}].Arg[2,|]}
                /varset 3rdPart ${Buffs[${i}].Arg[3,|]}
                /varset 4thPart ${Buffs[${i}].Arg[4,|]}
                /varset 5thPart ${Buffs[${i}].Arg[5,|]}
				/if (${2ndPart.Equal[Dual]}) {
                    /if (${4thPart.Equal[MA]}) {
                        /varset 2ndPart DualMA
                    } else /if (${4thPart.Equal[melee]}) {
                        /varset 2ndPart DualMelee
                    } else /if (${4thPart.Equal[caster]}) {
                        /varset 2ndPart DualCaster
                    } else /if (${4thPart.Equal[class]}) {
                        /varset 2ndPart DualClass
                    } else /if (${4thPart.Equal[mgb]}) {
                        /varset 2ndPart DualMgb
                    }
                } else /if (${2ndPart.Equal[class]}) {
                    /varset 5thPart ${3rdPart}
                }
                /if (${2ndPart.Equal[Dualmgb]}) {
					/varset bDoMGB 1
					|/varset 2ndPart Dual
				} else /if (${2ndPart.Equal[mgb]}) {
					/varset bDoMGB 1
				}
            } else {
                /varset SpellToCast ${Buffs[${i}]}
                /varset 2ndPart 
                /varset 3rdPart 
                /varset 4thPart 
				/varset 5thPart 
            }
			|/echo ${SpellToCast} ${2ndPart} ${3rdPart} ${4thPart} ${5thPart}
			DEBUGBUFF STC: ${SpellToCast} 2:${2ndPart} 3: ${3rdPart} 4:${4thPart} 5:${5thPart} MGB: ${bDoMGB} FullText: ${Buffs[${i}]}"
			|Lemons: Have to set the OOG stuff here cause we mess with the array entry below. 
			DEBUGBUFF LemonsDebug: Checking for OOG: ${FullText.Find[OOG]} i = ${i} and buff is ${SpellToCast}. FullText = ${FullText}. Trying to set FULLOOG to ${Buffs[${i}].Arg[2,:]} Which should be everything after : \agLine#:${Macro.CurLine}"
			DEBUGBUFF LemonsDebug: The array is ${Buffs[${i}]} \agLine#:${Macro.CurLine}"
			/if (${FullText.Find[OOG:]}) { 
				/varset FullOOG ${Buffs[${i}].Arg[2,:]}
				DEBUGBUFF LemonsDebug: Set FullOOG line to ${FullOOG} from >> ${Buffs[${i}].Arg[2,:]} >> ${Buffs[${i}].Arg[1,:]}, iterating ${Math.Calc[${Buffs[${i}].Arg[2,:].Count[,]} + 1]} times"
				/for x 1 to ${Math.Calc[${Buffs[${i}].Arg[2,:].Count[,]} + 1]}
					DEBUGBUFF LemonsDebug:${FullOOG.Arg[${x},,]} is entry with spawn data of ${Spawn[${FullOOG.Arg[${x},,]}].ID} and ${Spawn[${FullOOG.Arg[${x},,]}].Type} and Dist= ${Spawn[${FullOOG.Arg[${x},,]}].Distance} on #${x} \agLine#:${Macro.CurLine}"
					|Lemons: Check if it's a valid target right now that's not me because of tags like raid
					/if (${Spawn[${FullOOG.Arg[${x},,]}].Type.Equal[PC]} && ${Spawn[${FullOOG.Arg[${x},,]}].Distance} <= ${SpellRange} && ${Spawn[${FullOOG.Arg[${x},,]}].ID} != ${Me.ID} && ${FullOOG.Arg[${x},,].NotEqual[raid]} && ${FullOOG.Arg[${x},,].NotEqual[fellowship]} && !${FullOOG.Arg[${x},,].Find[range]}) {
						/varset OOGArray[${x}] ${Spawn[${FullOOG.Arg[${x},,]}].ID}
						DEBUGBUFF OOGArray${x} Set to ${OOGArray[${x}]}"
						|/echo LemonsDebug: OOGArray${x} Set to ${OOGArray[${x}]}
					} else /if (${Spawn[${FullOOG.Arg[${x},,]}].Type.Equal[PET]} && ${Spawn[2 ${FullOOG.Arg[${x},,]}].ID} && ${Spawn[2 ${FullOOG.Arg[${x},,]}].Type.Equal[PC]} && ${Spawn[2 ${FullOOG.Arg[${x},,]}].Distance} <= ${SpellRange}) {
						/varset OOGArray[${x}] ${Spawn[2 ${FullOOG.Arg[${x},,]}].ID}
						|/echo LemonsDebug: OOGArray${x} Set to ${OOGArray[${x}]} cause the first spawn was a pet with the same name
					} else /if (${Spawn[${FullOOG.Arg[${x},,]}].Type.Equal[PET]} && ${Spawn[${FullOOG.Arg[${x},,]}].Distance} <= ${SpellRange}) {
						/varset OOGArray[${x}] ${Spawn[${FullOOG.Arg[${x},,]}].ID}
						|/echo OOGArray${x} Set to ${OOGArray[${x}]} and it's a pet
						DEBUGBUFF OOGArray${x} Set to ${OOGArray[${x}]}"								
					} else /if (${FullOOG.Arg[${x},,].Find[xtarget]}) {
						/if (${FullOOG.Arg[${x},,].Length} == 8 && ${Me.XTarget[${FullOOG.Arg[${x},,].Right[1]}].ID}) {
							/varset OOGArray[${x}] ${Me.XTarget[${FullOOG.Arg[${x},,].Right[1]}].ID}
							DEBUGBUFF OOGArray${x} Set to ${OOGArray[${x}]} which should be the ID of XTarget 9 or less from ${FullOOG.Arg[${x},,]}"
						} else /if (${FullOOG.Arg[${x},,].Length} == 9 && ${Me.XTarget[${FullOOG.Arg[${x},,].Right[2]}].ID}) {
							/varset OOGArray[${x}] ${Me.XTarget[${FullOOG.Arg[${x},,].Right[2]}].ID}
							DEBUGBUFF OOGArray${x} Set to ${OOGArray[${x}]} which should be the ID of XTarget 10 or greater from ${FullOOG.Arg[${x},,]}"
						}
					} else /if (!${Spawn[${FullOOG.Arg[${x},,]}].ID} && ${Spawn[${Ini[${IniFileName},Buffs,Buffs${x}].Arg[${x},,].Arg[2,:]}].ID} && ${Spawn[${Ini[${IniFileName},Buffs,Buffs${x}].Arg[${x},,].Arg[2,:]}].Type.Equal[PET]}) {
						/echo Your pet isn't loaded into the array! I checked for it anyways.
						/varset OOGArray[${x}] ${Spawn[${Ini[${IniFileName},Buffs,Buffs${x}].Arg[${x},,].Arg[2,:]}].ID}
					} else /if (${FullOOG.Arg[${x},,].Equal[raid]}) {
						/varset RaidFlag TRUE
						/varset OOGArray[${x}] Raid
						DEBUGBUFF Setting RaidFlag to ${RaidFlag}"
					} else /if (${FullOOG.Arg[${x},,].Equal[fellowship]}) {
						/varset FellowFlag TRUE
						/varset OOGArray[${x}] Fellowship
						DEBUGBUFF Setting FelowFlag to ${FellowFlag}"
					} else /if (${FullOOG.Arg[${x},,].Left[5].Equal[range]}) {
						/varset RangeFlag TRUE
						/varset RangeRange ${FullOOG.Arg[${x},,].Right[-5]}
						/varset OOGArray[${x}] Range
						DEBUGBUFF Setting RangeFlag to ${RangeFlag} ${RangeRange}"
					} else {
						DEBUGBUFF No valid OOG buff target for entry ${x} with ${FullText} and ${FullOOG}"
						|/echo LemonsDebug: No valid OOG buff target for entry #${x}
						/varset OOGArray[${x}]
					}
					DEBUGBUFF ${OOGArray[${x}]} is OOGArray ${x} Line:${Macro.CurLine}"
					/if (${x} == ${Math.Calc[${Buffs[${i}].Arg[2,:].Count[,]} + 1]}) /break
				/next x
			}
			
			|Lemons: I don't know why we only check this for dual stuff...but I'm not going to rewrite this entire buff logic. Replace with a check for what we can cast and keep buffsub.
            /if (${Me.SpellRankCap} < 3 && ${Select[${2ndPart},Dual,DualMA]}==0) {
                /if (${Me.SpellRankCap} == 2) {
					/if (${SpellToCast.Find[ Rk. III]}) {
						/varset BuffSub ${SpellToCast.Left[${Math.Calc[${SpellToCast.Find[ Rk.]}-1]}]}
						DEBUGBUFF BuffSub set to ${BuffSub}"
					} else {
						/varset BuffSub ${SpellToCast}
						DEBUGBUFF BuffSub set to ${BuffSub}"
					}
                } else {
                    /varset BuffSub ${SpellToCast}
					DEBUGBUFF BuffSub set to ${BuffSub}"
                }
            } else {
                /varset BuffSub ${SpellToCast}
				DEBUGBUFF BuffSub set to ${BuffSub}"
            }
			DEBUGBUFF BuffSub is ${BuffSub}"
			/if (${BuffSub.Find[item:]}) {
				/varset SpellToCast ${BuffSub.Replace[item:,]}
				/varset BuffSub ${SpellToCast}
				DEBUGBUFF BuffSub set to ${BuffSub}"
			} else /if (${BuffSub.Find[command:]}) {
				/varset SpellToCast ${BuffSub.Replace[command:,]}
				/varset BuffSub ${SpellToCast}
				/varset bufftype command
				DEBUGBUFF BuffSub set to ${BuffSub}"
			} else /if (${BuffSub.Find[summoned:]}) {
				/varset SpellToCast ${BuffSub.Replace[summoned:,]}
				/varset BuffSub ${SpellToCast}
				DEBUGBUFF BuffSub set to ${BuffSub}"
			}
			/if (${Me.SpellRankCap} < 2 && ${BuffSub.Find[Rk. ]}) {
				/varset silverBuff ${BuffSub.Left[${Math.Calc[${BuffSub.Find[Rk.]}-2]}]}
			} else {
				/varset silverBuff ${BuffSub}
			}
			DEBUGBUFF BuffSub is ${BuffSub} and STC is ${SpellToCast} and silver is ${silverBuff}"
			| lets check what this is first of all:
			| is it an altability? Lemons: This can't handle spells and AA that have the same name. Changed to check if we have the AA purchased.  
			/if (${bufftype.NotEqual[command]}) {
				/if (${AltAbility[${BuffSub}]} && ${AltAbility[${BuffSub}].Rank} > 0) {
					/varset bufftype aa
					DEBUGBUFF Setting bufftype for ${BuffSub} to ${bufftype}"
				} else /if (${Spell[${BuffSub}].ID}) {
					/if (${Spell[${BuffSub}].IsSkill}) {
						/varset bufftype ca
						DEBUGBUFF Setting bufftype for ${BuffSub} to ${bufftype}"
					} else {
						/varset bufftype spell
						DEBUGBUFF Setting bufftype for ${BuffSub} to ${bufftype}"
					}
				}
				/if (${FindItem[=${BuffSub}].ID}) {
					/varset bufftype item
					DEBUGBUFF Setting bufftype for ${BuffSub} to ${bufftype}"
					|DEBUGBUFF Changing BuffSub to the spell on the item"
					|/varset BuffSub ${FindItem[=${BuffSub}].Clicky.Spell}
					DEBUGBUFF BuffSub is now ${BuffSub}"
				}
			}
			DEBUGBUFF Bufftype is ${bufftype}"
			|ok checks are done we now know wha type of spell this is
			/if (${bufftype.Equal[aa]}) {
				|/call DoAAChecks ${BuffSub}
				/if (!${Me.AltAbilityReady[${BuffSub}]}) {
					DEBUGBUFF |${BuffSub}| is a AA, but it is NOT ready, I will skip it. Ready?:${Me.AltAbilityReady[${BuffSub}]}"
					/goto :SkipBuff
				}
			} else /if (${bufftype.Equal[item]}) {
				/if (!${Me.ItemReady[=${BuffSub}]}) {
					DEBUGBUFF ${BuffSub} is a Item, but it is NOT ready, I will skip it."
					/goto :SkipBuff
				}
			} else /if (${bufftype.Equal[ca]}) {
				/if (!${Me.CombatAbilityReady[${Spell["${BuffSub}"].RankName}]}) {
					DEBUGBUFF ${BuffSub} is a CA, but it is NOT ready, I will skip it."
					/goto :SkipBuff
				}
			} else /if (${bufftype.Equal[spell]}) {
				/if (${Me.Book[${Spell[${BuffSub}].RankName}]}) {
					/if (${Me.Gem[${Spell[${BuffSub}].RankName}]}) {
						/if (!${Me.SpellReady[${Spell[${BuffSub}].RankName}]}) {
							DEBUGBUFF ${Me.SpellReady[${BuffSub}]} ${Spell[${BuffSub}].RankName} is a Spell, but it is NOT ready, I will skip it."
							/goto :SkipBuff
						}
					}
					DEBUGBUFF setting BookSpellTT to ${Spell[${BuffSub}].TargetType}"
					/varset BookSpellTT ${Spell[${BuffSub}].TargetType}
				}
			} else /if (${bufftype.Equal[command]}) {
				DEBUGBUFF We got a Command buff ${SpellToCast} | ${2ndPart} | ${3rdPart} | ${4thPart} | ${5thPart}"			
			}

			DEBUGBUFF PARTS: ${SpellToCast} | ${2ndPart} | ${3rdPart} | ${4thPart} | ${5thPart}"

			| but first some reagentchecks this is checked for all buffs no matter if they are aa, ca, item or spellbook spells
			/if (${Spell[${BuffSub}].ReagentID[1]} > 0) {
				/if (${FindItemCount[${Spell[${BuffSub}].ReagentID[1]}]} < ${Spell[${BuffSub}].ReagentCount[1]}) {
					DEBUGBUFF ${BuffSub} requires a Reagent to cast it's ID is ${Spell[${BuffSub}].ReagentID[1]} and you don't have any"
					|DEBUGBUFF Buff${i} You are missing components. Turning off ${BuffSub}."
					|/varset Buffs[${i}] NULL
					|/varset FullText NULL
					/goto :SkipBuff
				}
			}
			/if (${Spell[${BuffSub}].NoExpendReagentID[1]} > 0) {
				/if (${FindItemCount[${Spell[${BuffSub}].NoExpendReagentID[1]}]} == 0) {
					DEBUGBUFF ${BuffSub} requires (but does not consume) a Reagent to cast it's ID is ${Spell[${BuffSub}].NoExpendReagentID[1]} and you don't have any"
					|DEBUGBUFF Buff${i} You are missing components. Turning off ${BuffSub}."
					|/varset Buffs[${i}] NULL
					|/varset FullText NULL
					/goto :SkipBuff
				}
			}
			
            /if (${bufftype.Equal[item]}) {
				/if (${FindItem[=${BuffSub}].Spell.ID}) {				
					/if (${FindItem[=${BuffSub}].Spell.TargetType.Find[Group v]}) {
						/varset SpellRange ${FindItem[=${BuffSub}].Spell.AERange}
						DEBUGBUFF Setting ${bufftype} SpellRange for ${BuffSub} to ${SpellRange}"
					}
				}
			} else {
				/if (${Spell[${BuffSub}].TargetType.Find[Group v]}) {
					/varset SpellRange ${Spell[${BuffSub}].AERange}
					DEBUGBUFF Setting ${bufftype} SpellRange for ${BuffSub} to ${SpellRange}"
				}
			}
            /if (!${SpellRange}) {
				/varset SpellRange 100
			}
			/if (${bufftype.Equal[command]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
				DEBUGBUFF Buff is a Command, lets do it."
				/call CastCommand "${BuffSub}"
				/goto :SkipCheckIni
			}
			/if (${Select[NoGroup,${2ndPart},${3rdPart},${4thPart},${5thPart}]}) {
				DEBUGBUFF Skipping group check cause it's tagged as NoGroup"
				/goto :SkipBuff
			}
			|DEBUGBUFF 1 checking buff ${BuffSub}"
            | Check for Mana/End AA Regen on others
            /if (${Group} && ${Select[${2ndPart},Endgroup,Managroup]} > 0 && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
                /if (${2ndPart.Equal[Endgroup]}) {
					/if (${4thPart.Equal[Class]}) {
						DEBUGBUFF Calling RegenOther with ${BuffSub} Endurance ${3rdPart} ${5thPart}"
						/call RegenOther "${BuffSub}" Endurance ${3rdPart} ${5thPart}
					} else {
						DEBUGBUFF Calling RegenOther with ${BuffSub} Endurance ${3rdPart} 0"
						/call RegenOther "${BuffSub}" Endurance ${3rdPart} 0
					}
				}
                /if (${2ndPart.Equal[Managroup]}) {
					/if (${4thPart.Equal[Class]}) {
						DEBUGBUFF Calling RegenOther with ${BuffSub} Mana ${3rdPart} ${5thPart}"
						/call RegenOther "${BuffSub}" Mana ${3rdPart} ${5thPart}
					} else {
						DEBUGBUFF Calling RegenOther with ${BuffSub} Mana ${3rdPart} ${4thPart}"
						/call RegenOther "${BuffSub}" Mana ${3rdPart} ${4thPart}
					}
				}
                /if (${Macro.Return.Equal[TRUE]}) {
					DEBUGBUFF Skipping ${BuffSub} because RegenOther returned true..."
					/goto :SkipBuff
				}
            } else /if (${2ndPart.Equal[mana]}) {
				DEBUGBUFF Skipping ${BuffSub} buff because mana tags are done in CastMana."
				/goto :SkipBuff
            }

            | Remove buff from |Remove tag
            /if (${2ndPart.Equal[Remove]} && ${Me.Buff[${BuffSub}].ID}) {
                /removebuff ${BuffSub}
				DEBUGBUFF Removed buff ${BuffSub}
                /goto :SkipBuff
            }

            | If buff cost more mana than I have skip it
            /if (${Spell[${Buffs[${i}]}].Mana} > ${Me.CurrentMana}) {
				/if (${bufftype.NotEqual[item]}) {
					DEBUGBUFF Skipping ${BuffSub} buff because we don't have enough Mana."
					/goto :SkipBuff
				}
			}
            | Check if aura is up
            /if (${2ndPart.Equal[Aura]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
				DEBUGBUFF Going to Check Aura ${SpellToCast}"
                /call CheckAura "${SpellToCast}"
				/goto :SkipBuff
            }
			/if (${2ndPart.Equal[Once]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
				| Check for |Once tag and turn buff off if cast is successful
				DEBUGBUFF Calling BuffOnce ${BuffSub}"
                /call BuffOnce "${BuffSub}" 
				DEBUGBUFF Return from BuffOnce is ${Macro.Return}. Going to :SkipBuff"
                /if (${Macro.Return.Equal[TRUE]}) {
                    /varset FullText ${FullText}|0
                    /echo Buffing Once with ${Buffs[${i}]}. 
                }
				/goto :SkipBuff
            }
			/if (${2ndPart.Equal[End]}) {
				| Check and Cast endurance discs/AAs - 2nd wind, respite, etc
				DEBUGBUFF It's an END. ${Me.PctEndurance} <= ${3rdPart}."
                /if (${Me.PctEndurance} <= ${3rdPart}) {
					DEBUGBUFF Endurance  Checking ${bufftype.Equal[ca]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})"
					DEBUGBUFF Endurance If above was false, then check: ${bufftype.Equal[aa]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})
					| Well, if we got here we know the ability is ready that was checked earlier so no need to do that again...
					/if (${bufftype.Equal[ca]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
						DEBUGBUFF (${Me.ActiveDisc.ID} && ${Spell[${BuffSub}].Duration} && !${Spell[${BuffSub}].StacksWithDiscs})"
						/if (${Me.ActiveDisc.ID} && ${Spell[${BuffSub}].Duration} && !${Spell[${BuffSub}].StacksWithDiscs}) {
							DEBUGBUFF Skipping ${BuffSub} buff because ${Me.ActiveDisc} is already active."
							/goto :SkipBuff
						}
						DEBUGBUFF Calling CheckEndurance "${BuffSub}" ${3rdPart} ${4thPart}"
						/call CheckEndurance "${BuffSub}" ${3rdPart} ${4thPart}
					} else /if (${bufftype.Equal[aa]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
						/call CheckEndurance "${BuffSub}" ${3rdPart} ${4thPart}
					}
				}
				DEBUGBUFF Skipping ${BuffSub} buff because internal condition was ${2ndPart}"
                /goto :SkipBuff
            }
			/if (${2ndPart.Equal[Summon]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
				DEBUGBUFF Summon item ${FindItemCount[=${3rdPart}]} < ${4thPart}"
				| Summon items ini example Buffs1=The Guardian's Pouch|Summon|Guardian Blade|200
                /if (${FindItemCount[=${3rdPart}]} < ${4thPart}) {
					/call SummonStuff "${SpellToCast}" "${3rdPart}" ${4thPart}
				}
                /goto :SkipBuff
            }
            /if (${Select[${2ndPart},Aura,End,Mount,Mana,Summon]}) {
				DEBUGBUFF Skipping ${BuffSub} buff because we already dealt with ${2ndPart} buffs."
				/goto :SkipBuff
			}

			| Ok from this point on we do some weird things and mess with the Buffs[${i}] array itself, I don't understand why yet.
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to buff part of spell
			|Lemons: This could be why these tags keep breaking...Why the fuck are ever messing with the array itself?!?!?! Gonna have to start reading the god damned ini to get real info...
            /if (${Select[${2ndPart},Dual,DualMA]}) {
				DEBUGBUFF 2ndPart is ${2ndPart} so im setting array ${Buffs[${i}]} to 3rdPart ${3rdPart}"
				/varset Buffs[${i}] ${3rdPart}
			} else /if (${Select[${2ndPart},Me,MA,!MA,!ME,Caster,Melee]}) {
				DEBUGBUFF 2ndPart is ${2ndPart} so im setting array ${Buffs[${i}]} to BuffSub ${BuffSub}"
				/varset Buffs[${i}] ${BuffSub}
			}
			
            | Cast buffs on MA && ${Spell[${Buffs[${i}]}].TargetType.Find[self]}
			|Lemons: Removed && ${Buff${i}GM7}==0 from the end to see if it causes spam. This timer doesn't pay attention to deaths. It probably exists to stop us from having to target around....give and take. 
            /if ((${2ndPart.Equal[MA]} || ${2ndPart.Equal[DualMA]}) && ${Spawn[=${MainAssist}].Distance} <= ${SpellRange} && ${Spawn[=${MainAssist}].ID} && (${Buff${i}GM7}==0 || !${Spawn[${MainAssist}].CachedBuff[${silverBuff}].ID})) {
				DEBUGBUFF [${Time}] Checking buff with MA tag ${Buffs[${i}]} 3rdpart ${3rdPart}"				
				| Check buffs in file to see if MA has buff or its blocked
                /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Blockedbuffs"].Find[${Buffs[${i}]}]}) {
					DEBUGBUFF Skipping ${BuffSub} because its blocked."
					/goto :SkipBuff
				}
				| Now some self blocked checks.
				| I dont want to use this file anymore we can just read cached buffs from now on...		
				/varset Buffs[${i}] ${BuffSub}
				
                /if (${Cursor.ID}) /call CheckCursor
				DEBUGBUFF Checking cachebuffs on ${MATargetID}"
				/call CacheBuffs ${MATargetID}
				/if (!${Spell[${silverBuff}].StacksSpawn[${MATargetID}]} && !${FindItem[${BuffSub}].Spell.StacksSpawn[${MATargetID}]}) {
					DEBUGBUFF Skipping ${BuffSub} because it DOES NOT stack on MA ${Spawn[${MATargetID}]}."
					/goto :SkipBuff
				}
				/if (${Spawn[${MATargetID}].CachedBuff[${silverBuff}].ID}) {
					/if (${Spawn[${MATargetID}].CachedBuff[${silverBuff}].Duration} > 1000) {
						DEBUGBUFF Skipping ${silverBuff} because MA ${Spawn[${MATargetID}]} already has it on."
						/goto :SkipBuff
					}
				} 
				/if (${Spawn[${MATargetID}].CachedBuff[${3rdPart}].ID}) {
					/if (${Spawn[${MATargetID}].CachedBuff[${3rdPart}].Duration} > 1000) {
						DEBUGBUFF Skipping ${Buffs[${i}]} because MA ${Spawn[${MATargetID}]} already has it on."
						/goto :SkipBuff
					}
				} 
				DEBUGBUFF Checking conditions on MA ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})"
				/if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
					DEBUGBUFF Casting >>> ${Buffs[${i}]} on MainAssist <<< Buffs-nomem"
					/call CastWhat "${Buffs[${i}]}" ${MATargetID} Buffs-nomem
					/if (${Macro.Return.Equal[CAST_SUCCESS]} || (!${Spawn[${MainAssistType} ${MainAssist} group].ID} && ${Macro.Return.Equal[CAST_TAKEHOLD]} )) {
						DEBUGBUFF ${Time}] Just buffed >> MainAssist << with ${Buffs[${i}]}."
						| For dual tag need to assign spell duration of the 3rd part 
						/if (${Select[${2ndPart},Dual,DualMA]}) {
							/varset Buffs[${i}] ${3rdPart}
						}
						/varcalc Buff${i}GM7 (${Spell[${Buffs[${i}]}].Duration.TotalSeconds}*${DurationMod})*10
						/varset WriteBuffsTimer 0
						/call WriteBuffs
						/goto :SkipCheckIni
					}
					/if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
						DEBUGBUFF Buff${i} You are missing components. Turning off ${Buffs[${i}]}."
						|/varset Buffs[${i}] NULL
						|/varset FullText NULL
						/goto :SkipBuff
					}
				}
            } 
            | Skip to next spell if Tag MA
            /if (${Select[${2ndPart},MA,DualMA]}) {
				DEBUGBUFF Skipping ${BuffSub} because we already checked ${2ndPart} for this buff."
				/goto :SkipBuff
			}
            | Check if buff is up and if it stacks with existing buffs. This is only for debug purposes?
			/if (${2ndPart.Find[Dual]}) {
				/if (!${Spell[${Buffs[${i}]}].Stacks}) {
					DEBUGBUFF DUAL: ${Buffs[${i}]} Does NOT Stack on ME"
				} else {
					DEBUGBUFF DUAL: ${Buffs[${i}]} DOES Stack on ME"
				}
			} else {
				DEBUGBUFF 2nd part isn't dual it's ${2ndPart}"
				/if (${bufftype.NotEqual[item]}) {
					/if (!${Spell[${BuffSub}].Stacks}) {
						/if (${Me.Buff[${BuffSub}].ID}) {
							DEBUGBUFF ${BuffSub} Does NOT Stack on ME because it's already on me."
						} else {
							DEBUGBUFF ${BuffSub} Does NOT Stack on ME."
						}
					} else {
						DEBUGBUFF ${BuffSub} DOES Stack on ME."
					}
				}
			}
			/if (${bufftype.NotEqual[item]}) {
				| Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to actual spell
				/if (${2ndPart.Find[Dual]}) {
					DEBUGBUFF Checking DUAL for ${Buffs[${i}]} should we be checking ${SpellToCast} instead?"
					/if (${Group} && (${Spell[${SpellToCast}].TargetType.Find[group v]} || ${BookSpellTT.Find[group v]})) {
						DEBUGBUFF Checking if ${SpellToCast} can be cast on the group it's a DUAL for ${Buffs[${i}]}"
						/call GroupBuff ${i} "${SpellToCast}" "${3rdPart}" "${2ndPart}" "${3rdPart}" "${5thPart}" "${SpellRange}" "${bDoMGB}"
						DEBUGBUFF Done checking group buffs. Setting ${Buffs[${i}]} back to ${FullText} and moving on to next buff."
						DEBUGBUFF ${Buffs[${i}]} is dual im setting it back to ${FullText}"
						/varset Buffs[${i}] ${FullText}
						/if (${Macro.Return} == 100 && !${BuffMode}) {
							DEBUGBUFF Returning because we have hostiles on xtarget."
							/varset Buffs[${i}] ${FullText}
							/return
						}
						/goto :SkipBuff
					} else /if (${Me.Buff[${Buffs[${i}]}].ID} || ${Me.Song[${Buffs[${i}]}].ID}) {
						DEBUGBUFF Skipping because ${Buffs[${i}]} which is a dual spell is already on ME, no need to buff it right now."
						DEBUGBUFF ${Buffs[${i}]} is dual im setting it back to ${FullText}"
						/varset Buffs[${i}] ${FullText}
						/goto :SkipBuff
					} else /if (!${Spell[${Buffs[${i}]}].Stacks} && (${2ndPart.Equal[Me]} || ${3rdPart.Equal[me]} || ${4thPart.Equal[Me]} || ${5thPart.Equal[Me]})) {
						DEBUGBUFF Skipping ${Buffs[${i}]} because it DOES NOT stack on me."
						DEBUGBUFF ${Buffs[${i}]} is dual im setting it back to ${FullText}"
						/varset Buffs[${i}] ${FullText}
						/goto :SkipBuff
					}
				}
				/if (${2ndPart.Equal[Me]}) {
					DEBUGBUFF Checking |Me for ${Buffs[${i}]} should we be checking ${SpellToCast} instead?"
					/if (${Me.Buff[${Buffs[${i}]}].ID} || ${Me.Song[${Buffs[${i}]}].ID} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
						DEBUGBUFF Skipping ${Buffs[${i}]} because it's already on ME, no need to buff it right now."
						/goto :SkipBuff
					}
					/if (${Target.ID}) /squelch /target clear
				}
				| If Target.Type=Group then buff self with group buff
				DEBUGBUFF We got to the group check for ${BuffSub} it's a ${Spell[${BuffSub}].TargetType} spell"
				/if (${Group} && (${Spell[${BuffSub}].TargetType.NotEqual[self]} && ${BookSpellTT.NotEqual[self]})) {
					DEBUGBUFF Checking if ${SpellToCast} can be cast on the group for ${Buffs[${i}]}"
					/call GroupBuff ${i} "${SpellToCast}" "${BuffSub}" "${2ndPart}" "${3rdPart}" "${5thPart}" "${SpellRange}" "${bDoMGB}"
					/if (${Macro.Return} == 100 && !${BuffMode}) {
						DEBUGBUFF returning because we have hostiles on xtarget."
						/varset Buffs[${i}] ${FullText}
						/return
					}
					DEBUGBUFF Done checking group for ${Buffs[${i}]}, moving on to OOG Buffs."
					/goto :SkipBuff
				} else {
					/if (${2ndPart.Equal[!ME]}) {
						DEBUGBUFF Skipping ${Buffs[${i}]} because it is tagged as !ME"
						/goto :SkipCheckIni
					}
					|This will cast the spell on the MA if they do not have the spell. Maybe one day we can rewrite to have it iterate through other groups etc.
					/if (${Spell[${BuffSub}].TargetType.NotEqual[self]}) {
						DEBUGBUFF It's not a self buff. (${Spawn[${MATargetID}].CachedBuff[${Buffs[${i}]}].ID} && ${Spawn[${MATargetID}].CachedBuff[${Buffs[${i}]}].Duration} > 1000 )"
						/if (${Spawn[${MATargetID}].CachedBuff[${Buffs[${i}]}].ID} && ${Spawn[${MATargetID}].CachedBuff[${Buffs[${i}]}].Duration} > 1000 ) {
							DEBUGBUFF Skipping ${Buffs[${i}]} because MA Already has ${BuffSub}. "
							/goto :SkipCheckIni
						} else {
							DEBUGBUFF (!${Defined[OOGTimerArray${MATargetID}]}) ${MATargetID} ${Buffs[${i}]}"
							/if (!${Defined[OOGTimerArray${MATargetID}]}) /call CacheBuffs ${MATargetID}
							DEBUGBUFF Checking stacking on MA (${Spell[${Buffs[${i}]}].StacksSpawn[${MATargetID}]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}))"
							/if (${Spell[${Buffs[${i}]}].StacksSpawn[${MATargetID}]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
								DEBUGBUFF [2] casting >>> ${BuffSub} <<< Buffs-nomem on ${Spawn[${MATargetID}]} because they are out of group MA assist and they need the buff"
								/call CastWhat "${BuffSub}" ${MATargetID} Buffs-nomem
							}
						}
					}
				}
				/if (${Me.Buff[${BuffSub}].ID} || ${Me.Song[${BuffSub}].ID}) {
					DEBUGBUFF Skipping ${Buffs[${i}]} because it's already on ME and the MA, no need to buff it right now."
					/goto :SkipBuff
				}
				/if (!${Spell[${BuffSub}].Stacks}) {
					DEBUGBUFF Skipping ${Buffs[${i}]} because it DOES NOT stack on me."
					/goto :SkipBuff
				}
				DEBUGBUFF ${BuffSub} is a Buff so lets go."
				/if (${Cursor.ID}) /call CheckCursor
				/if (${bDoMGB}) {
					:activatemgb
					/if (${Me.AltAbilityReady[Tranquill Blessing]}) {
						/echo Activating Tranquil Blessing
						DEBUGBUFF Trying to activate MGB"
						/alt act 992
						/delay 1
						/goto :activatemgb
					}
				}
				/if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
					DEBUGBUFF [2] casting >>> ${BuffSub} on me <<< Buffs-nomem"
					/call CastWhat "${BuffSub}" ${Me.ID} Buffs-nomem
					/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
						DEBUGBUFF Buffing >> ${BuffSub} on Me <<"
						/doevents flush Worn_off
						/varset WriteBuffsTimer 0
						/call WriteBuffs
						/goto :SkipBuff
					}
				}
			}
			| If Target.Type=Single then buff each party member with single buff
			DEBUGBUFF We got to the single check for ${BuffSub}"
			/if (${bufftype.NotEqual[item]}) {
				/if (${Spell[${BuffSub}].TargetType.Find[single]} || ${BookSpellTT.Find[single]} || (${FindItem[${BuffSub}].ID} && ${FindItem[${BuffSub}].Clicky.Spell.TargetType.Equal[single]})) {
					DEBUGBUFF Going to cast ${BuffSub} (a single buff) on the group."
					/if (${Buff${i}GM0}) /varset Buff${i}GM0 0
					/if (${2ndPart.Find[Dual]}) {
						/varset Buffs[${i}] ${SpellToCast}
						DEBUGBUFF Setting Buffs[${i}] to ${SpellToCast}"
					}
					DEBUGBUFF Checking ${Buffs[${i}]} for group should we be checking ${BuffSub} instead?"
					/if (${Group}) {
						/call GroupBuff ${i} "${SpellToCast}" "${BuffSub}" "${2ndPart}" "${3rdPart}" "${5thPart}" "${SpellRange}" "${bDoMGB}"
						/if (${Macro.Return} == 100 && !${BuffMode}) {
							|Return we have hostiles on xtarget
							/varset Buffs[${i}] ${FullText}
							DEBUGBUFF Returning cause we have hostiles and aren't in BuffMode ${i} ${SpellToCast}${BuffSub}${2ndPart}${3rdPart}${5thPart}${SpellRange} ${bDoMGB}"
							/return
						}
						DEBUGBUFF Moving on to next we already checked the full group for it including myself."
						/goto :SkipBuff
					} else {
						|not in a group, lets just cast it on myself then
						DEBUGBUFF OK it's single buff better check if it's restricted to a type SpellToCast = ${SpellToCast} 2ndPart = ${2ndPart} ${Buffs[${i}]}."
						/if (${Me.Buff[${SpellToCast}].ID} || ${Me.Song[${SpellToCast}].ID}) {
							DEBUGBUFF Skipping ${Buffs[${i}]} because it's already on ME, no need to buff it right now."
							/goto :SkipCheckIni
						}
						/if (${2ndPart.Equal[caster]} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) {
							DEBUGBUFF Skipping ${2ndPart} buff because ${Me} is not the correct class for ${Buffs[${i}]}."
							/goto :SkipBuff
						} else /if (${2ndPart.Equal[Melee]} && ${Select[${Me.Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0) {
							DEBUGBUFF Skipping ${2ndPart} buff because I am not the correct class for ${Buffs[${i}]}."
							/goto :SkipCheckIni
						} else /if (${2ndPart.Equal[MA]} && ${Me.Name.NotEqual[${MainAssist}]}) {
							DEBUGBUFF Skipping ${2ndPart} buff because I am not Ma for ${Buffs[${i}]}."
							/goto :SkipCheckIni
						}
						/if (${Cursor.ID}) /call CheckCursor
						/if (!${Spell[${SpellToCast}].Stacks}) {
							DEBUGBUFF ${SpellToCast} ${Buffs[${i}]} DOES NOT stack on ME, I will skip it."
							/goto :SkipCheckIni
						}
						/if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
							DEBUGBUFF Casting >>> ${Buffs[${i}]} <<< Buffs-nomem"
							/call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem
							/goto :SkipCheckIni
						}
					}
				}
			}

			DEBUGBUFF We are above self check"
			| If Target.Type=self then buff self
			/if (${bufftype.NotEqual[item]}) {
				DEBUGBUFF time to check self again for ${BuffSub}. its a ${Spell[${BuffSub}].TargetType} spell"
				/if (${Spell[${BuffSub}].TargetType.Find[target of target]} || ${Spell[${BuffSub}].TargetType.Find[self]} || ${BookSpellTT.Find[self]}) {
					DEBUGBUFF Checking ${BuffSub}, a ${Spell[${BuffSub}].TargetType} Buff"
					/if (${Me.Buff[${BuffSub}].ID} || ${Me.Song[${BuffSub}].ID}) {
						DEBUGBUFF Skipping ${Spell[${BuffSub}].TargetType} ${BuffSub} because it's already on ME, no need to buff it right now."
						/goto :SkipCheckIni
					}
					/if (!${Spell[${BuffSub}].Stacks}) {
						DEBUGBUFF ${BuffSub} DOES NOT stack on ME, I will skip it."
						/goto :SkipCheckIni
					}
					/if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
						DEBUGBUFF 4 casting >>> ${BuffSub} on me<<< Buffs-nomem"
						/call CastWhat "${BuffSub}" ${Me.ID} Buffs-nomem 
						/if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
							DEBUGBUFF Buff${i} You are missing components."
							/echo Buff${i} You are missing components.
							|/varset Buffs[${i}] NULL
							|/varset FullText NULL
							/goto :SkipCheckIni
						}
						/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
							DEBUGBUFF Just casted ${BuffSub} on myself."
						}
					}
				}
			}
			| Check if buff needs pet as target ie Mage's Symbiosis line of mana buffs
			|Lemons: Maybe we should check if it's tagged before checking pet....cause otherwise if we don't have a pet, then we're just gonna keep casting it......
			/if (${2ndPart.Equal[pet]} || ${Spell[${BuffSub}].TargetType.Find[pet]} || ${Select[${Spell[${Spell[${BuffSub}].ID}].Name.Arg[2,]},Symbiosis,Siphon,Simulacrum]}) {
				/if (${Me.Pet.ID}) {
					/if (${Pet.Buff[${Pet.Buff[${BuffSub}]}].ID}) {
						DEBUGBUFF Skipping Pet buff ${BuffSub} because it's already on my PET, no need to buff it right now."
						/goto :SkipCheckIni
					}
					/if (!${Spell[${BuffSub}].StacksPet}) {
						DEBUGBUFF ${BuffSub} ${Buffs[${i}]} DOES NOT stack on MY PET, I will skip it."
						/goto :SkipCheckIni
					}
					/if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
						/call CastWhat "${BuffSub}" ${Me.Pet.ID} Buffs
					}
				}
			}
			|Lemons: How is it possible to have random squiglies and the mac still works?
			|}
			| Items...
            | If buff is an item click it
			/if (${bufftype.Equal[item]}) {
				/if (${FindItem[=${BuffSub}].Spell.ID}) {
					DEBUGBUFF ${BuffSub} is an item"
					/if (${2ndPart.Find[dual]}) {
						DEBUGBUFF ${BuffSub} is a item with a DUAL spell: ${3rdPart}"
						/if ((${Me.Buff[${3rdPart}].ID} || ${Me.Song[${3rdPart}].ID}) && ${Spell[${3rdPart}].TargetType.Equal[self]}) {
							DEBUGBUFF Skipping because I already have ${3rdPart} on. Moving on to next buff."
							/goto :SkipBuff
						}
					}
					/if (${FindItem[=${BuffSub}].Spell.Stacks}) {
                        DEBUGBUFF ${FindItem[=${BuffSub}].Spell} stacks, moving on"
                        /if (${FindItem[=${BuffSub}].Spell.SpellType.NotEqual[Beneficial]} && ${FindItem[=${BuffSub}].Spell.SpellType.NotEqual[Beneficial(Group)]}) {
                            DEBUGBUFF Skipping because ${FindItem[=${BuffSub}].Spell} is NOT Beneficial. Moving on to next buff."
                            /goto :SkipCheckIni
                        }
						/if (!${Me.Buff[${FindItem[=${BuffSub}].Spell}].ID} && ${FindItem[=${BuffSub}].Timer}==0 && ${Select[${2ndPart},Aura,Mount,Mana]}<1) {
							/if (${FindItem[=${BuffSub}].Spell.IllusionOkWhenMounted}) {
								| Call of the wild ear fix
								/if (${SpellToCast.Equal[Call of the Wild]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
									/useitem 133851
									/call WaitCast "CheckBuffs" ${FindItem[133851].CastTime}
								} else /if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
									DEBUGBUFF going to cast item ${SpellToCast}"
									/call CastWhat "${BuffSub}" ${Me.ID} Buffs
								}
								/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
									DEBUGBUFF Clicked > ${BuffSub} <"
								} else {
									DEBUGBUFF Clicked > ${BuffSub} < FAILED"
								}
							} else {
								| Call of the wild ear fix
								/if (${SpellToCast.Equal[Call of the Wild]} && ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn})) {
									/useitem 133851
									/call WaitCast "CheckBuffs" ${FindItem[133851].CastTime}
								} else /if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
									DEBUGBUFF going to cast item ${SpellToCast}"
									/call CastWhat "${SpellToCast}" ${Me.ID} Buffs
								}
								/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
									DEBUGBUFF Clicked > ${SpellToCast} <"
								} else {
									DEBUGBUFF Clicked > ${SpellToCast} < FAILED"
								}
							}
						} else {
							DEBUGBUFF I already have ${FindItem[=${BuffSub}].Spell} on. Moving on to next buff."
							/goto :SkipBuff
						}
					} else {
						DEBUGBUFF ${SpellToCast} item DOES NOT stack on ME, I will skip it."
					}
				}
			}
            | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip ini check because none of these are cast on others
         :SkipBuff
			DEBUGBUFF In Skipbuff on ${BuffSub} ${SpellToCast}"
			| we need to get the heck outta here if we are under attack, don't hang around and do buffs you idiot...
            /if (${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]}) {
				DEBUGBUFF Going to skip cause ${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]}"
				/goto :SkipCheckIni
			}
			/if (${bufftype.Equal[item]}) {
				/if (${FindItemCount[=${Buffs[${i}]}]} >= 1 && ${Select[${Spell[${Buffs[${i}]}].TargetType},self]}) {
					DEBUGBUFF Going to skipcheck ${FindItemCount[=${Buffs[${i}]}]} >= 1 && ${Select[${Spell[${Buffs[${i}]}].TargetType},self]}"
					/goto :SkipCheckIni
				}
			}
			/if (${bufftype.NotEqual[item]}) {
				/if (${Spell[${Buffs[${i}]}].TargetType.Find[self]} || ${BookSpellTT.Find[self]} || ${BookSpellTT.Find[pet]}) {
					DEBUGBUFF Going to skipcheck ${Spell[${Buffs[${i}]}].TargetType.Find[self]} || ${BookSpellTT.Find[self]} || ${BookSpellTT.Find[pet]}"
					/goto :SkipCheckIni
				}
			}
            /if (${Redguides} && !${IniNextTimer} && !${CombatStart}) {
				/call CheckIniBuffs "${Buffs[${i}]}" ${i} ${SpellRange} "${SpellToCast}" "${2ndPart}" "${3rdPart}" "${4thPart}" "${BookSpellTT}"
			}
			
		:OOG
			|Lemons: For casting the Out of Group tag...hopefully. We are going to cast it here too to keep it simple(r)
			|A new tag has been added to buffs. Buff1=BuffName|Normal|Options|OOG:Name1,Name2,Name3		
			|Currently supports buffing 12 people unless I want to make a new ini entry or get creative. But it's late and I don't. 
			|It does now.
			DEBUGBUFF Checking if the buff has the OOG tag. ${FullText.Find[OOG:]} array size ${OOGArray.Size}"
			/if (${FullText.Find[OOG:]} && !${BuffsCOn}) {
				/for x 1 to ${OOGArray.Size}
					/if (${ChaseAssist} && !${BuffWhileChasing}) {
						DEBUGBUFF Chaseassist is now on and I'm not supposed to buff while chasing"
						/return
					}
					/if (${OOGArray[${x}].Equal[]} || ${OOGArray[${x}].Equal[NULL]} || ${OOGArray[${x}].Equal[ ]}) /continue
					/if (${MapTheZone}) /call ZoneMap FALSE Med
					|/echo LemonsDebug: OOGArray${x} is set to ${OOGArray[${x}]} who should already be a confirmed valid target. Depending how long it takes us to buff, they could leave/die, so we should recheck.
					DEBUGBUFF OOGArray${x} (((${Group.Member[${Spawn[${OOGArray[${x}]}].CleanName}].Index} && !${FullOOG.Arg[${x},,].Find[xtarget]}) || (${OOGArray[${x}].Equal[NULL]} || ${OOGArray[${x}].Equal[]} || ${OOGArray[${x}].Equal[ ]})) && ${FullOOG.Arg[${x},,].NotEqual[raid]} && ${FullOOG.Arg[${x},,].NotEqual[fellowship]} && !${FullOOG.Arg[${x},,].Find[range]})"
					/if (((${Group.Member[${Spawn[${OOGArray[${x}]}].CleanName}].Index} && !${FullOOG.Arg[${x},,].Find[xtarget]}) || (${OOGArray[${x}].Equal[NULL]} || ${OOGArray[${x}].Equal[]} || ${OOGArray[${x}].Equal[ ]})) && ${FullOOG.Arg[${x},,].NotEqual[raid]} && ${FullOOG.Arg[${x},,].NotEqual[fellowship]} && !${FullOOG.Arg[${x},,].Find[range]}) /continue
					DEBUGBUFF OOG Checking if we can cast it.${Spawn[${OOGArray[${x}]}].Type.Equal[PC]} || ${Spawn[${OOGArray[${x}]}].Type.Equal[Pet]}) && ${Spawn[${OOGArray[${x}]}].Distance} <= ${SpellRange} && ${Spawn[${OOGArray[${x}]}].CachedBuff[${BuffSub}].Duration} <= 180"
					/if ((${Spawn[${OOGArray[${x}]}].Type.Equal[PC]} || ${Spawn[${OOGArray[${x}]}].Type.Equal[Pet]}) && ${Spawn[${OOGArray[${x}]}].Distance} <= ${SpellRange} && (${Spawn[${OOGArray[${x}]}].CachedBuff[${3rdPart}].Duration} <= 180 && ${Spawn[${OOGArray[${x}]}].CachedBuff[${BuffSub}].Duration} <= 180) ) {
						DEBUGBUFF RaidFlag and #${x} is raid: (${RaidFlag} && ${Raid.Members} && ${OOGArray[${x}].Equal[raid]}) \agLine#:${Macro.CurLine}"
						/if (${RaidFlag} && ${OOGArray[${x}].Equal[raid]}) {
							DEBUGBUFF RaidFlag is on, gonna try and buff all raid members if I'm in a raid. I'll be gone awhile! \agLine#:${Macro.CurLine}"
							/if (${Raid.Members}) /call OOGBuff "${BuffSub}" Raid 0 "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" ${i}
							/goto :nextOOGNoCon
						}
						DEBUGBUFF FellowFlag and #${x} is Fellowship: (${FellowFlag} && ${Me.Fellowship.Members} && ${OOGArray[${x}].Equal[fellowship]}) \agLine#:${Macro.CurLine}"
						/if (${FellowFlag} && ${OOGArray[${x}].Equal[fellowship]}) {
							DEBUGBUFF FellowFlag is on, gonna try and buff all Fellowship members if we are in one.  \agLine#:${Macro.CurLine}"
							/if (${Me.Fellowship.Members}) /call OOGBuff "${BuffSub}" Fellowship 0 "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" ${i}
							/goto :nextOOGNoCon
						} 
						DEBUGBUFF RangeFlag for #${x} is ${RangeFlag} && ${Math.Calc[${SpawnCount[pc radius${RangeRange}]} + ${SpawnCount[pet radius${RangeRange}]}].Int} > 1 && ${OOGArray[${x}].Left[5].Equal[range]}) with RR ${RangeRange}, ${OOGArray[${x}]} Line:${Macro.CurLine}"
						/if (${RangeFlag} && ${OOGArray[${x}].Left[5].Equal[range]} && ${SpawnCount[pc radius ${RangeRange}]} > ${SpawnCount[group radius ${RangeRange}]} && ${BuffMode}) {
							DEBUGBUFF RangeFlag is on, gonna try and buff everything within ${RangeRange}ft which is ${SpawnCount[pc radius ${RangeRange}]} members \agLine#:${Macro.CurLine}"
							/call OOGBuff "${BuffSub}" range ${RangeRange} "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" ${i}
							/goto :nextOOGNoCon
						}
						DEBUGBUFF SkipFlag is ${SkipFlag}"
						/if (${SkipFlag}) /goto :nextOOGNoCon
						/if (!${Int[${OOGArray[${x}]}]}) {
							/goto :nextOOGNoCon
						}
						/tar id ${OOGArray[${x}]}
						/delay 1s ${Target.ID} == ${OOGArray[${x}]}
						/delay 2s ${Spawn[${OOGArray[${x}]}].CachedBuffCount} >= 0
						/if (${If[${BuffsCond[${i}]},0,1]}) {
							DEBUGBUFF We aren't meeting the Buff Conditions: (!${BuffsCond[${i}]}) for ${BuffSub} on ${Spawn[${OOGArray[${x}]}].CleanName} \agLine#:${Macro.CurLine}"
							/goto :nextOOGNoCon
						}							
						/if (${Spell[${BuffSub}].StacksSpawn[${OOGArray[${x}]}]} || ${FindItem[${BuffSub}].Clicky.Spell.StacksSpawn[${OOGArray[${x}]}]} || ${AltAbility[${BuffSub}].Spell.StacksSpawn[${OOGArray[${x}]}]}) {
							DEBUGBUFF Out of Group member ${OOGArray[${x}]} ${Spawn[${OOGArray[${x}]}]}  is about to get ${BuffSub}"
							/call CastWhat "${BuffSub}" ${OOGArray[${x}]} OOGBuffs-nomem
						} else {
							DEBUGBUFF OOG The buff ${BuffSub} does not stack on ${Spawn[${OOGArray[${x}]}].CleanName}"
						}
					}
				:nextOOGNoCon
					/varset SkipFlag FALSE
					/varset Buffee 0
					/call GetHostilesOnXTarget
					/if (${Macro.Return} > 0 && !${BuffMode}) {
						DEBUGBUFF Mobs on XTar, not gonna buff. Reseting ${Buffs[${i}]} to ${FullText}"
						/varset Buffs[${i}] ${FullText}
						/return
					}
					|/echo Current ${x} is ${OOGArray[${x}]}: ${OOGArray[${Math.Calc[${x}+1].Int}]}  (!${OOGArray[${Math.Calc[${x}+1].Int}].Length})
					/if (!${OOGArray[${Math.Calc[${x}+1].Int}].Length}) {
						DEBUGBUFF There isn't another entry for ${BuffSub}, ending OOG checks"
						/break
					}
					|2.5.6 edit to clear out the array
					/varset OOGArray[${x}]
				/next x
			} else /if (${FullText.Find[OOG:]} && ${BuffsCOn}) {
				DEBUGBUFF OOG There's an array and Buff Conditions are on"
				/for x 1 to ${OOGArray.Size}
					DEBUGBUFF OOG x is ${x} which is ${OOGArray[${x}]}"
					/if (${ChaseAssist} && !${BuffWhileChasing}) {
						DEBUGBUFF Chaseassist is now on and I'm not supposed to buff while chasing"
						/return
					}
					/if (${OOGArray[${x}].Equal[]} || ${OOGArray[${x}].Equal[NULL]} || ${OOGArray[${x}].Equal[ ]}) /continue
					/if (${MapTheZone}) /call ZoneMap FALSE Med
					|/echo LemonsDebug: OOG: STC: ${SpellToCast} 2:${2ndPart} 3: ${3rdPart} 4:${4thPart} 5:${5thPart} MGB: ${bDoMGB} FullText: ${Buffs[${i}]}.\agLine#:${Macro.CurLine}
					|/echo LemonsDebug: OOGArray${x} is set to ${OOGArray[${x}]} who should already be a confirmed valid target. Depending how long it takes us to buff, they could leave/die, so we should recheck2.\agLine#:${Macro.CurLine}
					DEBUGBUFF OOG Checking if OOGArray${x} ${Spawn[${OOGArray[${x}]}]} in group or not#${x} ((${Group.Member[${Spawn[${OOGArray[${x}]}].CleanName}].Index} && !${FullOOG.Arg[${x},,].Find[xtarget]}) || (${OOGArray[${x}].Equal[NULL]} || ${OOGArray[${x}].Equal[]} || ${OOGArray[${x}].Equal[ ]}) && ${FullOOG.Arg[${x},,].NotEqual[raid]} && ${FullOOG.Arg[${x},,].NotEqual[fellowship]} && !${FullOOG.Arg[${x},,].Find[range]})"
					/if (((${Group.Member[${Spawn[${OOGArray[${x}]}].CleanName}].Index} && !${FullOOG.Arg[${x},,].Find[xtarget]}) || (${OOGArray[${x}].Equal[NULL]} || ${OOGArray[${x}].Equal[]} || ${OOGArray[${x}].Equal[ ]})) && ${FullOOG.Arg[${x},,].NotEqual[raid]} && ${FullOOG.Arg[${x},,].NotEqual[fellowship]} && !${FullOOG.Arg[${x},,].Find[range]}) /continue
					DEBUGBUFF OOG Checking if we can cast it.((${Spawn[${OOGArray[${x}]}].Type.Equal[PC]} || ${Spawn[${OOGArray[${x}]}].Type.Equal[Pet]} || ${OOGArray[${x}].Equal[raid]} || ${OOGArray[${x}].Equal[fellowship]} || ${OOGArray[${x}].Equal[range]}) && ${Spawn[${OOGArray[${x}]}].Distance} <= ${SpellRange} && ((${Spawn[${OOGArray[${x}]}].CachedBuff[${3rdPart}].Duration} <= 180 && ${Spawn[${OOGArray[${x}]}].CachedBuff[${BuffSub}].Duration} <= 180) || (${OOGArray[${x}].Equal[raid]} || ${OOGArray[${x}].Equal[fellowship]} || ${OOGArray[${x}].Equal[range]})))"
					/if ((${Spawn[${OOGArray[${x}]}].Type.Equal[PC]} || ${Spawn[${OOGArray[${x}]}].Type.Equal[Pet]} || ${OOGArray[${x}].Equal[raid]} || ${OOGArray[${x}].Equal[fellowship]} || ${OOGArray[${x}].Equal[range]}) && ${Spawn[${OOGArray[${x}]}].Distance} <= ${SpellRange} && ((${Spawn[${OOGArray[${x}]}].CachedBuff[${3rdPart}].Duration} <= 180 && ${Spawn[${OOGArray[${x}]}].CachedBuff[${BuffSub}].Duration} <= 180) || (${OOGArray[${x}].Equal[raid]} || ${OOGArray[${x}].Equal[fellowship]} || ${OOGArray[${x}].Equal[range]}))) {
						|Lemons:Now need to check against all potential conditions class
						DEBUGBUFF Caster Check: (${2ndPart.Equal[caster]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0 && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]}))"
						/if (${2ndPart.Equal[caster]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0 && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]})) {
							DEBUGBUFF Skipping ${2ndPart} buff because ${Me} is not the correct class for ${Buffs[${i}]}. Will still check if ${Spawn[${OOGArray[${x}]}].Class.ShortName} is in -${3rdPart}-${4thPart}-${5thPart}"
							/if (${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${3rdPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${4thPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${5thPart}]}==0) /varset SkipFlag TRUE
						} 
						DEBUGBUFF Melee Check: (${2ndPart.Equal[Melee]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0 && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]}))"
						/if (${2ndPart.Equal[Melee]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0 && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]})) {
							DEBUGBUFF Skipping ${2ndPart} buff because ${x}OOG,${Spawn[${OOGArray[${x}]}]} is not the correct class for ${Buffs[${i}]}. Will still check if ${Spawn[${OOGArray[${x}]}].Class.ShortName} is in -${3rdPart}-${4thPart}-${5thPart}"
							/if (${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${3rdPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${4thPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${5thPart}]}==0) /varset SkipFlag TRUE
						} 
						DEBUGBUFF Class Check: ((${2ndPart.Equal[class]} || ${3rdPart.Equal[class]}) && (${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${3rdPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${4thPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${5thPart}]}==0) && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]}))"
						/if ((${2ndPart.Equal[class]} || ${3rdPart.Equal[class]}) && (${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${3rdPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${4thPart}]}==0 && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},${5thPart}]}==0) && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]})) {
							DEBUGBUFF Skipping ${SpellToCast} oogbuff because ${Spawn[${OOGArray[${x}]}]} is not the correct class for ${Buffs[${i}]} - ${Spawn[${OOGArray[${x}]}].Class.ShortName}-${3rdPart}-${4thPart}-${5thPart}. Still checking: (((${2ndPart.Equal[Melee]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0) || (${2ndPart.Equal[caster]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0)) && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]}))"
							/if (((${2ndPart.Equal[Melee]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0) || (${2ndPart.Equal[caster]} && ${Select[${Spawn[${OOGArray[${x}]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${2ndPart.NotEqual[caster]} && ${2ndPart.NotEqual[melee]})) && (${OOGArray[${x}].NotEqual[raid]} && ${OOGArray[${x}].NotEqual[fellowship]} && ${OOGArray[${x}].NotEqual[range]})) /varset SkipFlag TRUE
						}
						DEBUGBUFF RaidFlag and #${x} is raid: (${RaidFlag} && ${Raid.Members} && ${OOGArray[${x}].Equal[raid]}) \agLine#:${Macro.CurLine}"
						/if (${RaidFlag} && ${OOGArray[${x}].Equal[raid]}) {
							DEBUGBUFF RaidFlag is on, gonna try and buff all raid members if I'm in a raid. I'll be gone awhile! \agLine#:${Macro.CurLine}"
							/if (${Raid.Members}) /call OOGBuff "${BuffSub}" Raid 0 "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" ${i}
							/goto :nextOOG
						}
						DEBUGBUFF FellowFlag and #${x} is Fellowship: (${FellowFlag} && ${Me.Fellowship.Members} && ${OOGArray[${x}].Equal[fellowship]}) \agLine#:${Macro.CurLine}"
						/if (${FellowFlag} && ${OOGArray[${x}].Equal[fellowship]}) {
							DEBUGBUFF FellowFlag is on, gonna try and buff all Fellowship members if we are in one.  \agLine#:${Macro.CurLine}"
							/if (${Me.Fellowship.Members}) /call OOGBuff "${BuffSub}" Fellowship 0 "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" ${i}
							/goto :nextOOG
						} 
						|&& ${SpawnCount[pc radius ${RangeRange}]} > ${SpawnCount[group radius ${RangeRange}]} 
						DEBUGBUFF RangeFlag for #${x} is ${RangeFlag} with a range of ${RangeRange} && ${Math.Calc[${SpawnCount[pc radius ${RangeRange}]} + ${SpawnCount[pet radius ${RangeRange}]}].Int} > 1 && ${OOGArray[${x}].Left[5].Equal[range]}) with RR ${RangeRange}, ${OOGArray[${x}]} Line:${Macro.CurLine}"
						/if (${RangeFlag} && ${OOGArray[${x}].Left[5].Equal[range]} && ${BuffMode}) {
							DEBUGBUFF RangeFlag is on, gonna try and buff everything within ${RangeRange}ft which is ${SpawnCount[pc radius ${RangeRange}]} members \agLine#:${Macro.CurLine}"
							/call OOGBuff "${BuffSub}" range ${RangeRange} "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" ${i}
							/goto :nextOOG
						}
						DEBUGBUFF SkipFlag is ${SkipFlag}"
						/if (${SkipFlag}) /goto :nextOOG
						/if (!${Int[${OOGArray[${x}]}]}) {
							/goto :nextOOG
						}
						/tar id ${OOGArray[${x}]}
						/delay 1s ${Target.ID} == ${OOGArray[${x}]}
						/delay 2s ${Spawn[${OOGArray[${x}]}].CachedBuffCount} >= 0
						/if (${If[${BuffsCond[${i}]},0,1]}) {
							DEBUGBUFF We aren't meeting the Buff Conditions: (!${BuffsCond[${i}]}) for ${BuffSub} on ${Spawn[${OOGArray[${x}]}].CleanName} \agLine#:${Macro.CurLine}"
							/goto :nextOOG
						}							
						/if (${Spell[${BuffSub}].StacksSpawn[${OOGArray[${x}]}]} || ${FindItem[${BuffSub}].Clicky.Spell.StacksSpawn[${OOGArray[${x}]}]} || ${AltAbility[${BuffSub}].Spell.StacksSpawn[${OOGArray[${x}]}]}) {
							DEBUGBUFF Out of Group member ${OOGArray[${x}]} ${Spawn[${OOGArray[${x}]}]}  is about to get ${BuffSub}"
							/call CastWhat "${BuffSub}" ${OOGArray[${x}]} OOGBuffs-nomem
						} else {
							DEBUGBUFF OOG The buff ${BuffSub} does not stack on ${Spawn[${OOGArray[${x}]}].CleanName}"
						}
					}
				:nextOOG
					/varset SkipFlag FALSE
					/varset Buffee 0
					/call GetHostilesOnXTarget
					/if (${Macro.Return} > 0 && !${BuffMode}) {
						DEBUGBUFF Mobs on XTar, not gonna buff. Reseting ${Buffs[${i}]} to ${FullText}"
						/varset Buffs[${i}] ${FullText}
						/return
					}
					|/echo Current ${x} is ${OOGArray[${x}]}: ${OOGArray[${Math.Calc[${x}+1].Int}]}  (!${OOGArray[${Math.Calc[${x}+1].Int}].Length})
					/if (!${OOGArray[${Math.Calc[${x}+1].Int}].Length}) {
						DEBUGBUFF There isn't another entry for ${BuffSub}, ending OOG checks"
						/break
					}
					|2.5.6 edit to clear out the array
					/varset OOGArray[${x}]
				/next x
			}
         :SkipCheckIni
		 DEBUGBUFF Skipcheck for i${i} ${SpellToCast} ${BuffSub}"
          | Reset spell vars
            /if (${2ndPart.Length} && ${i} <= ${Buffs.Size}) {
				/varset Buffs[${i}] ${FullText}
                /varset FullText 0
            }
			|DEBUGBUFF Setting BookSpellTT to 0"
            /varset BookSpellTT 0
			DEBUGBUFF Going to Next i from ${i}"
        /next i
		
        /if (${PowerSource.NotEqual[NULL]} && !${Bool[${Me.Inventory[powersource].Name.Length}]} && ${FindItemCount[=${PowerSource}]}) {
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /autoinventory
        }
        /if (!${ReadBuffsTimer} && !${AggroTargetID}) /varset ReadBuffsTimer ${CheckBuffsTimer}s
        /if (${Macro.RunTime} > 120 && !${IniNextTimer}) /varset IniNextTimer 30s

        /if (${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscGem}]} && ${MiscGemRemem}) {
			DEBUGBUFF Calling MemSpell in CheckBuffs for ${ReMemMiscGem}"
			/call MemSpell "${ReMemMiscGem}" ${MiscGem}
		}
	DEBUGBUFF Returning from buffs"
    /return
	
| -------------------------------------------------------------------------------------
| SUB: OOGBuff. Called if we're trying to buff the entire raid, everyone in my range, or my fellowship
| -------------------------------------------------------------------------------------
Sub OOGBuff(string OOGBuffName, string BuffType, int BRange, 2nd, 3rd, 4th, 5th, int CI)
	DEBUGBUFF OOGBuffSub: N:${OOGBuffName} T:${BuffType} R:${BRange} 2:${2nd} 3:${3rd} 4:${4th} 5:${5th} #:${CI} |${Macro.CurLine}"
	/if ((!${Me.Book[${OOGBuffName}]} && !${FindItem[${OOGBuffName}].ID} && !${AltAbility[${OOGBuffName}].Rank} >0) || ${Me.Invis} || ${Me.Hovering}) /return
	/declare b int local 0
	/declare RF bool local FALSE
	/declare FF bool local FALSE
	/declare RRF bool local FALSE
	/declare SkipFlag string local FALSE
	/declare OOGRecastLine string local
	/declare TimeSinceLastCast int local
	/declare SpellToCast string local ${OOGBuffName}
	/declare TheBuffee int local
		/if (${BuffType.Equal[raid]}) {
			/varset RF TRUE
		} else /if (${BuffType.Equal[fellowship]}) {
			/varset FF TRUE
		} else /if (${BuffType.Equal[range]}) {
			/varset RRF TRUE
			/declare RangeArray[${SpawnCount[pc radius ${BRange}]}] string local NULL
			/for b 1 to ${RangeArray.Size}
				/if (${NearestSpawn[${b}, pc radius ${BRange}].ID}) /varset RangeArray[${b}] ${NearestSpawn[${b}, pc radius ${BRange}].ID}
				DEBUGBUFF RangeArray${b} is ${RangeArray[${b}]}"
			/next b
		}
	|Lemons: Gonna try to support AA's/items
	/if ((${FindItem[${OOGBuffName}].ID} || (${AltAbility[${OOGBuffName}].ID} && !${Me.Book[${OOGBuffName}]})) && ${2nd.Equal[DUAL]}) {
		/varset SpellToCast ${OOGBuffName}
		/if (${FindItem[${OOGBuffName}].ID}) {
			/varset OOGBuffName ${FindItem[${SpellToCast}].Clicky.Spell}
		} else {
			/varset OOGBuffName ${AltAbility[${SpellToCast}].Spell}
			}
		}
		DEBUGBUFF STCOOG is ${SpellToCast} OOGBuffName is ${OOGBuffName}"
		
		/if (${RF}) {
		DEBUGBUFF Raid Flag is on"
		/for b 0 to ${Raid.Members}
			/if (${Me.Hovering}) /return
			/if (${Me.Invis}) /return
			|Setting the Outer variable here so we can access it for Conditions. This should be the simplest, fastest way 
			/varset BuffeeLevel ${Raid.Member[${b}].Level}
			/varset Buffee ${Raid.Member[${b}].ID}
			/if (${SkipFlag}) /varset SkipFlag FALSE
			/if (${ChaseAssist} && !${BuffWhileChasing}) {
				DEBUGBUFF Chaseassist is now on and I'm not supposed to buff while chasing"
				/return
			}
			/if (!${Raid.Member[${b}].ID} || (${Raid.Member[${b}].Distance} >= ${Spell[${OOGBuffName}].Range} && ${Raid.Member[${b}].Distance} >= ${Spell[${OOGBuffName}].AERange})  || ${Group.Member[${Raid.Member[${b}]}].ID}) {
				DEBUGBUFF 1Skipping RaidMember${b} cause (!${Raid.Member[${b}].ID} || (${Raid.Member[${b}].Distance} >= ${Spell[${OOGBuffName}].Range} && ${Raid.Member[${b}].Distance} >= ${Spell[${OOGBuffName}].AERange})  || ${Group.Member[${Raid.Member[${b}]}].ID})\agLine#:${Macro.CurLine}"
				/continue
			} 
			/if (${BuffsCOn}) {	
				|Now I need to check the info sent in to see if they meet the conditions set
				/if (${2nd.Equal[caster]} && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) {
					DEBUGBUFF Skipping RaidMember${b} ${Raid.Member[${b}].Spawn.Class.ShortName} cause Caster ${2nd.Equal[caster]} && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0)\agLine#:${Macro.CurLine}"
					|Lemons: We don't match melee/caster, but want to make sure that we also don't match the specific class calls
					DEBUGBUFF Skipping RaidMember${b} if this is true: (${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${5th}]}==0)"
					/if (${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${5th}]}==0) /varset SkipFlag TRUE
				} 
				/if (${2nd.Equal[Melee]} && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0) {
					DEBUGBUFF Skipping RaidMember${b} cause Melee ${2nd.Equal[Melee]} && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0\agLine#:${Macro.CurLine}"
					|Lemons: We don't match melee/caster, but want to make sure that we also don't match the specific class calls
					/if (${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${Raid.Member[${b}]}].Class.ShortName},${5th}]}==0) /varset SkipFlag TRUE
				} 
				/if ((${2nd.Equal[class]} || ${3rd.Equal[class]}) && (${Select[${Raid.Member[${b}].Spawn.Class.ShortName},${3rd}]}==0 && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},${4th}]}==0 && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},${5th}]}==0)) {
					DEBUGBUFF Skipping RaidMember${b} cause Class ((${2nd.Equal[class]} || ${3rd.Equal[class]}) && (${Select[${Raid.Member[${b}].Spawn.Class.ShortName},${3rd}]}==0 && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},${4th}]}==0 && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},${5th}]}==0))\agLine#:${Macro.CurLine}"
					/if (((${2nd.Equal[Melee]} && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0) && (${2nd.Equal[caster]} && ${Select[${Raid.Member[${b}].Spawn.Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0)) || (!${2nd.Equal[caster]} && !${2nd.Equal[Melee]})) /varset SkipFlag TRUE
				} 
				/if (!${Spell[${OOGBuffName}].StacksSpawn[${Raid.Member[${b}].ID}]}) {
					DEBUGBUFF Skipping RaidMember${b} cause the buff doesn't stack\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
				}
				|Lemons: So now CachedBuff data isn't being shared between clients, so we basically have to target them to check buffs. Which sucks. 
				DEBUGBUFF Calling CacheBuffs on RaidMember${b} *${Raid.Member[${b}].CachedBuff[${OOGBuffName}].Duration} > 180* ${Target.Name} ${Raid.Member[${b}]}"
				/if (${Raid.Member[${b}].CachedBuff[${OOGBuffName}].Duration} > 180) {
					DEBUGBUFF Skipping RaidMember${b} cause the buff duration is over 180 -${Raid.Member[${b}].CachedBuff[${OOGBuffName}].Duration}-\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
				}
				/if (!${SkipFlag}) /call CacheBuffs ${Raid.Member[${b}].ID} OOG
				/if (${If[${BuffsCond[${CI}]},0,1]}) {
					DEBUGBUFF We aren't meeting the Buff Conditions: (!${BuffsCond[${CI}]}) for ${OOGBuffName} on ${Raid.Member[${b}]} \agLine#:${Macro.CurLine}"
					/goto :nextr
				}
				DEBUGBUFF SkipFlag on ${b} is ${SkipFlag} and StickChecked is ${StickChecked}"
				/if (${SkipFlag}) /goto :nextr
				/if (!${StickChecked}) {
					/call WillItStick "${OOGBuffName}" ${Raid.Member[${b}].ID}
					/if (${Macro.Return.Find[bad]}) {
						DEBUGBUFF ${OOGBuffName} wont stick on ${Spawn[${Raid.Member[${b}].ID}]}\agLine#:${Macro.CurLine}"
						/goto :nextr
					}
				}
				|/echo OOGRaid [${Time}] Calling Cast on ${Raid.Member[${b}]} with conditions\agLine#:${Macro.CurLine}
				DEBUGBUFF Calling cast of ${SpellToCast} on ${b} ${Raid.Member[${b}].ID}
				/call CastWhat "${SpellToCast}" ${Raid.Member[${b}].ID} OOGBuffs-nomem
			} else {
				DEBUGBUFF BuffCons are off. Everyone's getting buffed"
				|Just cast it on every member in the raid
				/if (!${StickChecked}) {
					/call WillItStick "${OOGBuffName}" ${Raid.Member[${b}].ID}
					/if (${Macro.Return.Find[bad]}) {
						/echo ${OOGBuffName} wont stick on ${Spawn[${Raid.Member[${b}].ID}]}\agLine#:${Macro.CurLine}
						/goto :nextr
					}
				}
				|/echo OOGRaid [${Time}] Calling Cast on ${Raid.Member[${b}]} without conditions\agLine#:${Macro.CurLine}
				/call CastWhat "${SpellToCast}" ${Raid.Member[${b}].ID} OOGBuffs-nomem
			}

			
		:nextr
		DEBUGBUFF Raid moving to next from ${b} ${Raid.Member[${b}].Spawn.Class}"
			/varset StickChecked 0
			/call GetHostilesOnXTarget
			/if (${Macro.Return} > 0 && !${BuffMode}) {
				DEBUGBUFF Mobs on XTar, not gonna buff"
				/return
			}
		/next b
	}

	/if (${FF}) {
		/for b 1 to ${Me.Fellowship.Members}
			/if (${ChaseAssist} && !${BuffWhileChasing}) {
				DEBUGBUFF Chaseassist is now on and I'm not supposed to buff while chasing"
				/return
			}
			/if (${Me.Hovering}) /return
			/if (${Me.Invis}) /return
			/if (${SkipFlag}) /varset SkipFlag FALSE
			/varset BuffeeLevel ${Me.Fellowship.Member[${b}].Level}
			/varset Buffee ${Spawn[${Me.Fellowship.Member[${b}]}].ID}
			/if (!${Spawn[pc ${Me.Fellowship.Member[${b}]}].ID} || ${Spawn[pc ${Me.Fellowship.Member[${b}]}].Distance} >= ${Spell[${OOGBuffName}].Range} || ${Group.Member[${Me.Fellowship.Member[${b}]}].ID}) {
				DEBUGBUFF Skipping FellowshipMember${b} cause !${Spawn[pc ${Me.Fellowship.Member[${b}]}].ID} || ${Spawn[pc ${Me.Fellowship.Member[${b}]}].Distance} >= ${Spell[${OOGBuffName}].Range} || ${Group.Member[${Me.Fellowship.Member[${b}]}].ID}\agLine#:${Macro.CurLine}"
				/continue
			} 
			/if (${BuffsCOn}) {
				|Now I need to check the info sent in to see if they meet the conditions set
				/if (${2nd.Equal[caster]} && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) {
					DEBUGBUFF Skipping FellowshipMember${b} cause ${2nd.Equal[caster]} && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0)\agLine#:${Macro.CurLine}"
					|Lemons: We don't match melee/caster, but want to make sure that we also don't match the specific class calls
					/if (${Select[${Spawn[${Me.Fellowship.Member[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${Me.Fellowship.Member[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${Me.Fellowship.Member[${b}]}].Class.ShortName},${5th}]}==0) /varset SkipFlag TRUE
				} 
				/if (${2nd.Equal[Melee]} && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0) {
					DEBUGBUFF Skipping FellowshipMember${b} cause ${2nd.Equal[Melee]} && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0\agLine#:${Macro.CurLine}"
					|Lemons: We don't match melee/caster, but want to make sure that we also don't match the specific class calls
					/if (${Select[${Spawn[${Me.Fellowship.Member[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${Me.Fellowship.Member[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${Me.Fellowship.Member[${b}]}].Class.ShortName},${5th}]}==0) /varset SkipFlag TRUE
				} 
				/if ((${2nd.Equal[class]} || ${3rd.Equal[class]}) && (${Select[${Me.Fellowship.Member[${b}].Class.ShortName},${3rd}]}==0 && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},${4th}]}==0 && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},${5th}]}==0)) {
					DEBUGBUFF Skipping FellowshipMember${b} cause ((${2nd.Equal[class]} || ${3rd.Equal[class]}) && (${Select[${Me.Fellowship.Member[${b}].Class.ShortName},${3rd}]}==0 && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},${4th}]}==0 && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},${5th}]}==0))\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
					/if ((${2nd.Equal[Melee]} && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}>=1) || (${2nd.Equal[caster]} && ${Select[${Me.Fellowship.Member[${b}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}>=1)) /varset SkipFlag FALSE
				} 
				/if (!${Spell[${OOGBuffName}].StacksSpawn[${Me.Fellowship.Member[${b}]}]}) {
					DEBUGBUFF Skipping FellowshipMember${b} cause the buff doesn't stack\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
				} 
				/if (${Spawn[pc ${Me.Fellowship.Member[${b}]}].CachedBuff[${OOGBuffName}].Duration} > 180) {
					DEBUGBUFF Skipping FellowshipMember${b} cause the buff duration is over 180 -(${Spawn[pc ${Me.Fellowship.Member[${b}]}].CachedBuff[${OOGBuffName}].Duration} > 180)-\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
				}
				/if (!${SkipFlag}) /call CacheBuffs ${Me.Fellowship.Member[${b}]} OOG
				/if (${If[${BuffsCond[${CI}]},0,1]}) {
					DEBUGBUFF We aren't meeting the Buff Conditions: (!${BuffsCond[${CI}]}) for ${OOGBuffName} on ${Me.Fellowship.Member[${b}]} \agLine#:${Macro.CurLine}"
					/goto :nextf
				}
				/if (${SkipFlag}) /goto :nextf
				/if (!${StickChecked}) {
					/call WillItStick "${OOGBuffName}" ${Spawn[pc ${Me.Fellowship.Member[${b}]}].ID}
					/if (${Macro.Return.Find[bad]}) {
						/echo ${OOGBuffName} wont stick on ${Spawn[pc ${Me.Fellowship.Member[${b}]}]}\agLine#:${Macro.CurLine}
						/goto :nextf
					}
				}				
				|/echo OOGFellow [${Time}] Calling Cast on ${b} ${Me.Fellowship.Member[${b}]} with conditions\agLine#:${Macro.CurLine}
				/call CastWhat "${SpellToCast}" ${Spawn[pc ${Me.Fellowship.Member[${b}]}].ID} OOGBuffs-nomem
			} else {
				|Just cast it on every member in the Fellowship
				/if (!${StickChecked}) {
					/call WillItStick "${OOGBuffName}" ${Spawn[pc ${Me.Fellowship.Member[${b}]}].ID}
					/if (${Macro.Return.Find[bad]}) {
						/echo ${OOGBuffName} wont stick on ${Spawn[pc ${Me.Fellowship.Member[${b}]}]}\agLine#:${Macro.CurLine}
						/goto :nextf
					}
				}
				|/echo OOGFellow [${Time}] Fellowship on ${Me.Fellowship.Member[${b}]} without conditions\agLine#:${Macro.CurLine}
				/call CastWhat "${SpellToCast}" ${Spawn[pc ${Me.Fellowship.Member[${b}]}].ID} OOGBuffs-nomem
			}
		:nextf
			/varset StickChecked 0
			/call GetHostilesOnXTarget
			/if (${Macro.Return} > 0 && !${BuffMode}) {
				DEBUGBUFF Mobs on XTar, not gonna buff"
				/return
			}
		/next b
	}

	/if (${RRF} && (${BuffMode} || ${SpawnCount[pc radius ${BRange}]} <= 12)) {
		/for b 2 to ${SpawnCount[pc radius ${BRange}]}
			/if (${Me.Invis}) /return
			/if (${SkipFlag}) /varset SkipFlag FALSE
			/if (${ChaseAssist} && !${BuffWhileChasing}) {
				DEBUGBUFF Chaseassist is now on and I'm not supposed to buff while chasing"
				/return
			}
			/if (${Me.Hovering}) /return
			/varset BuffeeLevel ${Spawn[${RangeArray[${b}]}].Level}	
			/varset Buffee ${Spawn[${RangeArray[${b}]}].ID}
			/if (!${RangeArray[${b}]} || ${Spawn[${RangeArray[${b}]}].Distance} >= ${Spell[${OOGBuffName}].Range} || ${Group.Member[${RangeArray[${b}]}].ID}) {
				DEBUGBUFF Skipping ${OOGBuffName} on  RangeArray${b} cause (!${RangeArray[${b}]} || ${Spawn[${RangeArray[${b}]}].Distance} >= ${Spell[${OOGBuffName}].Range} || ${Group.Member[${RangeArray[${b}]}].ID})\agLine#:${Macro.CurLine}"
				/continue
			} 
			|/echo BuffsCond RangeFlag: (!${BuffsCond[${CI}]} && ${BuffsCOn})  on #${b}
			/if (${BuffsCOn}) {
				|Now I need to check the info sent in to see if they meet the conditions set
				/if (${2nd.Equal[caster]} && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) {
					DEBUGBUFF Skipping ${OOGBuffName} on  RangeArray${b} cause Caster ${2nd.Equal[caster]} && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0)\agLine#:${Macro.CurLine}"
					|Lemons: We don't match melee/caster, but want to make sure that we also don't match the specific class calls
					/if (${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${5th}]}==0) /varset SkipFlag TRUE
				} 
				/if (${2nd.Equal[Melee]} && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0) {
					DEBUGBUFF Skipping ${OOGBuffName} on  RangeArray${b} cause Melee ${2nd.Equal[Melee]} && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0\agLine#:${Macro.CurLine}"
					|Lemons: We don't match melee/caster, but want to make sure that we also don't match the specific class calls
					/if (${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${5th}]}==0) /varset SkipFlag TRUE
				} 
				/if ((${2nd.Equal[class]} || ${3rd.Equal[class]}) && (${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${5th}]}==0)) {
					DEBUGBUFF Skipping ${OOGBuffName} on  RangeArray${b} cause no class((${2nd.Equal[class]} || ${3rd.Equal[class]}) && (${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${3rd}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${4th}]}==0 && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},${5th}]}==0))\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
					/if ((${2nd.Equal[Melee]} && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}>=1) || (${2nd.Equal[caster]} && ${Select[${Spawn[${RangeArray[${b}]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}>=1)) /varset SkipFlag FALSE
				} 
				/if (!${Spell[${OOGBuffName}].StacksSpawn[${RangeArray[${b}]}]}) {
					DEBUGBUFF Skipping ${OOGBuffName} on RangeArray${b} ${RangeArray[${b}]} cause the buff doesn't stack\agLine#:${Macro.CurLine}"
					/if (!${SkipFlag}) {
						/if (${Select[${Zone.ShortName},poknowledge,guildlobby,guildhall]}) {
							DEBUGBUFF But wait, we're in a hub zone and shit is broken"
							|/echo Keeping FALSE skipflag on ${Spawn[${RangeArray[${b}]}]} cause StacksSpawn is broken in hub zones
						} else {
							|Need to skip cause we aren't in a hub zone where Stacks is broken
							/varset SkipFlag TRUE
						}
					} else {
						|Lemons: Already skipping anyways due to some other condition. 
					}
				} 
				/if (!${SkipFlag}) /call CacheBuffs ${RangeArray[${b}]} OOG
				/if (${Spawn[${RangeArray[${b}]}].CachedBuff[${OOGBuffName}].Duration} > 180) {
					DEBUGBUFF Skipping ${OOGBuffName} on  RangeArray${b} cause the buff duration is over 180 -(${Spawn[${RangeArray[${b}]}].CachedBuff[${OOGBuffName}].Duration} > 180)-\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
				}
				|/echo WillLand on ${Target} (!${Spell[${OOGBuffName}].WillLand})
				/if (!${Spell[${OOGBuffName}].StacksTarget}) {
					DEBUGBUFF Skipping ${OOGBuffName} on  RangeArray${b} cause the buff doesn't stack again WillLand\agLine#:${Macro.CurLine}"
					/varset SkipFlag TRUE
				}
				/if (${If[${BuffsCond[${CI}]},0,1]}) {
					DEBUGBUFF We aren't meeting the Buff Conditions: (!${BuffsCond[${CI}]}) for ${OOGBuffName} on ${Spawn[${RangeArray[${b}]}]} \agLine#:${Macro.CurLine}"
					/goto :nextrg
				}
				DEBUGBUFF Skipflag is ${SkipFlag} on ${Spawn[${RangeArray[${b}]}].CleanName}"
				/if (${SkipFlag}) /goto :nextrg	
				/if (!${StickChecked}) {
					/call WillItStick "${OOGBuffName}" ${RangeArray[${b}]}]
					/if (${Macro.Return.Find[bad]}) {
						DEBUGBUFF ${OOGBuffName} wont stick on ${Spawn[${RangeArray[${b}]}]}\agLine#:${Macro.CurLine}"
						/goto :nextrg
					}
				}
				|Lemons: Gonna try to manage people with max buffs or blocked buffs....It's never going to be perfect. 
				|Same spawnid
				DEBUGBUFF \ayRangeOOGDupes #${b} Checking if their current spawnid ${RangeArray[${b}]} is the same as their spawnid from the last time I cast ${OOGBuffName} on ${Spawn[${RangeArray[${b}]}].CleanName}. ${Ini["MuleAssistOOGBuffs.ini","${OOGBuffName}","${Spawn[${RangeArray[${b}]}].CleanName}"].Arg[1,|].Equal[${RangeArray[${b}]}]}\agLine#:${Macro.CurLine}"
				/if (${Ini["MuleAssistOOGBuffs.ini","${OOGBuffName}","${Spawn[${RangeArray[${b}]}].CleanName}"].Arg[1,|].Equal[${RangeArray[${b}]}]}) {
					|Lemons: so we don't have to read it over and over from the file. 
					/varset OOGRecastLine ${Ini["MuleAssistOOGBuffs.ini","${OOGBuffName}","${Spawn[${RangeArray[${b}]}].CleanName}"]}
					/varset TimeSinceLastCast ${Math.Calc[${Time.SecondsSinceMidnight} - ${OOGRecastLine.Arg[2,|]}]}
					|Check last time we cast it vs duration of spell
					DEBUGBUFF  Duration of spell vs last time we cast it FullLine: ${OOGRecastLine} TimeSinceLastCast: ${TimeSinceLastCast}"
					DEBUGBUFF  (${Spell[${OOGBuffName}].MyDuration.TotalSeconds} > ${TimeSinceLastCast} || ${AltAbility[${OOGBuffName}].Spell.Duration.TotalSeconds} > ${TimeSinceLastCast} || ${FindItem[${OOGBuffName}].Clicky.Spell.Duration} > ${TimeSinceLastCast})"
					/if (${Spell[${OOGBuffName}].MyDuration.TotalSeconds} > ${TimeSinceLastCast} || ${AltAbility[${OOGBuffName}].Spell.Duration.TotalSeconds} > ${TimeSinceLastCast} || ${FindItem[${OOGBuffName}].Clicky.Spell.Duration} > ${TimeSinceLastCast}) {
						DEBUGBUFF  We already cast ${OOGBuffName} on ${Spawn[${RangeArray[${b}]}].CleanName} and the spell timer isn't up yet. ${Spell[${OOGBuffName}].MyDuration.TotalSeconds} > ${TimeSinceLastCast} && ${AltAbility[${OOGBuffName}].Spell.Duration.TotalSeconds} > ${TimeSinceLastCast} && ${FindItem[${OOGBuffName}].Clicky.Spell.Duration} > ${TimeSinceLastCast}\agLine#:${Macro.CurLine}"
						/goto :nextrg
						}
					DEBUGBUFF  We have cast ${OOGBuffName} on ${Spawn[${RangeArray[${b}]}].CleanName} before, but the duration of the buff is up. Now check if we're in Pok etc\agLine#:${Macro.CurLine}"
					/if (${Select[${Zone.ShortName},poknowledge,nexus,guildlobby,bazaar,guildhall]}) {
						DEBUGBUFF  We are in a zone that doesn't drop buffs. Not going to rebuff ${Spawn[${RangeArray[${b}]}].CleanName} since they still have the same spawnID as they had before. \agLine#:${Macro.CurLine}"
						/goto :nextrg
					}
				}
				/echo Gonna cast "${SpellToCast}" ${RangeArray[${b}]} OOGBuffs-nomem
				DEBUGBUFF It should be OK to buff ${Spawn[${RangeArray[${b}]}].CleanName} with ${OOGBuffName}.\agLine#:${Macro.CurLine}"
				/call CastWhat "${SpellToCast}" ${RangeArray[${b}]} OOGBuffs-nomem
				|Lemons: Need to try and figure out a way to not spam a buff on a rando who has it blocked. Really not sure how I want to do this yet.
				|		Ini						BuffHeader			CleanName								SpawnID|TimeCast|#of casts| 
				|/echo CastWhat "${SpellToCast}" ${RangeArray[${b}]} OOGBuffs-nomem
				/echo Writing MuleAssistOOGBuffs ${OOGBuffName}" "${Spawn[${RangeArray[${b}]}].CleanName}" "${RangeArray[${b}]}|${Time.SecondsSinceMidnight}|${Math.Calc[${Ini["MuleAssistOOGBuffs.ini","${OOGBuffName}","${Spawn[${RangeArray[${b}]}].CleanName}"].Arg[3,|]}+1]}
				/ini "MuleAssistOOGBuffs.ini" "${OOGBuffName}" "${Spawn[${RangeArray[${b}]}].CleanName}" "${RangeArray[${b}]}|${Time.SecondsSinceMidnight}|${Math.Calc[${Ini["MuleAssistOOGBuffs.ini","${OOGBuffName}","${Spawn[${RangeArray[${b}]}].CleanName}"].Arg[3,|]}+1]}"
				|/mqp
			} else {
				|Just cast it on every person within ${BRange}ft
				/if (!${StickChecked}) {
					/call WillItStick "${OOGBuffName}" ${RangeArray[${b}]}]
					/if (${Macro.Return.Find[bad]}) {
						/echo ${OOGBuffName} wont stick on ${Spawn[${RangeArray[${b}]}]}\agLine#:${Macro.CurLine}
						/goto :nextrg
					}
				}				
				|/echo OOGRange [${Time}] Buff on ${Spawn[${RangeArray[${b}]}]} without conditions\agLine#:${Macro.CurLine}
				/call CastWhat "${SpellToCast}" ${RangeArray[${b}]} OOGBuffs-nomem
			}
		:nextrg
			/varset StickChecked 0
			/call GetHostilesOnXTarget
			/if (${Macro.Return} > 0 && !${BuffMode}) {
				DEBUGBUFF Mobs on XTar, not gonna buff"
				/return
			}
		/next b
	}
	:doneskies
/return
| -------------------------------------------------------------------------------------
| SUB: BuffOnce 
| -------------------------------------------------------------------------------------
    Sub BuffOnce(Oncepell)
        /if (${Me.Invis}) /return
		/if (${Me.Hovering}) /return
        /declare OnceResult string local FALSE
		/if (!${Spell[${Oncepell}].Stacks}) {
			/echo ${Oncepell} DOES NOT stack on ME, I will skip it. \agLine#:${Macro.CurLine}
			/varset OnceResult TRUE
			/return ${OnceResult}
		}
        /call CastWhat "${Oncepell}" ${Me.ID} CheckEndurance
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset OnceResult TRUE
        }
    /return ${OnceResult}
| -------------------------------------------------------------------------------------
| SUB: CheckAura | Check if aura is up
| -------------------------------------------------------------------------------------
    Sub CheckAura(AuraSpell)
        /if (${Me.Invis}) /return
		/if (${Me.Hovering}) /return
        /declare AuraName string local
        /declare TempAura string local
        /declare AuraResult string local FALSE
        | Strip the Rk II/III out of the spell to check against aura window
		DEBUGBUFF  Checking ${AuraSpell}."
        /if (${AuraSpell.Find[ Rk. III]}) {
            /varset AuraName ${AuraSpell.Left[-8]}
        } else /if (${AuraSpell.Find[ Rk. II]}) {
            /varset AuraName ${AuraSpell.Left[-7]}
        } else /if (${AuraSpell.Find[ Rk.II]}) {
            /varset AuraName ${AuraSpell.Left[-6]}
        } else {
            /varset AuraName ${AuraSpell}
        }
        | Correct typo from SOE in monks 55 level aura
        /if (${AuraSpell.Find[Disciple's Aura]}) /varset AuraName Disciples Aura
        | Cleric exception for Reverent Aura 
        /if (${Me.Class.Name.Equal[cleric]} && ${AuraSpell.Find[Reverent]}) {
			/varset AuraName Reverent Aura
			DEBUGBUFF  Setting AuraName to Reverent Aura"
		}
        | Enchanter exception for Mana Recursion Auras
        /if ( ${AuraSpell.Find[Mana Reverberation]} || ${AuraSpell.Find[Mana Repercussion]} || ${AuraSpell.Find[Mana Reiteration]}) {
			/varset AuraName Mana Recursion Aura
		}
        | Enchanter exception for Mana Reverberation Aura lv 100
        /if (${AuraSpell.Find[Mana Reiterate]}) /varset AuraName Mana Reiterate Aura
        /if (${AuraSpell.Find[Mana Reverberation]}) /varset AuraName Mana Rev.
        /if (${AuraSpell.Find[Mana Resurgence]}) /varset AuraName Mana Resurgence Aura
        /if (${AuraSpell.Find[Mana Repercussion Aura]}) /varset AuraName Mana Rep. Aura
        /if (${AuraSpell.Find[Runic Radiance Aura]}) /varset AuraName Runic Rad. Aura
        | Mage exceptions because aura is on pet not in aura window and other fucked up shit
        /if (${AuraSpell.Find[Arcane Distillect]}) /varset TempAura Arcane Distillect
        /if (${AuraSpell.Find[Earthen Strength]}) /varset TempAura Earthen Strength Effect
        /if (${AuraSpell.Find[Rathe's Strength]}) /varset TempAura Rathe's Strength Effect
		DEBUGBUFF  CheckAura AuraName is ${AuraName}"
        | Check if aura is up 4 parts - Mage | Everyone else | 2 auras cleric | 2 auras enchamter
        /if (${Select[${Me.Class.ShortName},CLR,ENC,MAG]}==0 && !${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]}) {
			DEBUGBUFF Jumping down to FoundAura for ${AuraSpell}."
			DEBUGBUFF  CheckAura Jumping down to FoundAura for ${AuraSpell}.${Select[${Me.Class.ShortName},CLR,ENC,MAG]}==0 && !${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]}"
            /goto :FoundAura
        } else /if (${Me.Class.ShortName.Equal[MAG]} && ${Me.Pet.ID} &&  ${Me.Pet.Distance}<175 && !${TempAura.Find[effect]} && !${Me.Aura[1].Name.Find[${TempAura}]}) {
            DEBUGBUFF Jumping down to FoundAura for ${AuraSpell}. ${Me.Class.ShortName.Equal[MAG]} && ${Me.Pet.ID} &&  ${Me.Pet.Distance}<175 && !${TempAura.Find[effect]} && !${Me.Aura[1].Name.Find[${TempAura}]}"
			DEBUGBUFF  CheckAura Jumping down to FoundAura for ${AuraSpell}."
			/goto :FoundAura
        } else /if (${Me.Class.ShortName.Equal[CLR]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.AltAbility[Spirit Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[',]}]} && ${Me.AltAbility[Spirit Mastery]}))) {
            DEBUGBUFF Jumping down to FoundAura for ${AuraSpell}."
			DEBUGBUFF  CheckAura Jumping down to FoundAura for ${AuraSpell}. (${Me.Class.ShortName.Equal[CLR]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.AltAbility[Spirit Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[',]}]} && ${Me.AltAbility[Spirit Mastery]})))"
			/goto :FoundAura
        } else /if (${Me.Class.ShortName.Equal[ENC]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.AltAbility[Auroria Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[',]}]} && ${Me.AltAbility[Auroria Mastery]}))) {
            DEBUGBUFF Jumping down to FoundAura for ${AuraSpell}."
			DEBUGBUFF  CheckAura Jumping down to FoundAura for ${AuraSpell}. (${Me.Class.ShortName.Equal[ENC]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.AltAbility[Auroria Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[1].Name.Find[${AuraName.Replace[',]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[`,]}]} && !${Me.Aura[2].Name.Find[${AuraName.Replace[',]}]} && ${Me.AltAbility[Auroria Mastery]})))"
			/goto :FoundAura
        } else {
			DEBUGBUFF Skipping ${AuraSpell} because it's already on me."
			DEBUGBUFF  CheckAura Aura already one me"
			/return ${AuraResult}
		}
        :FoundAura
        | - Mutant Bards do this
        /if (${Me.Class.ShortName.Equal[BRD]}) {
			/if (${Me.Book[${AuraSpell}]}) {
				/stopcast
				/stoptwist
				/delay 5s ${Me.BardSongPlaying}==FALSE
				DEBUGBUFF [${Time}] Stopped twist"
				/if (!${Me.Gem[${AuraSpell}]}) {
					/if (${Cursor.ID}) /call CheckCursor
                    DEBUGBUFF [${Time}] Calling MemSpell for ${AuraSpell}"
					/call MemSpell "${AuraSpell}" ${MiscGem}
                    /delay 15s ${Me.GemTimer[${MiscGem}]}==0
					DEBUGBUFF [${Time}] Ok ${AuraSpell} is memmed in ${MiscGem}"
					/delay 1s
                }
				DEBUGBUFF [${Time}] Going to cast ${AuraSpell} from Gem: ${Me.Gem[${AuraSpell}]}"
				/cast "${AuraSpell}"
				/call WaitCast "CheckAura" ${Spell[${AuraSpell}].MyCastTime}
				DEBUGBUFF [${Time}] Casted ${AuraSpell} My CastTime: ${Spell[${AuraSpell}].MyCastTime}"
				/varset AuraResult TRUE
				/delay 5s ${Me.Aura.ID} && !${Me.Casting.ID}
				/return ${AuraResult}
			}
		}
		| - Normal casting
		/if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]} && ${Me.CurrentEndurance} > 500) {
			DEBUGBUFF  Casting Aura Disc ${AuraSpell}"
            /call CastDisc "${AuraSpell}" 0
            /varset AuraResult TRUE
            /return ${AuraResult}
        } else {
			DEBUGBUFF [${Time}] Going to cast ${AuraSpell}"
            /call CastWhat "${AuraSpell}" ${Me.ID} CheckAura
        }
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            DEBUGBUFF Casted Aura >> ${AuraSpell} <<"
            /varset AuraResult TRUE
        }
    /return ${AuraResult}
| -------------------------------------------------------------------------------------
| SUB: CheckEndurance
| -------------------------------------------------------------------------------------
    Sub CheckEndurance(ESpell,EPct,EHealth)
		/if (${Me.Hovering}) /return
        /if (${Me.Invis}) /return
        /declare EndResult string local FALSE
        /if (${EHealth.Equal[null]} || !${EHealth.Length}) /varset EHealth 0
        /if (!${Me.Standing}) {
			DEBUGN going to stand"
			/if (!${standTimer}) /stand
			/delay 1s ${Me.Standing}
			/if (!${Me.Standing}) {
				DEBUGN Returning cause I'm not standing"
				/return
			}
		}
        /if (${Cursor.ID}) /call CheckCursor
		DEBUGBUFF CheckEndurance casting CastWhat "${ESpell}" ${Me.ID} CheckEndurance"
        /call CastWhat "${ESpell}" ${Me.ID} CheckEndurance
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset EndResult TRUE
            /echo Casting >> ${ESpell} << for endurance
        }
    /return ${EndResult}
| -------------------------------------------------------------------------------------
| SUB: SummonStuff
| -------------------------------------------------------------------------------------    
    Sub SummonStuff(SSpell,SumItem,int SumNum)
        /if (${Me.Invis}) /return
		/if (${Me.Hovering}) /return
        /if (${FindItemCount[=${SumItem}]}>=${SumNum}) /return
        /declare SumResult string local FALSE
        /declare SummonAttempts int local 0
        /if (${FindItemCount[=${SumItem}]}<${SumNum}) {
            :summonagain
                /if (${Twist}) {
					/multiline ; /squelch /twist stop ; /varset Twisting 0
					/varset TwistStop ${Macro.CurLine}
				}
                /if (${Me.FreeInventory}==0) {
                    /echo No room in inventory skipping summoning >> ${SumItem} <<.
                    /goto :summondone
                }
                | Summon axes for zerkers had to be hard coded because spell is same name as tm item summoned.
                /if (${Select[${Me.Class.ShortName},BER]} && ${SSpell.Find[axe]}) {
                    /call CastDisc "${SSpell}" 0
                    /delay 80 ${Cursor.ID}
                    /varcalc SummonAttempts ${SummonAttempts}+1
                    /goto :inventory
                }
                | Summon stuff
                /if (!${Select[${Me.Class.ShortName},BER]} && !${SSpell.Find[axe]}) {
                    | Check if isummoning from an item
                    /if (${FindItemCount[=${SSpell}]} > 0) {
                        | Check if item is ready to cast
                        /if (${FindItem[=${SSpell}].Timer}!=0) {
                            /varset SumResult FALSE
                            /return ${SumResult}
                        }
                    }
                    /if (${Cursor.ID}) /call CheckCursor
                    /call CastWhat "${SSpell}" ${Me.ID} SummonStuff-nomem
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    :inventory
                    /delay 15s ${Cursor.ID}
                    /if (${Cursor.ID}) {
                        /echo Summoned  >> ${SumItem} <<
                        /varcalc SummonAttempts ${SummonAttempts}+1
                        /call CheckCursor
                    }
                    /if (${FindItemCount[=${SumItem}]}==0 && ${SummonAttempts}>0) {
                        /echo Summoning >> ${SumItem} << Failed - Check reagents, timer, etc
                        /echo -- Turning off ${SSpell} - ${SSpell}|Summon|${SumItem}|0
                        /varset SummonAttempts 0
                        /varset SumResult TRUE
                        /goto :summondone
                    }
                }
            /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                /echo You are missing components. Turning Off ${SumItem}.
                /varset SumResult FALSE
                /return ${SumResult}
            }
            /if (${FindItemCount[=${SumItem}]}<${SumNum} && ${SummonAttempts}>=5) /goto :summonagain
            :summondone
	    /if (${FindItemCount[=${SumItem}]} > 0) {
	            /echo I now have ${FindItemCount[=${SumItem}]}/${SumNum} of >> ${SumItem} <<
	    }
		}
    /return ${SumResult}
| -------------------------------------------------------------------------------------
| SUB: CheckIniBuffs
| -------------------------------------------------------------------------------------
    Sub CheckIniBuffs(BuffName, BuffsNum, int BuffRange, SpellToCast, 2ndPart, 3rdPart, 4thPart)
		/declare k int local
        /declare l int local
        | Assign var IniIDList all the spawn ids from buff ini file 2345|2195|2391| etc
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniBuffCount int local 0
        /declare IniBBuffList string local
        /declare IniBuffList string local
        /declare IniStackCheck[50] string local
        /declare PBTimerID int local
        /declare IniTempBuff string local
        | Check Buffs from ini
        /if (${Redguides}) {
            | IniIDCount = number of Char IDs counted in ini file. If 0 skip or Buff is null the the process.
            /if (${IniIDCount}<=0 || ${BuffName.Equal[null]}) /return
            | Start scan of buffs listed on toons in ini file
            /for k 1 to ${IniIDCount}
                /if (${AggroTargetID}) /return
                | If the Spawn ID is not in the zone and not a PC/merc and not me skip to next ID
                /if (!${Spawn[${IniIDList.Arg[${k},|]}].ID} || ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Type},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,NPC,TRIGGER,TRAP,TIMER,MOUNT]} || ${IniIDList.Arg[${k},|]}==${Me.ID}) /goto :NextCharCheck
                | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip because none of these are cast on others
                | Set buff to correct spell to check for with Dual tag
                /if (${2ndPart.Find[Dual]}) {
                    /if (${Select[${Spell[${3rdPart}].TargetType},self]})  {
                        /goto :NextCharCheck
                    } else {
						/varset BuffName ${3rdPart}
					}
                }
                | If buff marked MA skipped if spawn ID isn't MA
                /if ((${2ndPart.Equal[MA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.NotEqual[${MainAssist}]}) || (${2ndPart.Equal[!MA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.Equal[${MainAssist}]})) {
					/goto :NextCharCheck
				}
				|/echo new ME code ${IniIDList.Arg[${k},|]}\agLine#:${Macro.CurLine}
                /if ((${2ndPart.Equal[ME]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.NotEqual[${Me}]}) || (${2ndPart.Equal[!ME]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.Equal[${Me}]})) {
					/goto :NextCharCheck
				}
                /if ((${2ndPart.Equal[Caster]} && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${2ndPart.Equal[Melee]} && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /goto :NextCharCheck
                | Temp variable to store buff name after stripping rk stuff makes it easier to compare
                /varset IniTempBuff ${BuffName}
                /if (${BuffName.Find[ Rk. III]}) /varset IniTempBuff ${BuffName.Left[-8]}
                /if (${BuffName.Find[ Rk. II]})  /varset IniTempBuff ${BuffName.Left[-7]}
                | Assign var IniBBuffList blocked buffs list from ini file
                /varset IniBBuffList ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"Blockedbuffs"]}
                | If the current buff is on the blocked buff list skip it.
                /if (${IniBBuffList.Find[${IniTempBuff}]}) /goto :NextCharCheck
                | Assign var IniBuffList buffs list from ini file
                /varset IniBuffList ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"Buffs"]}
                | If current buff is on the buff list skip it
                /if (${IniBuffList.Find[${IniTempBuff}]}) /goto :NextCharCheck
                | Assign buff count
                /varset IniBuffCount ${Math.Calc[${IniBuffList.Count[|]}]}
                | Check if current buff stacks will all existing buffs in list
                /for l 1 to ${IniBuffCount}
                    | Fix for stacking issues with Perfected Group Levitation there are a lot
                    /if (${IniBuffList.Arg[${l},|].Find[Group Perfected Levitation]} && !${BuffName.Find[Group Perfected Levitation]}) /goto :PGLevFix
                    /if (${Select[${Spell[${IniBuffList.Arg[${l},|]}].WillStack[${BuffName}]},TRUE,FALSE,NULL]}>=2) {
                        /goto :NextCharCheck
                    }
                    :PGLevFix
                /next l
                | If buff has dual tag assign current buff to spell that needs to be cast
                /if (${2ndPart.Find[Dual]}) {
					/echo 1. ok we are buffing from the ini sub right now buff is ${BuffName}
					/varset BuffName ${SpellToCast}
					/echo 2. ok we are buffing from the ini sub right now buff is ${BuffName}

				}
                | varset ini buff timer toon Id spell Id to shorten var and clarity
                /varset PBTimerID ${IniIDList.Arg[${k},|]}${Spell[${BuffName}].ID}
                | Define timer for spell i am about to cast
                /if (!${Defined[IniBuffTimer${PBTimerID}]}) {
					/declare IniBuffTimer${PBTimerID} timer outer 0
				}
                | Check if toon is within spell range and cast buff
                /if (${Spawn[${IniIDList.Arg[${k},|]}].Distance} <= ${BuffRange} && !${IniBuffTimer${PBTimerID}}) {
                    /if (${Spell[${BuffName}].TargetType.Equal[self]} && ${Spawn[${IniIDList.Arg[${k},|]}].ID}!=${Me.ID}) {
                        /goto :NextCharCheck
                    }
					/echo BBUFF ${Spawn[${IniIDList.Arg[${k},|]}].CleanName} has id ${IniIDList.Arg[${k},|]} \agLine#:${Macro.CurLine}
					/call CacheBuffs ${Spawn[${IniIDList.Arg[${k},|]}].ID}
					/if (${Spawn[${IniIDList.Arg[${k},|]}].CachedBuff[${BuffName}].ID}) {
						/if (${Spawn[${IniIDList.Arg[${k},|]}].CachedBuff[${BuffName}].Duration} > 1000) {
							/echo [${Time}] \atCheckINIBuffs NOT Buffing ${Spawn[${IniIDList.Arg[${k},|]}].CleanName} with ${BuffName}. \agLine#:${Macro.CurLine}
							/goto :NextCharCheck
						}
					} else {
						/echo [${Time}] \atCheckINIBuffs Buffing ${Spawn[${IniIDList.Arg[${k},|]}].CleanName} with ${BuffName}. SpellToCast = ${SpellToCast} 2ndPart = ${2ndPart}\agLine#:${Macro.CurLine}
					}
                    /call CastWhat "${BuffName}" ${IniIDList.Arg[${k},|]} Buffs
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo [${Time}] Buffed >> ${BuffName} << on ${Spawn[${IniIDList.Arg[${k},|]}].CleanName} \agLine#:${Macro.CurLine}
                        /varset IniBuffTimer${PBTimerID} 60s
                        /varset IniNextTimer 0
                        /doevents flush Worn_off
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                    }
                }
                :NextCharCheck
                /if (${2ndPart.Find[Dual]}) {
					/varset BuffName ${3rdPart}
				}
            /next k
        }
    /return
| ----------------------------------------------------------------------------
| SUB: RegenOther
| ----------------------------------------------------------------------------
    Sub RegenOther(RGName, Stat, int StatPct, RegonOnClasses)
    | Casting on others during combat will interrupt fast med
		/if (${Me.Invis}) /return
		/if (${Me.Hovering}) /return
        /declare i int local 0 
		|Lemons: I think we have to return true no matter what to ensure we don't try to buff this buff on other people since we're only here cause the tag is there
        /declare ROResult string local TRUE
		DEBUGBUFF RegenOther Enter  ${RGName} ${Stat} ${StatPct} ${RegonOnClasses}"
        /if (${RegonOnClasses.Equal[0]} || ${RegonOnClasses.Equal[null]}) {
            /if (${Stat.Equal[endurance]}) {
                /varset RegonOnClasses BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
            }
            /if (${Stat.Equal[mana]}) {
                /varset RegonOnClasses BRD,BST,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHD,SHM,WIZ
            }
        }
        /for i 1 to 5 
            | If bard rallying call aa skip tank or he won't attack
			DEBUGBUFF RegenOther Class: ${Group.Member[${i}].Class.ShortName} AggroID: ${AggroTargetID}  GrpMemPct: ${Group.Member[${i}].Current${Stat}}<=${StatPct} GrpMemID: ${Group.Member[${i}].ID}"
            /if (${RGName.Find[Rallying Call]} && ${Group.Member[${i}].ID}==${Spawn[=${MainAssist} ${MainAssistType}].ID}) /goto :NextGMember 
            | Bard Dichotomic uses endurance not mana
            /if  (${RGName.Find[Dichotomic Psalm]} && ${Me.CurrentEndurance}<6700) /goto :NextGMember 
            | Dichotomic Psalm & Quiet Miracle do not work on bards
            /if (${Group.Member[${i}].Class.Name.Equal[bard]} && (${RGName.Equal[Dichotomic Psalm]} || ${RGName.Equal[Quiet Miracle]})) /goto :NextGMember
             DEBUGBUFF RegenOther:(${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID})"
			/if (${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID}) {            
                DEBUGBUFF RegenOther: i:${i} (${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID})"
				DEBUGBUFF RegenOther: Calling CastWhat with ${RGName} ${Group.Member[${i}].ID} Regenother"
				/call CastWhat "${RGName}" ${Group.Member[${i}].ID} Regenother
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting ${RGName} on ${Group.Member[${i}].CleanName} for ${Stat}.
					DEBUGBUFF RegenOther: Cast successful on ${Group.Member[${i}].CleanName} for ${Stat}"
                    /varset ROResult TRUE
                    /return ${ROResult}
                }
            }
            :NextGMember              
        /next i
    /return    ${ROResult}    
| -------------------------------------------------------------------------------------
| SUB: Target Window Buffs
| -------------------------------------------------------------------------------------     
    Sub TargetWinBuffs(int TWtargetID,Checkbuff,FromSub)
        /if (!${Checkbuff.Length} || ${Spawn[TWtargetID].ID}) /return
        /declare i int local 0
        /for i 0 to 50
            /if (${Window[TargetWindow].Child[Target_Buff${i}_Button].Tooltip.Find[${Checkbuff}]}) {
            /echo ${Target.CleanName} has ${Checkbuff} skipping to next buff
                /if (${FromSub.Equal[CastWhat]}) /call Interrupt
                /return TRUE 
            }
        /next i
    /return 
| -------------------------------------------------------------------------------------
| SUB: PetStateCheck
| -------------------------------------------------------------------------------------
Sub PetStateCheck 
    DEBUGPET Checking Pet State."
	/if (${Me.Hovering}) /return
    /if (${Me.AltAbility[Companion's Suspension]}>0) {    
        :CastSusMin
        /if (${Me.AltAbilityReady[Companion's Suspension]}) {
			/alt act ${Me.AltAbility[Companion's Suspension].ID}
            /call WaitCast "PetStateCheck" ${Me.Ability[Companion's Suspension].Spell.CastTime}
            /doevents
        } else {
            /echo Waiting on Suspend Minion AA to be ready.
            /delay 1s
            /goto :CastSusMin
        }
   } else {
        /echo You do not have the "Companion's Suspension" AA, PetSuspend being turned off.
        /varset PetSuspend 0    
    }
    /if (${Me.Pet.ID}) /varset PetActiveState  1
/return

| -------------------------------------------------------------------------------------
| SUB: DoPetStuff
| -------------------------------------------------------------------------------------
    Sub DoPetStuff
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (!${Defined[PetSpell]}) /declare PetSpell string outer NULL
		/if (!${Defined[PetBuffsOn]}) /declare PetBuffsOn bool outer FALSE
		|Lemons: Changed where we put PetOn check so that they will buff their charm pet without trying to cast a pet spell from the ini. 
        | /if (!${PetOn} || ${AggroTargetID} || ${Me.Invis} || ${Me.Hovering}) /return
        |/if (!${PetOn}) /return
        /if (${AggroTargetID}) /return
        /if (${Me.Invis}) /return
        /if (${Me.Hovering}) /return
        /if (${Spell[${PetSpell}].ReagentID[1]} > 0 && ${PetOn}) {
			/if (${FindItemCount[${Spell[${PetSpell}].ReagentID[1]}]} < ${Spell[${PetSpell}].ReagentCount[1]}) {
				/echo ${PetSpell} requires a Reagent to cast it's ID is ${Spell[${PetSpell}].ReagentID[1]} and you don't have any. \agLine#:${Macro.CurLine}
				/echo You are missing components. Turning off ${PetSpell}. \agLine#:${Macro.CurLine}
				/varset PetOn 0
				/return
			}
		}
        /declare PetSummonTimer timer local 60s
		/declare didCast bool local FALSE
        /doevents
        DEBUGPET DoPetStuff Enter"
        /declare FocusCurrent string local ${InvSlot[${PetFocus.Arg[2,|]}].Item.Name}
        /declare FocusSlot string local ${PetFocus.Arg[2,|]}
        /declare FocusPet string local ${PetFocus.Arg[1,|]}
        /declare FocusSwitch int local 0
		/declare i int local 0
		/declare OffHand string local
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]}) /pet get lost
        | Swap pet focus in pet cast
        /if (!${Me.Pet.ID} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana} && ${PetSpell.NotEqual[YourPetSpell]} && !${Me.Casting.ID}) {
            | verbose
            /echo I have no pet. ${Me.Class}s live longer when we have pets. \agLine#:${Macro.CurLine}
            /varset PetActiveState 0
            /if (${PetFocus.Arg[1,|].Length} && ${FindItemCount[=${FocusPet}]}) {
                /if (!${Cursor.ID} && ${FocusPet.NotEqual[${FocusCurrent}]}) {
					|Lemons: Adding in support to designate a bandolier set instead of a slot. PetFocus=Earring of PetFocus|band:NameOfSet
					/if (${PetFocus.Arg[2,|].Find[band:]}) {
						/for i 1 to 12
							/if (${Me.Bandolier[${Bandolier[${i}]}].Item[1].ID} == ${Me.Inventory[mainhand].ID} && ${Me.Bandolier[${Bandolier[${i}]}].Item[2].ID} == ${Me.Inventory[offhand].ID} && ${Me.Bandolier[${Bandolier[${i}]}].Item[3].ID} == ${Me.Inventory[ranged].ID} && ${Me.Bandolier[${Bandolier[${i}]}].Item[4].ID} == ${Me.Inventory[ammo].ID}) {
								/varset FocusCurrent ${i}
								/echo PetFocus is set to a bandolier. Original set as ${Me.Bandolier[${i}]}
								/break
								}
						/invoke ${Me.Bandolier[${PetFocus.Arg[2,|].Arg[2,:]}].Activate}
					}
                    /call CheckCasting 50
					|Lemons: Exchange doesn't work if you're moving a 2h wep in with both hands occupied. 
					/if (${FocusSlot.Equal[Mainhand]} && ${FindItem[${FocusPet}].Type.Find[2h]} && ${InvSlot[14].ID}) {
						/varset OffHand ${InvSlot[14].Item.Name}
						/unequip 14
						/delay 2s 
					}
                    /if (!${PetFocus.Arg[2,|].Find[band:]}) /exchange "${FocusPet}" ${FocusSlot}
                    /varset FocusSwitch 1
                    /delay 1s
                }
            }
            /doevents
            /delay 3
            | Pet spell mem check - Else try item like mage epic
			DEBUGPET Pet: Going to CastWhat with ${PetSpell} ${Me.ID} DoPetStuff"
            /call CastWhat "${PetSpell}" ${Me.ID} "DoPetStuff"
			DEBUGPET Pet: Back from CastWhat"
			/varset didCast TRUE
			| Add these 2 lines to remove pettoys line if a new summon happens.  later one doesn't get called due to early return -bytebyte
			/ini ${IniFileName} "Pet" "PetToysGave" "0"
			/varset PetToysGave ${Ini[${IniFileName},Pet,PetToysGave]}
            | Summon Pet
            |- If using suspended pet function.
            /if (${PetSuspend}) {
				DEBUGPET Pet: Suspend pet checks"
               |- If I have a suspended pet bust him out!
               /if ((${PetTotCount}==1) && (${PetActiveState}==0) && (${PetSuspendState}==1)) {
                   /echo I have a suspended pet, summoning it now! \agLine#:${Macro.CurLine}
                   /call PetStateCheck           
               }
               |- If I don't have a suspended or an active pet, make them.
               /if (${PetTotCount}<2 && ${PetSuspendState}==0 && ${PetActiveState}==0 && ${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
					:MakeMyPet1
                    /echo - Making pet now. \agLine#:${Macro.CurLine}
                    /echo 1 ARISE ${PetSpell} \agLine#:${Macro.CurLine}
                    /call CastWhat "${PetSpell}" ${Me.ID} "DoPetStuff \agLine#:${Macro.CurLine}"
					/varset didCast TRUE
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components to make this pet. Ending macro.
                        /end
                    } 
                    /delay 15s !${Me.Casting.ID}
                    /delay 1s ${Me.Pet.ID}            
                    /if (!${Me.Pet.ID} && ${PetSummonTimer}) {
                        /goto :MakeMyPet1
                    } else {                
                        /if (${Me.Pet.ID})  /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                        /varset PetActiveState 1
                        /call CheckPetBuffs
                        /if (${Me.Pet.ID} && ${PetToysOn}) {
                            /call PetToys ${Me.Pet.CleanName}
                            /if ((${PetSuspendState}==0) && (${PetActiveState}==1)) /varset PetToysDone 0
                            /if ((${PetSuspendState}==1) && (${PetActiveState}==1)) /varset PetToysDone 1
                        }
                    }
                    /call PetStateCheck
                    /if (${PetTotCount}<2 && ${PetSuspendState}==1 && ${PetActiveState}==0  && ${PetSummonTimer}) /goto :MakeMyPet1
                }
            } else /if (${Me.Book[${PetSpell}]}) {
				DEBUGPET Pet: PetSpell is a spell in my book"
                | Normal pet function for not using suspend pet.
                :MakeMyPet2
				/call GetHostilesOnXTarget
				/if (${Macro.Return} > 0) {
					/return
				}
				/delay 2
				/if (${Me.Pet.ID}) {
					/if (${FocusSwitch}) /goto :swap
					DEBUGPET Already have a pet up, not gonna get another one, returning"
					/return
				}
				/if (${Spell[${PetSpell}].Mana} <= ${Me.CurrentMana}) {
					/call CastWhat "${PetSpell}" ${Me.ID} "DoPetStuff \agLine#:${Macro.CurLine}"
					/varset didCast TRUE
					|/delay 10s !${Me.Casting.ID}
					/if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
						/echo You are missing components to make this pet. Ending macro.
						/end
					}
					/delay 1s ${Me.Pet.ID}
					/if (!${Me.Pet.ID}  && ${PetSummonTimer}) {
						/goto :MakeMyPet2
					} else {                
						/if (${Me.Pet.ID})  /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
						/varset PetActiveState 1                
					}
				}
            }
            | Reset PetToysGave in config after pet creation, as well as memory variable so we will pickup if our pet needs toys after death, under new condition checks.
            /ini ${IniFileName} "Pet" "PetToysGave" ""
            /if (${Me.Pet.ID} && ${PetToysOn}) /varset PetToysGave "NULL"
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance} <= ${CampRadius}) {
				/pet guard
			}
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance} > ${CampRadius}) {
				/pet follow
			}
            /if (${PetHoldOn}) /pet ${PetHold} on      
            /if (${Me.AltAbility[Pet Discipline]}>5) /pet focus on
            /if (!${PetTauntOn} && ${Select[${Role},pettank,pullerpettank]}) /pet taunt on
        }
		:swap
		| Swap pet focus out for regular item
		/if (${FocusSwitch} && !${Cursor.ID}) {
			/if (${PetFocus.Arg[2,|].Find[band:]}) {
				/invoke ${Me.Bandolier[${FocusCurrent}].Activate}
			} else {
				/call CheckCasting
				/exchange "${FocusCurrent}" ${FocusSlot}
				/delay 3
				/if (${OffHand.Length}) {
					/exchange "${OffHand}" 14
				}
				/delay 2
			}
		}
        /call CheckPetBuffs
        | Pet Toy routines
        | Condition revised to only call PetToys if I do not have my pet name in the PetToysGave string.
        /if (${Me.Pet.ID} && ${PetToysOn} && !${PetToysGave.Find[${Me.Pet.CleanName}]}) /call PetToys ${Me.Pet.CleanName}
        | Check to have pet come to owner if owner out of camp too long.
        /if (${Select[${Role},pettank,hunterpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) && ${Me.Pet.Stance.Equal[GUARD]}) {
			/pet follow
		}
        |/if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscGem}]}) /memorize "${ReMemMiscGem}" gem${MiscGem}
        /if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscGem}]} && ${MiscGemRemem} && ${didCast}) /call MemSpell "${ReMemMiscGem}" ${MiscGem}
        DEBUGN DoPetStuff Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckPetBuffs
| -------------------------------------------------------------------------------------
Sub CheckPetBuffs
        /if (!${Me.Pet.ID}) /return
        |Lemons: Commenting out so the bot will buff a charmed pet.
		|/if (!${PetOn}) /return
        /if (!${PetBuffsOn}) /return
        /if (${CombatStart}) /return
        /if (${Pulling}) /return
        /if (${PetBuffCheck}) /return
        /if (${Me.Invis}) /return
		/if (${ChaseAssist} && !${BuffWhileChasing}) /return
        DEBUGBUFF CheckPetBuffs Enter"
        /declare PTempBuff string local
        /declare i int local 0
        /declare j int local
        /declare SpellToCast string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0                
        /declare FoundPetBuff int local 0
        /varset PetBuffCheck 60s
        /for i 1 to ${PetBuffs.Size}
            /doevents
            | Stop pet buffing if aggro detected
            /if (${AggroTargetID}) /return
            /if (${PetBuffs[${i}].Equal[Null]}) /goto :SkipPetBuff
            | Check for pet spells in book to prevent double casting of items
            /if (${Me.Book[${PetBuffs[${i}]}]} || ${Me.AltAbilityReady[${PetBuffs[${i}]}]}) {
                /varset PTempBuff ${PetBuffs[${i}]}
                /if (${PetBuffs[${i}].Find[ Rk. III]}) /varset PTempBuff ${PetBuffs[${i}].Left[-8]}
                /if (${PetBuffs[${i}].Find[ Rk. II]}) /varset PTempBuff ${PetBuffs[${i}].Left[-7]}
                DEBUGBUFF CheckPetBuffs ${i} ${Me.PetBuff[${PTempBuff}]} ${PetBuffs[${i}]} ${PTempBuff}"
                /for j 1 to 50
                    /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                /next j
                /if (!${FoundPetBuff}) {
                    | Vebrose
                    /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet-nomem
                    /call WaitCast "FoundPetBuff" ${Spell[${PetBuffs[${i}]}].MyCastTime}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with ${PetBuffs[${i}]}
                    /varset FoundPetBuff 0
                    /goto :SkipPetBuff
                }
            }
            DEBUGBUFF CheckPetBuffs ${FindItem[=${PetBuffs[${i}]}].Spell} ${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]}"
            /if (${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]}>=1) /goto :SkipPetBuff
            |- Cast item clicky buff (ItemName and PetBuff = DIFFERENT)
            |--- START: Multipart handling for PetBuffs.
            /if (${PetBuffs[${i}].Find[|]}) {            
                /varset SpellToCast ${PetBuffs[${i}].Arg[1,|]}
                /varset 3rdPart ${PetBuffs[${i}].Arg[3,|]}
                /varset PTempBuff ${3rdPart}
                |--- START: DUAL Handle for different Effect names versus their Item name
                DEBUGBUFF CheckPetBuffs - Dual - ${SpellToCast} - ${3rdPart}"
                /if (${PetBuffs[${i}].Arg[2,|].Equal[Dual]}) {
                    /if (${FindItem[=${SpellToCast}].ID}) {
                        /for j 1 to 50
                             /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                        /next j
                        /if (!${FoundPetBuff}) {
                            |Vebrose
                            /call CastWhat "${SpellToCast}" ${Me.Pet.ID} Pet
                            /call WaitCast "FoundPetBuff" ${Spell[${SpellToCast}].MyCastTime}
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with (${3rdPart})
                            /varset FoundPetBuff 0        
                            /goto :SkipPetBuff
                        }
                    }
               }
               |--- END: DUAL Handle for different Effect names versus their Item name                
            }
            |--- END: Multipart handling for PetBuffs.

            |- Cast item clicky buff (ItemName and PetBuff = SAME)
            /if (${FindItem[=${PetBuffs[${i}]}].ID}) {
                /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet
                /call CheckCasting 75
            }
            :SkipPetBuff
            /varset FoundPetBuff 0
        /next i
    DEBUGBUFF CheckPetBuffs Pet Height: ${Me.Pet.Height}"
    /if (${Me.Pet.Height}>1.35 && ${PetShrinkOn}) {
        /call CastWhat "${PetShrinkSpell}" ${Me.Pet.ID} Pet
    }
    /if (${Target.ID}==${Me.Pet.ID}) {
		/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
		/squelch /target clear
	}
    DEBUGBUFF CheckPetBuffs Leave"
/return
| ----------------------------------------------------------------------------
| SUB: Check PetToys - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for MuleAssist
| ----------------------------------------------------------------------------
    Sub PetToys(string petName)
        /if (!${Me.Pet.ID}) /return
        DEBUGPET PetToys Enter"
        /declare i int local 0
        /declare j int local
        /declare GrabItem int local 0
        /declare PetToySpell string local 0
		/declare GiveCnt int local 0
        /declare FullText string local
        /declare 2ndPart string local
        /declare 3rdPart string local
        /declare PetToysTemp string local ${Ini[${IniFileName},Pet,PetToysGave]}
        /declare GaveItem int local 1
        /call OpenInvSlot
        /declare petID int local ${Spawn[pet ${petName}].ID}
        /if (${BagNum}==0) {
            /echo You must have an empty Top Inventory slot for Pet Toys to work.
            /varset PetToysOn 0
            /return
        }
        /if (!${InvSlot[pack${BagNum}].Item.Container} && !${Me.FreeInventory}) {
            /echo Inventory is full. Turning off pet toys
            /varset PetToysOn 0
            /return
        }
        | reset if different pet name only on my pet
        /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
            /ini ${IniFileName} "Pet" "PetToysGave" "0"
            /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
        }
        /for i 1 to ${PetToys.Size}
        DEBUGPET CHECKING: ${i} ${PetToys[${i}]}"
			DEBUGPET PetToys Spell: ${PetToys[${i}]}"
			DEBUGPET PetToys Temp: ${PetToysTemp}"
			DEBUGPET PetToys SkipCheck: ${PetToys[${i}].Equal[Null]} || (${Me.Pet.CleanName.Equal[${petName}]} && ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]})"
            | Had to add pet name check else it will always skip giving weapons to OTHER pets.                        
            /if (${PetToys[${i}].Equal[Null]} || (${Me.Pet.CleanName.Equal[${petName}]} && ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]})) /goto :SkipPetToy
            | Are we handing weapons to the pet
            /if (${PetToys[${i}].Arg[2,|].Length}) {
				DEBUGPET PetToys Spell has multiple parts"
                /varset FullText ${PetToys[${i}]}
                /varset PetToySpell ${PetToys[${i}].Arg[1,|]}
                /varset 2ndPart ${PetToys[${i}].Arg[2,|]}
                /varset 3rdPart ${PetToys[${i}].Arg[3,|]}
            } else {
				DEBUGPET PetToys Spell has one part"
                /varset PetToySpell ${PetToys[${i}]}
            }
			DEBUGPET PetToys Skip check (${Me.Pet.CleanName.Equal[${petName}]} && ((${2ndPart.Length} && ${PetToysTemp.Find[${2ndPart}1]}) || (${3rdPart.Length} && ${PetToysTemp.Find[${3rdPart}2]})))"
            /if (${Me.Pet.CleanName.Equal[${petName}]} && ((${2ndPart.Length} && ${PetToysTemp.Find[${2ndPart}1]}) || (${3rdPart.Length} && ${PetToysTemp.Find[${3rdPart}2]}))) /goto :SkipPetToy
            | Check for pet toy spells in book to prevent double casting of items
            /if (${Me.Book[${PetToySpell}]}) {
				DEBUGPET PetToys We have the spell so cast it"
				/if (${Me.GemTimer[${PetToySpell}]}!=0) {
					DEBUGPET PetToys Delaying until the spell is ready to cast"
					/delay 15s ${Me.GemTimer[${PetToySpell}]}==0
				}
                /call CastWhat "${PetToySpell}" ${Me.ID} Pet-nomem
                /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
					DEBUGPET PetToys Temp doesn't have the petName ${petName} in it yet and it's my pet"
					DEBUGPET ${IniFileName} "Pet" "PetToysGave" "${petName}""
                    /ini ${IniFileName} "Pet" "PetToysGave" "${petName}"
                    /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting pet toy spell >> ${PetToySpell} <<
                }

                /delay 15s ${Cursor.ID}
				DEBUGPET PetToys Should have something on cursor. If not, I'm leaving ${Cursor.ID}"
                /if (!${Cursor.ID}) /return
                | Check if spell has summoned a bag or folded pack
                /if (${Cursor.Container} || ${Cursor.Name.Find[Folded]}) {
					DEBUGPET PetToys it's a container"
                    | If item is in Inv Slot exchange it with bag on cursor
                    /if (${InvSlot[pack${i}].Item.ID}) /nomodkey /itemnotify pack${BagNum} leftmouseup
                    :Unfolded
                    /delay 2s ${Cursor.ID}
                    | Drop exchanged item into inventory
                    /autoinventory
                    /delay 1s
                    | If folded pack right click to convert to phantom satchel
                    /if (${InvSlot[pack${BagNum}].Item.Name.Find[folded]}) {
                        /nomodkey /itemnotify pack${BagNum} rightmouseup
                        /echo Opening ${InvSlot[pack${BagNum}].Item.Name}
                        /delay 3s
                        | Return to top to drop bag into inventory
                        /goto :Unfolded
                    }
                }
                /if (${InvSlot[pack${BagNum}].Item.Container} && (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]})) {
                    | Open the bag
                    /nomodkey /itemnotify pack${BagNum} rightmouseup
                    /delay 10
                    DEBUGPET PetToys ${i} ${PetToySpell} ${2ndPart} ${3rdPart}"
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${2ndPart}1]}) && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]})) {
                        /call GiveTo "${2ndPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
						DEBUGPET PetToys Set PetToysTemp to ${PetToysTemp}"
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini ${IniFileName} "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${3rdPart}2]}) && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]})) {                  
                        /call GiveTo "${3rdPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${3rdPart}2
						DEBUGPET PetToys Set PetToysTemp to ${PetToysTemp}"
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini ${IniFileName} "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    /if (!${2ndPart.Length}) {
                        /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                            /if (${InvSlot[pack${BagNum}].Item.Item[${j}].ID} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                                /call GiveTo "${InvSlot[pack${BagNum}].Item.Item[${j}].Name}" ${petID}
                            }
                            /delay 10
                        /next j
                        /if (${j}>=8 && !${PetToysTemp.Find[${PetToySpell}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
                            /varset PetToysTemp ${PetToysTemp}|${PetToySpell}
							DEBUGPET PetToys Set PetToysTemp to ${PetToysTemp}"
                            /ini ${IniFileName} "Pet" "PetToysGave" "${PetToysTemp}"
                        }
                    }
                }
				DEBUGPET PetToys Check if cursor has Summoned: on it ${Cursor.Name.Find[Summoned:]}"
                /if (${Cursor.Name.Find[Summoned:]}) {
					DEBUGPET PetToys calling GiveTo ${Cursor.Name} ${petID}"
                    /call GiveTo "${Cursor.Name}" ${petID}
					DEBUGPET Setting Temp to ${PetToysTemp}|${PetToySpell}
                    /varset PetToysTemp ${PetToysTemp}|${PetToySpell}
                    /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini ${IniFileName} "Pet" "PetToysGave" "${PetToysTemp}"
                    /varset GaveItem 0
                }
				DEBUGPET PetToys Check destroy bag (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]})
                /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) /call DestroyBag
                /goto :SkipPetToy
            }
        :SkipPetToy
            | Reset spell vars
			DEBUGPET PetToys SkipPetToy 2ndpart currently ${2ndPart} ${2ndPart.Length}"
            /if (${2ndPart.Length}) {
                /varset FullText
                /varset 2ndPart
                /varset 3rdPart
            }
            /if (!${PetToysOn}) /return
        /next i
        | MUST reset PetToysGave after cycle complete in order to stop calling PetToys all the time.
		DEBUGPET PetToys Resetting PetToysGave ${PetToysGave} to PetToysTemp ${PetToysTemp}"
        /varset PetToysGave ${PetToysTemp}
        /if (${Window[InventoryWindow].Open} && !${GaveItem}) /keypress inventory
        /varset PetToysDone 1
        DEBUGPET PetToys Leave"
    /return
| ----------------------------------------------------------------------------
| SUB: Check OpenInvSlot - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for MuleAssist
| ----------------------------------------------------------------------------
    Sub OpenInvSlot
        /if (${BagNum}) /return
		/if (${Me.Hovering}) /return
        /declare i int local 0
        /varset BagNum 0
        /for i 1 to 10
            /if (${InvSlot[pack${i}].Item.Container}) /goto :NextSlot
            /if (!${InvSlot[pack${i}].Item.Container} || ${InvSlot[pack${i}].Item.ID}==0) {
                | Must have at least 2 inv slots open in order to swap bags and items
                /if (${Me.FreeInventory}>=2) /varset BagNum ${i}
            }    
            /if (${BagNum}) {
                /echo Pet Toys: Inventory slot ${i} is empty using that one.
                /delay .5
                /return
            }
            :NextSlot
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Check DestroyBag - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for MuleAssist
| ----------------------------------------------------------------------------
    Sub DestroyBag
        /declare j int local
        | Make sure bag has no items other than summoned in it before deleting.
        /if (${InvSlot[pack${BagNum}].Item.Items}) {
            /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                /if (!${InvSlot[pack${BagNum}].Item.Item[${j}].NoRent} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                    /echo Bag has non summoned item(s) in it. Aborting delete. Pet Toys Off
                    /varset PetToysOn 0
                    /return
                }
            /next j
        }
        /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) {
            /nomodkey /itemnotify pack${BagNum} leftmouseup
            /delay 5s ${Cursor.ID}
            /if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
            /delay 20 !${Cursor.ID}
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Check GiveTo - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for MuleAssist
| ----------------------------------------------------------------------------
    Sub GiveTo(string GItem, int GTarget)
        /declare ItemSummoned int local 0
        /if (${Target.ID}!=${GTarget}) {
			/if (${MuleDebug}) /echo Targeting a mob 15m
            /target id ${GTarget}
            /delay 2s ${Target.ID}==${GTarget}
        }
        /if (${Target.Distance}>10 && ${Target.Distance}<=${CampRadius}) {
			DEBUGMOVE Moveto "
			/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
            /moveto id ${Target.ID}
            /delay 50 ${MoveTo.Stopped}
        }
        /if (!${Cursor.ID} && ${FindItemCount[=${GItem}]}>0) {
            /shift /itemnotify "${GItem}" leftmouseup
            /delay 20 ${Cursor.ID}
        }
        :CursorFree
            /if (${Cursor.ID} && ${Cursor.NoRent} && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
                /varset ItemSummoned 1
                /nomodkey /click left target
                /delay 10
            }
        /if (${Cursor.ID} && ${Cursor.NoRent}) /goto :CursorFree
        /delay 30 ${Window[GiveWnd].Open}
            /if (${ItemSummoned} && ${Window[GiveWnd].Open}) {
                /notify GiveWnd GVW_Give_Button leftmouseup
                /echo Giving ${GItem} to ${Target.CleanName}
            } else {
                /echo Item is NOT SUMMONED canceling trade
                /notify GiveWnd GVW_Cancel_Button leftmouseup
            }
            /delay 15 
            | New pet patch gives back item if pet has equipped. Delete item from cursor.
            /if (${Cursor.ID} && ${Cursor.NoRent} && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
            :delItem
                /destroy
                /delay 10
            /if (${Cursor.ID}) /goto :delItem
        }
        /delay 200 !${Window[GiveWnd].Open}
    /return
| ----------------------------------------------------------------------------
| SUB: Check Plugin
| ----------------------------------------------------------------------------
    Sub CheckPlugin(string pluginname)
        /if (${Debug}) {
			DEBUGN CheckPlugin: Enter \agLine#:${Macro.CurLine}"
		}
        /if (!${Bool[${Plugin[${pluginname}]}]}) {
            /squelch /plugin ${pluginname} load noauto
            /echo ${pluginname} not detected! This macro requires it! Loading ...
        }
        /if (${Debug}) {
			DEBUGN CheckPlugin: Leave \agLine#:${Macro.CurLine}"
		}
    /return
	
| ----------------------------------------------------------------------------
| SUB: Cleanup - Removed depreciated sections from ini
| ----------------------------------------------------------------------------
Sub Cleanup
	/if (${Ini[${IniFileName},General,MedCombat].Length}) {
		/echo Removing MedCombat. It's not used. 
		/ini ${IniFileName} General MedCombat NULL
	}
/return
| ----------------------------------------------------------------------------
| SUB: Load Ini
| ----------------------------------------------------------------------------
Sub LoadIni(string sectionName, string varName, string varType, string varValue, string varArray, string varArray2, string FileName, string FileName2)
 |/call LoadIni 		DPS 				DPS            string     		NULL       		 DPS              DPSCond        ${IniFileName} ${ConditionsFileName}
 |                "${ZoneName}"        MezImmune       		string          "L"              NULL             False             ${InfoFileName}
    /if (${Debug}) {
        DEBUGN Sub Loadini S:${sectionName} varName:${varName} varType:${varType} varValue:${varValue} varArray:${varArray} varArray2:${varArray2} FileName:${FileName} FileName2:${FileName2} \agLine#:${Macro.CurLine}"
    }
	
	|/setchattitle Loading Ini ${sectionName}:${varName}
    /declare rkTemp                 string      local 
    /declare IsConditionVar         int         local        0 
    /declare UtilInt                int         local        0 
    /declare FileName1              string      local        ${FileName}
	/declare isBlank				bool		local		FALSE
	/declare RestartFlag			bool 		local 		FALSE
    /if (${FileName1.Length}==0 || ${FileName1.Equal[null]} || ${FileName1.Equal[NULL]}) {
		 /varset FileName1 ${IniFileName}
		 DEBUGN No FileName1 sent in. Changing it to ${IniFileName}, ${FileName1}"
    }
	|Lemons: Because of emu servers, gonna strip an extra pair of " out of FileName1. Yes, that's 3 "
	/if (${FileName1.Find["""]}) {
		/varset FileName1 ${FileName1.Right[-1].Left[-1]}
		|/echo LemonsDebug: FileName1 has double quotes. Removing one pair and setting to ${FileName1}
	}
	/if (${FileName2.Find["""]}) {
		/varset FileName2 ${FileName2.Right[-1].Left[-1]}
		|/echo LemonsDebug: FileName2 has double quotes. Removing one pair and setting to ${FileName2}
	}
    | Check if ini value is asking for an array ie buff 1 to buff40
	| cant check this if ${varArray} is NULL (cause then we are checking {NULL.Size}
	/if (${Bool[${varArray}]}) {
        /if (${${varArray}.Size}>0) {
        	/declare i int local 0
        	/for i 1 to ${${varArray}.Size}
				|DEBUGN Array: ${varArray} ${${varArray}} | Sec: ${sectionName} | Name: ${varName} | Val: ${varValue} | Ini: ${Ini[${FileName1},${sectionName},${varArray}${i}]}"
				/varset IsConditionVar 0
        	    /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
					/ini ${FileName1} "${sectionName}" "${varArray}${i}" "${varValue}"
				}
        	    /if (${varName.Equal[OhShit]}) {
					/if (${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
						|Lemons: Going stop filling inis with 40 NULL entries and set their array size to however many entries they have.
						/if (${Ini[${FileName1},${sectionName},${varArray}${i}].Equal[NULL]} && ${Ini[${FileName1},${sectionName},${varArray}${Math.Calc[${i}+1].Int}.Equal[NULL]} && ${Ini[${FileName1},${sectionName},${varArray}${Math.Calc[${i}+2].Int}.Equal[NULL]}) {
							/echo LemonsDebug: No entry for ${sectionName},${varArray}${i}. Going to set ${varArray} from ${${varArray}.Size} to ${Math.Calc[${i} -1]}
							/ini ${FileName1} "${sectionName}" "${varArray}Size" ${Math.Calc[${i} -1].Int}
							/varset isBlank TRUE
						} else {
							/varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i},TRUE,noparse]}
							|ok so we are at in a special case, we need to set this var to 1 so it wont try to refer to an undeclared variable 
							|The user is using a OhShit, which is allowed to take undeclared varibles in its argument.
							/varset IsConditionVar 1
						}
					}
				} else /if (${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
					|Lemons: Going stop filling inis with 40 NULL entries and set their array size to however many entries they have.
					/if (${Ini[${FileName1},${sectionName},${varArray}${i}].Equal[NULL]} && ${Ini[${FileName1},${sectionName},${varArray}${Math.Calc[${i}+1].Int}].Equal[NULL]} && ${Ini[${FileName1},${sectionName},${varArray}${Math.Calc[${i}+2].Int}].Equal[NULL]}) {
						/echo LemonsDebug: No entry for ${sectionName},${varArray}${i}. Going to set ${varArray} from ${${varArray}.Size} to ${Math.Calc[${i} -1]}
						/ini ${FileName1} "${sectionName}" "${varArray}Size" ${Math.Calc[${i} -1].Int}
						/varset isBlank TRUE
					} else {
						|Lemons: This is for the parser engine 2. Now we can actually store a non-parsed variable in an array
						DEBUGN Setting #${i} ${varArray}[${i}] to ${Parse[2,${Ini[${FileName1},${sectionName},${varArray}${i}]}]}"
						/varset ${varArray}[${i}] ${Parse[2,${Ini[${FileName1},${sectionName},${varArray}${i}]}]}
					}
				}
				|Now we're gonna support people who create blanks in ther UI/Ini......................
				/if (${Ini[${FileName1},${sectionName},${varArray}${i}].Equal[NULL]} && (${Ini[${FileName1},${sectionName},${varArray}${Math.Calc[${i}+1].Int}].NotEqual[NULL]} || ${Ini[${FileName1},${sectionName},${varArray}${Math.Calc[${i}+2].Int}].NotEqual[NULL]})) {
					/echo \arYou have blank spots in your Ini and/or MQ2Mule UI window for ${varArray}. I'll try to set your ${varArray}Size to what I can only guess is the correct numbers
					/echo \arBlank spots can cause issues. If you experience any issues, remove the blank spots. If the new ${varArray}Size is wrong, get rid of your blanks in your UI and Ini, then try again. ${FileName1} "${sectionName}" "${varArray}Size" ${Math.Calc[${i} +1].Int}
					|We haven't increased the number yet (or enough), so we will increase it by one and end the macro to be restarted.
					/if (${${varArray}Size} != ${Math.Calc[${i}+1]} && ${${varArray}Size} < ${i}) {
						/ini ${FileName1} "${sectionName}" "${varArray}Size" ${Math.Calc[${i} +1].Int}
						/varset RestartFlag TRUE
						/beep
						}
				}
        	    /if (${Debug}) {
					DEBUGN ${ConditionsOn} ${Int[${varArray2.Length}]} ${varArray2.Length} ${Bool[${varArray2.NotEqual[null]}]} ${varArray2}"
				}
        	    /if (${Defined[ConditionsOn]}) {
        	        /if (${ConditionsOn} && ${Int[${varArray2.Length}]}>0 && ${varArray2.NotEqual[null]}) {
        	            | Check to see if the conditions file is a different file and update spell info.
        	            /if (!${IsConditionVar}) {
							|ok the user is NOT using a undeclared variable so its ok for us to read it.
							/if (${FileName2.NotEqual[${FileName1}]}) /ini "${FileName2}" "${sectionName}" "${varName}${i}" "${${varArray}[${i}]}"
        	            }
						/if (!${Ini["${FileName2}",${sectionName},${varArray2}${i}].Length}) {
        	                /if (${${varArray}[${i}].NotEqual[null]}) {
        	                    /ini "${FileName2}" "${sectionName}" "${varArray2}${i}" "TRUE"
        	                } else {
        	                    /ini "${FileName2}" "${sectionName}" "${varArray2}${i}" "FALSE"
        	                }
        	            }
        	            /varset ${varArray2}[${i}]  ${Ini["${FileName2}",${sectionName},${varArray2}${i},TRUE,noparse]}
						/if (${IsConditionVar}) {
							| the user IS using a undeclared variable in his condition, we should NOT check this against Rk. II
							| because if we read that var it is undeclared at this point so we skip.
							/continue
						}
        	        } else /if (${Int[${varArray2.Length}]}>0 && ${varArray2.NotEqual[null]}) {
        	            /varset ${varArray2}[${i}] TRUE
                	} 
                } else {
                	/varset ${varArray2}[${i}] TRUE
                }
                /if (${${varArray}[${i}].NotEqual[null]}) {
                	| find out if there is a Rank and fix spell name.
                	/if (${varType.Equal[string]} && ${Int[${${varArray}[${i}].Left[1]}]}==0) {
						DEBUGN LoadIni Checking spell rank ${${varArray}[${i}]}" 
                	    /call Spell_Rk_Check "${${varArray}[${i}]}"
						DEBUGN LoadIni Return is ${Macro.Return}"
                	    /if (${${varArray}[${i}].Find[|]}) {
							|so we don't overwrite the dynamic $Parse stuff
							/varset ${varArray}[${i}] ${Macro.Return.Arg[1,|]}|${Parse[3,${Ini[${FileName1},${sectionName},${varArray}${i}].Right[-${${varArray}[${i}].Find[|]}]}]}
							|/echo returned from spellck: ${Macro.Return.Arg[1,|]}|${Parse[3,${Ini[${FileName1},${sectionName},${varArray}${i}].Right[-${${varArray}[${i}].Find[|]}]}]}
						} else {
							/varset ${varArray}[${i}] ${Macro.Return}
						}
                	}
                	| code to fix the Heal PCT for those zones that knock your HPs down to 
                	/if (${sectionName.Equal[Heals]} && ${Select[${Zone.ID},795,796]}) {
                	    /if (${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0) {
                	        /varset UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}
                	        /varcalc UtilInt 70*(${UtilInt}/100)
                	        /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                	    }
                	} else /if (${sectionName.Equal[DPS]} && ${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0 && ${${varArray}[${i}].Arg[3,|].Equal[debuffall]}) {
                	    /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                	    /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                	}
                }
                /if (${Debug}) {
					DEBUGN Loadini ${i} - ${varArray}[${i}] - ${${varArray}[${i}]} - ${Macro.Return} - ${Me.AltAbility[${Macro.Return}]} \agLine#:${Macro.CurLine}"
				}
			/if (${isBlank}) /break
			/if (${${varArray}[${i}].Equal[NULL]}) {
				|/echo LemonsDebug: ${varArray}[${i}] is ${${varArray}[${i}]}. If you see this as NULL, your section is empty in your ini but has ${varArray}Size set at a number higher or you have blank spots. We don't like blank spots.
				|/beep
			}
			/next i
			/if (${RestartFlag}) {
				/beep
				/call BroadCast r "WARNING! I need you to restart my macro because I found a blank in my ${varArray} section. Turning off the macro NOW"
				/echo \amYou should reload your MQ2Mule window by hitting the "Reload" button or typing /notify MuleWnd MULE_ReLoad_Button leftmouseup
				/end
			}
            /return
		}
	} else {
		DEBUGN Loadini: Checking to define Var !${Defined[${varName}]} && ${Defined[varType]} \agLine#:${Macro.CurLine}"
        /if (!${Defined[${varName}]} && ${Defined[varType]}) /declare ${varName} ${varType} outer 0
        |Using the varArray2 to tell if trying to find a conditional entry or not. False = conditional null = non-conditional
        /if (${varArray2.Length}==0 || ${varArray2.Equal[false]} || ${varArray2.Equal[NULL]}) {
			DEBUGN Loadini: If Ini doesn't exist !${Ini[${FileName1},${sectionName},${varName}].Length} \agLine#:${Macro.CurLine}"
            /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                /if (${varValue.Length}) {
                    /ini ${FileName1} "${sectionName}" "${varName}" "${varValue}"
                    /varset ${varName} ${varValue}
                    /if (${Debug}) {
						DEBUGN Sub LoadIni /varset ${varName} ${varValue} \agLine#:${Macro.CurLine}"
					}
                }
            } else {
				/if (${varName.Equal[TheWinTitle]}) {
                    /varset TheWinTitle ${Ini[${FileName1},${sectionName},TheWinTitle,NULL,noparse]}
					|/echo Reading wintitle from infile, it is: ${TheWinTitle}
					|dont mess with this variable anymore, just return
					/return
		    	} else /if (${varName.Equal[MezMaxLevel]} && ${Spell["${Ini[${FileName1},${sectionName},MezSpell]}"].ID}) {
					/varset ${varName} ${Spell["${Ini[${FileName1},${sectionName},MezSpell]}"].MaxLevel}
					/ini ${FileName1} "${sectionName}" "${varName}" "${Spell[${Ini[${FileName1},${sectionName},MezSpell]}].MaxLevel}"
				} else /if (${varName.Equal[PullCond]}) {
					|Parse lets us keep the actual variable stored instead of the result.
					|/echo setting PullCond ${Parse[1,${Ini[${FileName1},${sectionName},${varName}]}]}
					/varset PullCond ${Parse[1,${Ini[${IniFileName},Pull,PullCond]}]}
					DEBUGN Loadini: ${varName} ${Parse[2,${Ini[${IniFileName},Pull,PullCond]}]} \agLine#:${Macro.CurLine}"
		    	} else /if (${varName.Equal[PrePullCond]}) {
					|Parse lets us keep the actual variable stored instead of the result.
					|/echo setting PrePullCond ${Parse[2,${Ini[${FileName1},${sectionName},${varName}]}]}
					/varset PrePullCond ${Parse[1,${Ini[${IniFileName},Pull,PrePullCond]}]}
					DEBUGN Loadini: ${varName} ${Parse[1,${Ini[${IniFileName},Pull,PrePullCond]}]} \agLine#:${Macro.CurLine}"
		    	} else {
					/varset ${varName} ${Parse[2,${Ini[${FileName1},${sectionName},${varName}]}]}
					DEBUGN Loadini: ${varName} ${Parse[2,${Ini[${FileName1},${sectionName},${varName}]}]} Ini:${Ini[${FileName1},${sectionName},${varName}]} \agLine#:${Macro.CurLine}"
		    	}
            }
            /if (${FileName1.Equal[${IniFileName}]}) {
                /varset rkTemp ${${varName}}
                | find out if there is a Rank and fix spell name.
                /if (${varType.Equal[string]} && ${Int[${rkTemp.Left[1]}]}==0 && !${varName.Find[Help]}) {
                    /if (${Spell[${${varName}}].ID}) {
						/call Spell_Rk_Check "${${varName}}"
						/if (${Macro.Return.NotEqual[null]} && ${Spell[${Macro.Return}].ID}) /varset ${varName} ${Macro.Return}
					}
                }
            }
        } else /if (${Defined[ConditionsOn]}) {
            /if (${ConditionsOn}) {
                /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                    /if (${varValue.Length}) {
                        /ini ${FileName1} "${sectionName}" "${varName}" "${varValue}"
                        /varset ${varName} ${varValue}
                        DEBUGN Sub Loadini /varset ${varName} ${varValue}"
                    }
                } else {
                    /varset ${varName} ${Ini[${FileName1},${sectionName},${varName},NULL,noparse]}
                }
            } else {
                /varset ${varName} ${varValue}
            }
        } else {
            /varset ${varName} ${varValue}
        }
        /if (${Debug}) {
			DEBUGN Sub LoadIni: ${varName} - ${${varName}}"
		}
        /varset rkTemp 
    }
	DEBUGN Sub LoadIni: Leave"
	|/setchattitle Loading Ini ${sectionName}:${varName}
/return

| ----------------------------------------------------------------------------
| SUB: End Mac If
| ----------------------------------------------------------------------------
    Sub EndMacroIf
        DEBUGN EndMacroIf: Enter"
        | I died wait for rez loop
        :WaitOnRez
        /if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
        /if ((${Me.Hovering} || ${CampZone} != ${Zone.ID}) && ${RezAcceptOn} && ${IAmDead}) {
            /if (${Attacking}) /call CombatReset EndMac
            /delay 1
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CampOnDeath}) /call DoICamp
			/call Empty
            /goto :WaitOnRez
        }
        /if (!${RezAcceptOn} && ${CampZone} != ${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICamp
            /if (${IAmDead}) {
                /if (${Twist}) {
                    /twist stop
					/varset TwistStop ${Macro.CurLine}
					/if (${MuleDebug}) /echo Stopping twist \ag${Macro.CurLine}
                    /delay 3s !${Twist}
                }
                /endmac
            }
        }
		/call ClearCorpse
        DEBUGN EndMacroIf: Leave"
    /return
	
	Sub ClearCorpse
	/if (${Spawn[corpse ${Me.CleanName}].ID} && ${Spawn[corpse ${Me.CleanName}].Distance} < 15 && !${Me.HaveExpansion[call of the forsaken]} && ${Me.Buff[Resurrection Sickness].ID}) {
			/echo Trying to clear my corpse after rez
			/tar id ${Spawn[corpse ${Me.CleanName}].ID}
			/delay 1s ${Target.ID} == ${Spawn[corpse ${Me.CleanName}].ID}
			DEBUGMOVE Moveto "
			/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
			/moveto ID
			/delay 1s ${Target.Distance} < 10
			/loot
			/delay 1s ${Window[LootWnd]}
			/keypress esc
			/delay 2
			/memmyspells ${IniFileName}
			/call Empty
		}
	/return
| ----------------------------------------------------------------------------
| SUB: Do I Camp
| ----------------------------------------------------------------------------
    Sub DoICamp
        /if (!${CampOnDeath}) /return
        /if (!${CampOnDeathTimer} && ${CampZone} != ${Zone.ID} && ${Me.Buff[Revival Sickness].ID}) {		
            /echo I am dead and not where I am suppose to be. Time to camp out.
            /if (${Twist}) {
                /twist stop
				/varset TwistStop ${Macro.CurLine}
				/if (${MuleDebug}) /echo Stopping twist \ag${Macro.CurLine}
                /delay 3s !${Twist}
            }
            /docommand /camp desktop
            /delay 40s
            /endmac
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Do Bard Stuff
| ----------------------------------------------------------------------------
    Sub DoBardStuff
        /if (${Me.Class.Name.NotEqual[Bard]}) /return
		/if (${Me.Hovering}) /return
        /if (!${BardStartTwist} && !${Me.Invis}) {
            /squelch /twist stop
			/varset TwistStop ${Macro.CurLine}
			/if (${MuleDebug}) /echo Stopping twist \ag${Macro.CurLine}
            /delay 3s !${Twist}
            /if (${TwistWhat.Length} && !${TwistWhat.Find[order]}) {
				/squelch /twist ${TwistWhat}
			}
            /varset BardStartTwist 1
			/varset Twisting 0
			/echo returning from DoBardStuff because BardStartTwist is 0 \agLine#:${Macro.CurLine}
			/delay 1
            /return
        }
        /if (${Me.Invis}) {
           /if  (!${Me.Gem[${Twist.Current}].HasSPA[12]} && ${Twist}) {
				/twist stop
				/stopsong
				/varset TwistStop ${Macro.CurLine}
				/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
			}
			/if (${MuleDebug}) /echo returning from DoBardStuff because I am Invis. \agLine#:${Macro.CurLine}
            /return
        }
        /if (${Debug}) {
			DEBUGN DoBardStuff: Enter \agLine#:${Macro.CurLine}"
		}
		/if (${Twisting} && !${Twist} && ${Me.Standing} && !${bardShouldBeSitting}) {
			/echo I'm not actually twisting anything
			/varset Twisting 0
		}
		/if (!${CombatStart} && !${Twist} && ${TwistOn} && !${Twisting}) {
			|Lemons: Check and see if we managed to stop twisting with the flag in the wrong setting
			/twist ${TwistWhat}
			/varset Twisting 1
			/varset DPSTwisting 0
		}
		/if (${CombatStart} && !${Twist} && ${TwistOn} && !${DPSTwisting}) {
			|Lemons: Check and see if we managed to stop twisting with the flag in the wrong setting
			/twist ${TwistWhat}
			/varset Twisting 0
			/varset DPSTwisting 1
		}		
        /if (${MeleeTwistOn} && ${CombatStart} && !${DPSTwisting}) {
            /varset DPSTwisting 1
            /varset Twisting 0
            /if (${MeleeTwistWhat.Equal[Continuous]}) {
                /if (${Twist}) {
                    /echo == Continuing normal twist for melee \agLine#:${Macro.CurLine}
                    /return
                }
            } else {
                /squelch /twist ${MeleeTwistWhat}
            }
            /echo == Starting melee twist \agLine#:${Macro.CurLine}
        }
        /if (${TwistOn} && !${CombatStart} && !${Twisting} && !${Me.Gem[${Twist.Current}].HasSPA[12]}) {
            /varset DPSTwisting 0
            /varset Twisting 1
            /if (${MeleeTwistWhat.Equal[Continuous]} && ${Twist} && !${Select[${Twist.Current},${TwistMed}]}) {
                    /echo == Continuing normal twist \agLine#:${Macro.CurLine}
                    /return
            } else {
				/if (!${Me.Mount.ID} && !${Me.Standing}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return
					}
				}
                /squelch /twist ${TwistWhat}
                /echo == Starting normal twist ${TwistWhat} \agLine#:${Macro.CurLine}
            }
        }
        /if (!${TwistOn} && !${CombatStart}) {
				/if  (!${Me.Gem[${Twist.Current}].HasSPA[12]} && ${Twist}) {
					/twist stop
					/stopsong
					/varset TwistStop ${Macro.CurLine}
					/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
				}
		}
        /if (${Debug}) {
			DEBUGN DoBardStuff: Leave \agLine#:${Macro.CurLine}"
		}
    /return
| ----------------------------------------------------------------------------
| SUB: GroupEscape
| ----------------------------------------------------------------------------
    Sub GroupEscape
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
     /if (!${GroupEscapeOn}) /return
         DEBUGN GroupEscape Enter"
	/declare Escaped bool FALSE
         |- If (in combat) or (Have AgroID) AND (MA is not present) or (a corpse).
         /if ((${Me.CombatState.Equal[COMBAT]} || ${AggroTargetID}) && (!${Spawn[=${MainAssist}].ID} || ${Spawn[=${MainAssist}].Type.Equal[Corpse]})) {
         DEBUGN GroupEscape: CombatState:${Me.CombatState.Equal[COMBAT]} AggroTargetID:${AggroTargetID} MA Dead:!${Spawn[=${MainAssist}].ID}|${Spawn[=${MainAssist}].Type.Equal[Corpse]}"
         /echo + The MA is dead and I'm in combat, activating Group Escape!
         /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                 |-- Druid AA or Spell group evac casting.
                 /if (${Select[${Me.Class.ShortName},DRU]}) {
                     |- Drop Divine Barrier if it is up so we can exodus group!
                     /removebuff Divine Barrier
                     /if (${Me.AltAbilityReady[Exodus]}) {
						 /call BCTExec all "/camphere off"
                         /call CastWhat "Exodus" ${Me.ID} GroupEscape
                     } else /if (${Me.Book[Succor]}) {
						 /call BCTExec all "/camphere off"
                         /call CastWhat "Succor" ${Me.ID} GroupEscape
                     } else /if (${Me.Book[Lesser Succor]}) {
						 /call BCTExec all "/camphere off"
                         /call CastWhat "Lesser Succor" ${Me.ID} GroupEscape
                     }
                 }
                 |-- Wizard AA or Spell group evac casting.
                 /if (${Select[${Me.Class.ShortName},WIZ]}) {
                     /if (${Me.AltAbilityReady[Exodus]}) {
						 /call BCTExec all "/camphere off"
                         /call CastWhat "Exodus" ${Me.ID} GroupEscape
                     } else /if (${Me.Book[Evacuate]}) {
						 /call BCTExec all "/camphere off"
                         /call CastWhat "Evacuate" ${Me.ID} GroupEscape
                     } else /if (${Me.Book[Lesser Evacuate]}) {
						 /call BCTExec all "/camphere off"
                         /call CastWhat "Lesser Evacuate" ${Me.ID} GroupEscape
                     }
                 }
             }
			/varset Escaped TRUE
         }
         DEBUGN GroupEscape Leave"
    /return ${Escaped}

Sub GetGroupMage
	/declare i int local 0
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Pet.ID} && ${Group.Member[${i}].Type.Equal[PC]} && ${Group.Member[${i}].Class.ShortName.Equal[MAG]}) {
			/return ${i}
		}
	/next i
/return 7
| ----------------------------------------------------------------------------
| SUB: CheckHealth
| ----------------------------------------------------------------------------
    Sub CheckHealth
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
		/if (${OhShitOn}) {
			/call OhShitStuff "CheckHealth"
		}
		/if (${CallCustomFunc}) {
			/call CustomFunc "${CustomFuncName}"
		}
        /if (!${HealsOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        DEBUGHEALS  CheckHealth Enter \agLine#:${Macro.CurLine}"
		
        /declare i                  int         local       0
        /declare MostHurtName       string      local
        /declare MostHurtType       string      local
        /declare MostHurtID         int         local       0
        /declare MostHurtHP         int         local       100
        /declare MostHurtNo         int         local       0
		/declare MAGOwnerNum int local 0
        :CheckAgain
        /varset HealAgain    0
        | Check self health
        /if (${Me.PctHPs} <= ${SingleHealPoint}) {
			/call SingleHeal "${Me}" PC ${Me.PctHPs} 0 ${Me.ID}
		}
        | Call MA health check for only those that can heal others
        /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,RNG,PAL]}) {
			/call GetHostilesOnXTarget
			/if (${Macro.Return} > 0) {
				/if (${Me.Class.ShortName.Equal[CLR]} && ${ReturnToCamp}==0 && ${ChaseAssist}) {
					/if (${Me.Aura[Aura of Divinity].ID}) {
						/if (${Spawn[=${MainAssist}].ID}!=${Me.ID}) {
							/if (${Spawn[=${MainAssist}].Distance3D} < 200 && ${Spawn[=${MainAssist}].Distance3D} > 50) {
								/if (${Spawn[${Me.GroupAssistTarget.ID}].Type.Equal[NPC]} && !${Me.Rooted.ID}) {
									/call BCTExec ${MainAssist} "/popup moving closer so you can get some more hps from aura of divinity."
									/nav spawn id ${Spawn[=${MainAssist}].ID} | dist=40
									/delay 5 ${Navigation.Active}==TRUE
									/delay 4s ${Navigation.Active}==FALSE
								}
							}
						}
					}
				}
			}
            | This is to target Main Assist out of group if class can heal
			/if (${Select[${HealsOn},1,3]}) {
				/if (${Spawn[=${MainAssist}].ID}!=${Me.ID}) {
					/if (${Spawn[=${MainAssist} ${MainAssistType}].ID}) {
						| Skip targeting tank if MA is defined to watch for heals in XTarget. Targets the MainAssist if they're out of group and not part of the XTar list. 
							|Lemons: Should just set a flag to note whether the MainAssist is listed in XTarget Healing or not. Call it MainAssistXTar
							/if (!${XTarHeal} || (${XTarHeal} && !${MainAssistXTar})) {
								/if (${Target.ID}!=${Spawn[=${MainAssist} ${MainAssistType}].ID}) {
									|Lemons: This was causing it to spam between the kill target and tank on inc. I don't know what the point of this is atm since you can use Spawn to check for HP, so I'm commenting it out. 
									|It's probably to target a tank if you don't have them in the XTarget list. But that would still cause it to spam, so leaving it out. 
									|/if (${MuleDebug}) /echo Targetin at\agLine#:${Macro.CurLine}
									|/target id ${Spawn[=${MainAssist} ${MainAssistType}].ID}
									|/delay 10 ${Target.ID}==${Spawn[=${MainAssist} ${MainAssistType}].ID}
								}
							}
						DEBUGHEALS CheckHealth:  Tank OOG: ${Spawn[=${MainAssist}].PctHPs} ${Spawn[=${MainAssist} ${MainAssistType}].ID}  ${Spawn[=${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} \agLine#:${Macro.CurLine}"
						
						/if (${Spawn[=${MainAssist} ${MainAssistType}].PctHPs} < 100) {
							/call SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[=${MainAssist} ${MainAssistType}].PctHPs} 0 ${MainAssistID}
						}
					}
				}
			}
			/if (${AutoRezOn}) {
				/if (!${Spawn[=${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
			}
			| Who is the most hurt
            /if (${Select[${HealsOn},1,2]} && ${Group} && !${JustZoned} && !${JoinedParty}) {
                /varset MostHurtName
                /varset MostHurtType
                /varset MostHurtID
                /varset MostHurtHP 100
                /varset MostHurtNo 0
                /for i 0 to ${Group}
                    /if (${HealsOn}==2) {
						/if (${Select[${Spawn[=${MainAssist} ${MainAssistType}].ID},${Group.Member[${i}].ID},${Group.Member[${i}].Pet.ID}]}>0) /continue
					}
                    /if (${Group} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].PctHPs}>=1) {
						DEBUGHEALS CheckHealth:  -- Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP} \agLine#:${Macro.CurLine}"
                        
						/if (${Group.Member[${i}].PctHPs} <= ${MostHurtHP}) {
                            /varset MostHurtName ${Group.Member[${i}].CleanName}
                            /varset MostHurtType ${Group.Member[${i}].Type}
                            /varset MostHurtID ${Group.Member[${i}].ID}
                            /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                            /varset MostHurtNo ${i}
                        }
                        /if (${HealGroupPetsOn}) {
							/if (${Select[${Group.Member[${i}].Class.Name},cleric,wizard]}==0 && ${Group.Member[${i}].Pet.ID}>0 && ${Group.Member[${i}].Pet.PctHPs} <= ${MostHurtHP}) {
								/varset MostHurtName ${Group.Member[${i}].Pet.CleanName}
								/varset MostHurtType Pet
								/varset MostHurtID ${Group.Member[${i}].Pet.ID}
								/varset MostHurtHP ${Group.Member[${i}].Pet.PctHPs}
								/varcalc MostHurtNo ${i}+8
							}
                        }
                    }
                /next i
                DEBUGHEALS CheckHealth: (${MostHurtHP} <= ${SingleHealPoint}) /call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} ${MostHurtID} \agLine#:${Macro.CurLine}"
                
				/if (${MostHurtHP} <= ${SingleHealPoint}) {
					/call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} ${MostHurtID}
				}
            }
        }
        | Rez tank check
        /if (${AutoRezOn}) {
		/if (!${Spawn[=${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
	}
        | Group Heal Check only call for those classes that can group heal
        /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) {
            | Check for group heals
            /if (${Group}) {
				/call DoGroupHealStuff ${Group.AvgHPs}
			}
        }
        | Rez tank check
        /if (${AutoRezOn}) {
			/if (!${Spawn[=${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
		}
        | Check xtarget health if on.
        /if (${Int[${XTarHeal}]}) {
			DEBUGHEALS CheckHealth: SingleHeal XTarget Gonna iterate through all listed XTarget list ${Math.Calc[${XTarHeal.Count[|]} + 1]}, ${XTarHeal.Count[|]}"
			/for i 1 to ${Math.Calc[${XTarHeal.Count[|]} + 1]}
				DEBUGHEALS CheckHealth: SingleHeal XTarget#${i} which is ${XTarHeal.Arg[${i},|]}"
				/if (${Select[${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].Type},PC,Mercenary,Pet]}) {
					/if (${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID} && ${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].PctHPs} <= ${SingleHealPoint}) {
						/call SingleHeal "${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].CleanName}" "${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].Type}" ${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].PctHPs} 7 ${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}
						DEBUGHEALS CheckHealth: SingleHeal XTarget ${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].CleanName}" "${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].Type}" ${Spawn[${Me.XTarget[${XTarHeal.Arg[${i},|]}].ID}].PctHPs} 7 \agLine#:${Macro.CurLine}"
						
					}
				} 
			/next i
		}
        /if (${PetOn}) {
			/if (${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100) /call DoPetHealStuff
		}
        /if (${HealAgain}) /goto :CheckAgain
        DEBUGHEALS CheckHealth leave \agLine#:${Macro.CurLine}"
        /if (${AutoRezOn}) /call RezCheck
        /call WriteDebuffs
    /return


|----------------------------------------------------------------------------
| SUB: Single Heals
|----------------------------------------------------------------------------
    Sub SingleHeal(SHealName, SHealType, int SHealHPs, int WhoNum, int TheHealID)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
		DEBUGHEALS SingleHeal Enter: \ayName: ${SHealName} TType: ${SHealType} Hps%: ${SHealHPs} WhoNum:${WhoNum} \agLine#:${Macro.CurLine}"
        /if (!${HealsOn}) /return
        /if (${Me.Moving}) /return
        /if (${Me.Hovering}) /return
        /if (!${TheHealID}) {
			DEBUGHEALS inside SingleHeal leaving cause no ID: SHealName=${SHealName} and SHealType=${SHealType}, ${TheHealID}"
			/return
		}
        /if (${Select[${SHealType},PC,Pet,Mercenary]}==0) /return
        /if (${Me.Invis} && !${AggroTargetID}) {
			/return
		}
		/doevents
        /declare i               int     local   0
        /declare HealSpell      string  local
        /declare SHealTag        string  local
       |/declare TheHealID       int     local   ${Spawn[=${SHealName} ${SHealType}].ID}
        /declare SHealRange      int     local   0
        /declare HealLoopCount   int     local   0
        /declare HealLoopTimer   timer   local   5
        | Set MA ID to 6 to keep spell durations correct
        /if (${WhoNum}!=6 && ${TheHealID}==${MainAssistID}) /varset WhoNum 6
	:NoHeal
        /varset HealAgain 0
        /varset HealLoopCount 0
        | If heal is null or off |0 or spell/aa/item not ready skip it
        /for i 1 to ${SingleHeal.Size}
			|/if (${DebugHeal}) /delay 5
			/varcalc HealLoopCount ${HealLoopCount}+1
			DEBUGHEALS SingleHeal Spell ${i}: ${SingleHeal[${i}]}  ${SingleHeal[${i}].Arg[1,|]}   ${SingleHeal[${i}].Arg[2,|]}   ${SingleHeal[${i}].Arg[3,|]} \agLine#:${Macro.CurLine}"
			DEBUGHEALS SingleHeal Skip?: !${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]} \agLine#:${Macro.CurLine}"
			/if (!${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]}) /continue
            /varset HealSpell   ${SingleHeal[${i}].Arg[1,|]}
            /varset SHealPct     ${SingleHeal[${i}].Arg[2,|]}
            /varset SHealTag     ${SingleHeal[${i}].Arg[3,|]}
            /varset SHealRange ${Spell[${HealSpell}].MyRange}
            /if (${Spell[HealSpell].TargetType.Find[Group v]}) /varset SHealRange ${Spell[${HealSpell}].AERange}
            /if (!${SHealRange}) /varset SHealRange 100

			| New Conditional Check to Skip spell
            /if (${ConditionsOn} && ${HealsCOn}) {
				DEBUGHEALS healcondition for ${i} is: ${SHCond[${i}].Replace[$,#]} HealSpell=${HealSpell} SHealTag=${SHealTag} TheHealID=${TheHealID} SHealType=${SHealType} SHealName=${SHealName} SHealHPs=${SHealHPs} WhoNum=${WhoNum} MainAssistID=${MainAssistID}\agLine#:${Macro.CurLine}"
				/if (${TheHealID}==${Me.ID}) {
					/if (${If[${SHCond[${i}]},0,1]}) {
						DEBUGHEALS HealCondition for ${HealSpell} failed 1."
						/continue
	    			}
					/if (${SHealTag.Find[buff!=]}) {
						/varset SHealTag ${SHealTag.Mid[7,400]}
						|/echo need to make sure ${SHealName} doesn't have ${SHealTag} on.
						/if (${Me.Buff[${SHealTag}].ID}) {
							|/echo HealCondition for ${HealSpell} failed 2.
							/continue
						}
					} else /if (${SHealTag.Find[buff==]}) {
						/varset SHealTag ${SHealTag.Mid[7,400]}
						|/echo need to make sure ${SHealName} does have ${SHealTag} on.
						|no need to change target I can access my own buffs
						/if (!${Me.Buff[${SHealTag}].ID}) {
							|/echo HealCondition for ${HealSpell} failed 3.
							/continue
						}
					}
				} else {
					/if (${Spawn[${TheHealID}].Distance3D} > 250) {
						|well its kinda pointless we cant cast anything that far out...
						/continue
					}
					/if (${SHCond[${i}].Find[{Target.]}) {
						/beep
						/echo Your ${SHCond[${i}].Replace[$,#]} contains "${Target" that is not a supported condition
						/noparse /echo please change it to use ${Spawn[${TheHealID}]} or something instead.
						/end
					}
					/if (${If[${SHCond[${i}]},0,1]}) {
						DEBUGHEALS HealCond${i} for ${HealSpell} ${SHCond[${i}]} on ${Spawn[${TheHealID}].Name} failed C."
						/continue
	    			} else {
						DEBUGHEALS COND${i} = ${SHCond[${i}]} its ok to cast ${HealSpell} on ${Spawn[${TheHealID}].Name}"
					}
					/if (${SHealTag.Find[buff!=]}) {
						|Timer Rework
						/target id ${TheHealID}
						/delay 1s ${Target.ID} == ${TheHealID}
						/delay 1s ${Target.BuffsPopulated}
						/varset SHealTag ${SHealTag.Mid[7,400]}
						|/echo need to make sure ${SHealName} DOES have ${SHealTag} on.
						/if (${Spell[${SHealTag}].Duration} > 0) {
							/if (${Spawn[${TheHealID}].CachedBuff[${SHealTag}].Duration} > 0) {
								|/if (${MuleDebug}) /echo HealCondition: ${Spawn[${TheHealID}].Name} already have ${HealSpell} buff, we will skip A.
								/continue
							} else {
								/if (${MuleDebug}) {
									/echo (${Target.BuffsPopulated} [${Target.CachedBuff[Savage Growth]}] | ${Target.CachedBuffCount}) SHealTag="${SHealTag}" ${Spawn[${TheHealID}].Name} DOES NOT HAVE BUFF ${HealSpell} WE WILL CAST IT.
									|/delay 2s
								}
							}
						} else {
							/if (${Spawn[${TheHealID}].CachedBuff[${SHealTag}].ID}) {
								|/if (${MuleDebug}) /echo HealCondition: ${Spawn[${TheHealID}].Name} already have ${HealSpell} buff, we will skip A.
								/continue
							} else {
								/if (${MuleDebug}) {
									/echo (${Target.BuffsPopulated} [${Target.CachedBuff[Savage Growth]}] | ${Target.CachedBuffCount}) SHealTag="${SHealTag}" ${Spawn[${TheHealID}].Name} DOES NOT HAVE BUFF ${HealSpell} WE WILL CAST IT.
									|/delay 2s
								}
							}
						}
					} 
					/if (${SHealTag.Find[buff==]}) {
						|Timer Rework
						/target id ${TheHealID}
						/delay 1s ${Target.ID} == ${TheHealID}
						/delay 1s ${Target.BuffsPopulated}
						/varset SHealTag ${SHealTag.Mid[7,400]}
						|/echo need to make sure ${SHealName} DOES NOT have ${SHealTag} on.
						/if (${Spell[${SHealTag}].Duration} > 0) {
							/if (!${Spawn[${TheHealID}].CachedBuff[${SHealTag}].Duration} > 0) {
								|/if (${MuleDebug}) /echo HealCondition: ${Spawn[${TheHealID}].Name} does NOT have ${HealSpell} buff, we will skip B.
								/continue
							}
						} else {
							/if (!${Spawn[${TheHealID}].CachedBuff[${SHealTag}].ID}) {
								|/if (${MuleDebug}) /echo HealCondition: ${Spawn[${TheHealID}].Name} does NOT have ${HealSpell} buff, we will skip B.
								/continue
							}
						}
					}
				}
			}
			|Lemons: Skipping this spell since we should only be here if the target is not myself and the spell is tagged with |Me. 
			/if (${SHealTag.Find[Me]} && ${Me.ID} != ${TheHealID}) {
				DEBUGHEALS Me heal spell and I'm targeting ${Target}"
				/continue
			}
            | Skip Heal if pet 
            /if (${Spawn[${TheHealID}].Type.NotEqual[Pet]} && ${SHealTag.Equal[pet]}) {
				DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because he is not a Pet and the tag says Pet 1"
				/continue
			}
            | Skip Heal if !pet 
            /if (${Spawn[${TheHealID}].Type.Equal[Pet]} && ${SHealTag.Equal[!pet]}) {
				DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because he is a Pet and the tag says !Pet 1"
				/continue
			}
			| If tag MA/Mob and heal target not MA or tag !MA and heal target MA skip
			/if (${TheHealID} != ${Spawn[=${MainAssist}].ID}) {
				/if (${HealGroupPetsOn}) {
					/if (${SHealTag.Equal[pet]} && ${Spawn[${TheHealID}].Type.NotEqual[pet]}) {
						DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because he is not a Pet and the tag says Pet 2"
						/continue
					}
				} else {
					/if (${SHealTag.Equal[pet]}) {
						DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because it is a pet and HealGroupPetsOn = 0"
						/continue
					}
				}
				/if (${SHealTag.Equal[Mob]} && ${Spawn[${TheHealID}].Type.NotEqual[NPC]}) {
					DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because he is not a NPC and the tag says Mob"
					/continue
				}
 				/if (${SHealTag.Equal[MA]}) {
					DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because he is not MA and the tag says MA"
					/continue
				}
			} else {
				/if (${SHealTag.Equal[!MA]}) {
					DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because it's MA"
					/continue
				}
			}
			DEBUGHEALS SingleHeal SHealTag.Equal[MA]: ${SHealTag.Equal[MA]} TheHealID = ${TheHealID} MainAssistID = ${MainAssistID} || ${SHealTag.Equal[Mob]} && ${TheHealID}!=${MainAssistID} || ${SHealTag.Equal[!MA]} && ${TheHealID}==${MainAssistID}"
			| Cleric Divine Arbitration and Epics do not work on pets or people out of group
			/if (${Spawn[${TheHealID}].Type.Equal[Pet]}) {
				/if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Divine Arbitration]}) {
					DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because it's a pet"
					/continue
				}
			}
			/if (!${Spawn[${SHealName} ${SHealType} group].ID}) {
				/if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Divine Arbitration]}) {
					DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because he is not in the group"
					/continue
				}
			}
			| intervention and survival lines only work on group members
			/if (!${Spawn[${SHealName} ${SHealType} group].ID}) {
				/if (${Select[${Me.Class.Name},Druid,Shaman]}) {
					/if (${HealSpell.Find[Intervention]} || ${HealSpell.Find[Survival]}) {
						DEBUGHEALS skipping healing ${SHealName} with ${HealSpell} because its a non grouped guy"
						/continue
					}
				}
			}
			| Check For Life Taps
			/if (${SHealTag.Find[Tap]}) {
				/if (!${Pulled} && ${CombatStart} && ${Me.PctHPs} <= ${SHealPct} && ${Target.Type.NotEqual[Corpse]} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance} <= ${SHealRange} && ${Spell${i}GM0}==0) {
					/if (${Me.Book[${HealSpell}]} || ${Me.AltAbilityReady[${HealSpell}]} || ${Me.CombatAbilityReady[${HealSpell}]}) {
						/call CastWhat "${HealSpell}" ${Spawn[${MyTargetID}].ID} SingleHeal
					} else {
						DEBUGHEALS ${HealSpell} not ready 1."
						/continue
					}
					/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
						/call BroadCast o "${HealSpell} for >> ${Me.CleanName} << 1"
						/varcalc Spell${i}GM0 (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod})*10
						DEBUGHEALS SingleHeal Assign Timer:Spell${i}GM0 (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod}) ${Spell${i}GM0} \agLine#:${Macro.CurLine}"
						/return
					} else {
						/if (${Macro.Return.Equal[CAST_CANCELLED]}) /return
					}
				} else {
					|/echo Skipping ${HealSpell} shit shit!
					/continue
				}
			} else /if (${SHealTag.Find[Mob]}) {
				| Check For Nuke Heals - contibuted by thenomadman
				/if (!${AggroTargetID}) {
					/if (${MuleDebug}) /echo Skipping ${HealSpell} due to no AggroTargetID
					/continue
				}
				/doevents Switch
				/if (${DPSOn} || ${MeleeOn}) {
					/if (!${MyTargetID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]}) /call Assist Heals
				}
				/if (${MyTargetID} && ${Spawn[=${MainAssist}].PctHPs}<=${SHealPct} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance}<=${SHealRange} && !${Spawn[${MyTargetID}].Type.Equal[Corpse]}) {
					/varset HealAgain 2
					/if (${Me.Book[${HealSpell}]} || ${Me.AltAbilityReady[${HealSpell}]} || ${Me.CombatAbilityReady[${HealSpell}]}) {
						/call CastWhat "${HealSpell}" ${Spawn[${MyTargetID}].ID} SingleHeal
					} else {
						/continue
					}
					/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
						/call BroadCast o "${HealSpell} for >>${Spawn[${SHealName} ${SHealType}].CleanName} << cast on ${Spawn[${MyTargetID}].CleanName}"
						/varset HealAgain 1
						/return
					} else {
						/if (${Macro.Return.Equal[CAST_CANCELLED]}) /return
					}
				} else {
					/if (${MuleDebug}) /echo Skipping ${HealSpell} due to a mistake.
					/continue
				}
			}
			| Check conditons for heals
			DEBUGHEALS SingleHeal \aw${SHealHPs} <= ${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0 \agLine#:${Macro.CurLine}"
			/if (${SHealHPs} <= ${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0 && (${Me.Book[${HealSpell}]} || ${Me.AltAbilityReady[${HealSpell}]} || ${Me.CombatAbilityReady[${HealSpell}]})) {
				DEBUGHEALS SingleHeal \aw${SHealHPs} <= ${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0 \agLine#:${Macro.CurLine}"
				| target has qualified for a heal
				/varset HealAgain 2
				/if (${Spell[${HealSpell}].TargetType.Equal[Free Target]}) {
					| Check if spalsh heal target is in line of sight
					/if (${Target.ID}!=${TheHealID}) {
						/if (${MuleDebug}) /echo Targeting a mob 14c: ${TheHealID}
						/target id ${TheHealID}
						/delay 2s ${Target.ID}==${TheHealID}
					}
					/if (!${Target.CanSplashLand}) {
						/if (${MuleDebug}) /echo Splash Spell will NOT land on target. Skipping.
						/continue
					}
				}
				/if (${Select[${EverQuest.Server},zek]}) {
					/if (${Select[${Target.Type},PC]} && ${Me.Combat}) {
						/attack off
						/delay 25 !${Me.Combat}
					}
				}
				/if (${TheHealID}==${MainAssistID}) {
					/if (${Spawn[=${MainAssist} ${MainAssistType}].ID} && ${Me.Buff[Divine Barrier]}) /removebuff Divine Barrier
				}
				/if (${Math.Calc[${Spell[${HealSpell}].Mana} + 20]} > ${Me.CurrentMana}) {
					/continue
				}
				/if (${Select[${Role},Hunter,tank,pullertank]} && ${Me.CombatState.Equal[Combat]} && !${Me.Gem[${HealSpell}]}) {
					DEBUGHEALS I'm the tank and I don't have ${HealSpell} memmed. Moving on to next spell."
					/continue
				}
				DEBUGHEALS healing (ID) ${Spawn[${TheHealID}]} with ${HealSpell}"
				/if (!${Me.SpellInCooldown} && ${Me.SpellReady[${HealSpell}]}) /call BroadCast o "${HealSpell} on >> ${Spawn[${SHealName} ${SHealType}].CleanName} <<"
				/call CastWhat "${HealSpell}" ${TheHealID} SingleHeal
				DEBUGHEALS SingleHeal \awMR: ${Macro.Return} \agLine#:${Macro.CurLine}"
				/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
					|/call BroadCast o "${HealSpell} on >> ${Spawn[${SHealName} ${SHealType}].CleanName} << 2"
					/varcalc Spell${i}GM${WhoNum} (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod})*10
					/if (${HealSpell.Find[Promised]}) {
						/varset Spell${i}GM${WhoNum} 240
						|/echo LemonsDebug: It's a promised spell. Setting Spell${i}GM${WhoNum} to ${Spell${i}GM${WhoNum}}
					}   
					DEBUGHEALS SingleHeal Assign Timer:Spell${i}GM${WhoNum} ${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod} ${Spell${i}GM${WhoNum}} Line#:${Macro.CurLine}"
					| Prioritize heals by setting flag to check Health again
					/varset HealAgain 1
					/return
				} else {
					/if (${Macro.Return.Equal[CAST_CANCELLED]}) {
						/return
					}
				}
			}
        /next i
        | if target qualified for a heal but did not recieve one due to cooldown etc try to heal again. Release after 3s
        /if (${HealAgain}==2) {
			/if (${SingleHeal.Size}==${HealLoopCount} && ${HealLoopTimer}) /goto :NoHeal
		}
		DEBUGHEALS \aySingleHeal Leave \agLine#:${Macro.CurLine}"
        /varset HealAgain 0
    /return    
| ----------------------------------------------------------------------------
| SUB: Do Group Heal Stuff
| ----------------------------------------------------------------------------
Sub DoGroupHealStuff(int GroupHealth)
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
	DEBUGHEALS DoGroupHealStuff Enter ${GroupHealth} \agLine#:${Macro.CurLine}"
    /doevents
    /declare j              int     local
    /declare HealSpell      string  local
    /declare TheHealID      int     local ${Me.ID}   
    /declare HealPct        string  local
    /for j 1 to ${GroupHeal.Size}
        /if (!${Heals[${j}].Length} || ${Heals[${j}].Arg[2,|].Equal[0]}) {
		|/if (${MuleDebug}) /echo returning in DoGroupHealStuff due to Heals[${j}].Length = ${Heals[${j}].Length} or Heals[${j}].Arg[2,|].Equal[0] = ${Heals[${j}].Arg[2,|].Equal[0]}
		/return
	}
        /varset HealSpell   ${GroupHeal[${j}].Arg[1,|]}
        /varset HealPct     ${GroupHeal[${j}].Arg[2,|]}
		DEBUGHEALS DoGroupHealStuff ${HealSpell} ${HealPct} \agLine#:${Macro.CurLine}"
		DEBUGHEALS DoGroupHealStuff Group Heal Spell/Item:${Spell[${HealSpell}].TargetType.Find[group v]}/${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} Spell:${HealSpell} GpAvg:${GroupHealth} HealAt:${HealPct} Timer:${SpellGH${j}}==0 \agLine#:${Macro.CurLine}"
	/if (${ConditionsOn} && ${HealsCOn}) {
		|ok both global and local is ON so we check the condition...
		/if (${If[${GHCond[${j}]},0,1]}) {
			|/echo [Condition: ${j}] well the condition for ${HealSpell}|${HealPct} -> ${GHCond[${j}].Replace[$,#]} <-> ${SpellGH${j}} <-> ${GHCond[${j}]} returned FALSE... so we should NOT moveon...
			/continue
		}
		|else {
		|	/echo [Condition: ${j}] well the condition for ${HealSpell}|${HealPct} -> ${GHCond[${j}].Replace[$,#]} <-> ${SpellGH${j}} <-> ${GHCond[${j}]} returned TRUE... so we SHOULD moveon...
		|}
	}
            /if (${GroupHealth}<=${HealPct} && ${SpellGH${j}}==0 && ${Group}) {
                /call CastWhat "${HealSpell}" ${Me.ID} GroupHeal
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    DEBUGHEALS DoGroupHealStuff ${HealSpell} on  >> Group << \agLine#:${Macro.CurLine}"
                    /call BroadCast o "${HealSpell} on  >> Group <<"
                    /varcalc SpellGH${j} (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod})*10
                    DEBUGHEALS DoGroupHealStuff Assign Timer:SpellGH${j} (${Spell[${HealSpell}].Duration}*${DurationMod}.TotalSeconds) ${SpellGH${j}} \agLine#:${Macro.CurLine}"
                    /varset HealAgain    1
                    /return
                }
            }
    /next j
    DEBUGHEALS DoGroupHealStuff Leave \agLine#:${Macro.CurLine}"
/return
| -------------------------------------------------------------------------------------
| SUB: DoPetHealStuff
| -------------------------------------------------------------------------------------
    Sub DoPetHealStuff
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        | Check if my pet needs healing
        /if (!${Me.Pet.ID}) /return
        DEBUGPET DoPetHealStuff Enter \agLine#:${Macro.CurLine}"
        /declare j int local
        /for j 1 to ${SingleHeal.Size}
            /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /goto :NextPetHeal
            /if (${Me.Pet.PctHPs}<=${SingleHeal[${j}].Arg[2,|]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].MyRange}) {
					DEBUGPET DoPetHealStuff (${SingleHeal[${j}].Arg[3,|].Find[PET]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].MyRange}) \agLine#:${Macro.CurLine}"
			   /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Heal
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast o "${SingleHeal[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                    /varcalc PetHealTimer${j} (${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration.TotalSeconds}*${DurationMod})*10
                    /varset HealAgain    1
                }
            }
            :NextPetHeal
        /next j
        DEBUGPET DoPetHealStuff Leave \agLine#:${Macro.CurLine}"
    /return

| -------------------------------------------------------------------------------------
| SUB: Rez Check
| -------------------------------------------------------------------------------------
    Sub RezCheck
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}	
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
    | Don't rez if AutoRezOn=0.  AutoRezOn=1 dmzone not instanced like pok, hovering, invis and no aggro, AutoRezOn=2 and aggro(rez after combat setting)
    /if (!${AutoRezOn}) /return
    |/if (${DMZ} && ${Me.InInstance}==FALSE) /return
    /if (${Me.Hovering}) /return
    /if (${Me.Invis} && !${AggroTargetID}) /return
    /if (${AutoRezOn}==2 && ${AggroTargetID}) /return
    DEBUGHEALS RezCheck Enter \agLine#:${Macro.CurLine}"
    /declare i int local 0
    /declare j int local 0
	/declare r int local 0
    /declare CorpseCount int local
    /declare RezMeID int local 
    /declare RezID int local
    /declare RezRadius int local 150
	/declare XTarRez bool local FALSE
    | Does Group Member have a corpse?
    /for i 1 to ${Group}
        DEBUGHEALS RezCheck BattleTimer:${BattleRezTimer${i}}==0 && CorpseDistance:${Spawn[${Group.Member[${i}]} corpse].Distance}<${RezRadius} CorpseID:${Spawn[${Group.Member[${i}]} pccorpse].ID}  AutoRez Ready(!${Me.SpellReady[${AutoRezWith}]} && !${Me.AltAbilityReady[${AutoRezWith}]} && !${Me.ItemReady[=${AutoRezWith}]}) \agLine#:${Macro.CurLine}"
        /if (!${Spawn[${Group.Member[${i}]} pccorpse].ID}) /continue
		/if (!${Me.SpellReady[${AutoRezWith}]} && !${Me.AltAbilityReady[${AutoRezWith}]} && !${Me.ItemReady[=${AutoRezWith}]}) /continue
		/if (${AutoRezWith.Find[Call of]} && ${Group.Member[${i}].OtherZone}==FALSE) /continue
        | Check for group member corpses and battle rez
        /if (${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}]} corpse].Distance} < ${RezRadius}) {
			/if (${MuleDebug}) /echo Targeting a mob 15o
            /if (${Target.Distance} < 100 && ${Me.CurrentMana} > ${Spell[${AutoRezWith}].Mana}) {
				/squelch /target id ${Spawn[${Group.Member[${i}]} corpse].ID}
				/delay 10 ${Target.ID}==${Spawn[${Group.Member[${i}]} corpse].ID}
				/corpse
				/delay 2
				/if (${Me.Invulnerable.ID}) {
					/call BroadCast o "I'M INVULNERABLE !!!"
					/removebuff ${Me.Invulnerable}
					/delay 5 !${Me.Invulnerable.ID}
				}
                /call CastWhat "${AutoRezWith}" ${Target.ID}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast o "BATTLE REZZED =>> ${Group.Member[${i}]} <<="
                    /varset BattleRezTimer${i} 3m
					/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
                    /squelch /target clear
                    /if (${AutoRezWith.Find[Call of]}) /varset BattleRezTimer${i} 6m
                } else {
                    /if (${Group.Member[${i}].Name.NotEqual[${MainAssist}]}) /varset BattleRezTimer${i} 1m
                }
            }
        }
        :NextChar
    /next i
	| Do I have a Corpse
    /varset RezMeID ${Spawn[corpse ${Me} radius ${RezRadius} zradius 50].ID}
    /if (${RezMeID}) {
		DEBUGHEALS RezMeID"
    	/if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0

		/if (${OOCRezTimer${RezMeID}}==0 && (${Me.SpellReady[${AutoRezWith}]} || ${Me.AltAbilityReady[${AutoRezWith}]} || ${Me.ItemReady[=${AutoRezWith}]})) {
			/if (${MuleDebug}) /echo Targeting a mob 14d: ${RezMeID}
        	/target id ${RezMeID}
        	/delay 1s ${Target.ID}==${RezMeID}
        	/if (${Target.Distance}>${CampRadius}) /corpse
        	|delayremove/delay 1
        	/call  CastWhat "${AutoRezWith}" ${Target.ID}
        	/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            		/varset OOCRezTimer${RezMeID} 3m
            		/if (${SpawnCount[corpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && ${Zone.Outdoor}) {
				|/echo time to get a mount up! Zone.Outdoor is ${Zone.Outdoor}
				/call CastMount
	    		}
			}
    	}
    }
    | Out of Combat Rez | 
    /varset CorpseCount ${SpawnCount[corpse radius ${RezRadius} zradius 50]}
	DEBUGHEALS CorpseCount is ${CorpseCount} CombatStart ${CombatStart}"
    /if (${CorpseCount}>0 && !${CombatStart}) {
        /for j 1 to ${CorpseCount}
            /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
			/if (${Spell[${AutoRezWith}].ID} && ${Spell[${AutoRezWith}].Mana} >= ${Me.CurrentMana}) /goto :NextCorpse
            /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
		/if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
		/if (${Int[${XTarHeal}]}) {
			/for r 1 to ${Math.Calc[${XTarHeal.Count[|]} + 1]}
				/if (${RezID} == ${Me.XTarget[${XTarHeal.Arg[${r},|]}].ID}) {
					/varset XTarRez TRUE
					/if (${DebugHeal}) /echo This is someone on my XTar list, I should rez them!\agLine#:${Macro.CurLine}
					/break
				}
			/next r
			}
		DEBUGHEALS ${Spawn[${RezID}].CleanName.Left[-9]}"
		DEBUGHEALS Check general rez (${OOCRezTimer${RezID}}==0 && (${Me.SpellReady[${AutoRezWith}]} || ${Me.AltAbilityReady[${AutoRezWith}]} || ${Me.ItemReady[=${AutoRezWith}]}) && ((${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} || ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID}) || ${XTarRez} || ${Raid.Member[${Spawn[${RezID}].CleanName.Left[-9]}].ID}))"
		/if (${OOCRezTimer${RezID}}==0 && ((${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} || ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID}) || ${XTarRez} || ${Raid.Member[${Spawn[${RezID}].CleanName.Left[-9]}].Level})) {
			| If call of wild and toon in zone skip
			/if (${AutoRezWith.Find[Call of]} && ${Spawn[pc ${Spawn[${RezID}].CleanName.Left[-9]} ].ID}) /goto :NextCorpse
                	/if (${Spawn[${RezID}].Distance}<=${RezRadius}) {
						/if (${MuleDebug}) /echo Targeting a mob 145: ${RezMeID}
						/target id ${RezID}
						/delay 10 ${Target.ID}==${RezID}
						DEBUGHEALS Calling CastWhat Rez CastWhat "${AutoRezWith}" ${Target.ID}"
                    		/call  CastWhat "${AutoRezWith}" ${Target.ID}
                    		/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        		/call BroadCast o "Rezzing =>> ${Target.CleanName} <<="
                        		/varset OOCRezTimer${RezID} 5m
                        		/delay 30 !${Me.Casting.ID}
								/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
                        		/squelch /target clear
                    		}
                	}
            	}
	    }
        :NextCorpse
        /next j
    }
    DEBUGHEALS RezCheck Leave \agLine#:${Macro.CurLine}"
/Return
| -------------------------------------------------------------------------------------
| SUB: Loot Stuff
| -------------------------------------------------------------------------------------
    Sub LootStuff
        /if (!${LootOn} || (!${Me.UseAdvancedLooting} && ${AggroTargetID}) || (${MainAssist.Equal[${Me}]} && ${AggroTargetID}) || (${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Invis}) /return
        DEBUGN LootStuff: Enter"
        /if (${Me.FreeInventory}==0) {
            /echo Inventory is full. Looting OFF
            /varset LootOn 0
            /return
        }
        /doevents
        /if (${Me.UseAdvancedLooting}) {
            /call UseAdvLoot
        } else {
            /call LootMobs
        }
        /call DoWeMove "LootStuff"
        DEBUGN LootStuff: Leave"
    /return

| -------------------------------------------------------------------------------------
|   Sub ClearXTarget - To fix EQ and MQ2XAssist problems
| -------------------------------------------------------------------------------------
    Sub ClearXTarget(string calledfrom)
		|Lemons 10/30/21 Disabling due to complaints. I'm sure the bug will be more agreeable. 
		/return
		/if (${Me.CombatState.Equal[COMBAT]}) /return
		/declare i int local
		/for i 1 to ${Me.XTargetSlots}
			/if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].ID} && !${SpawnCount[npc radius ${CampRadius}]} && (${Math.Calc[${SpawnCount[group radius ${CampRadius}]}-1]} == ${Group} || !${Group})) {
				/echo Clearing XTarget slot ${i} cause it might be stuck on ${Me.XTarget[${i}]}
				DEBUGN ClearXTarget: Clearing XTarget slot ${i} cause it might be stuck on ${Me.XTarget[${i}]}"
				/xtarget set ${i} autohater
				/if (${Me.Pet.ID}) {
					/pet back
					/pet hold
				}
			}
		/next i
	/varset XTarClearTimer ${XTarClearTimer.OriginalValue}
	/return
| -------------------------------------------------------------------------------------
|   Sub MobRadar
| -------------------------------------------------------------------------------------
    Sub MobRadar(int CountRadius,string calledfrom)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
		/if (!${XTarClearTimer} && ${Me.XTarget} && ${Me.CombatState.NotEqual[COMBAT]}) {
			DEBUGN MobRadar: Calling XTarget clear cause the timer is up and I have something on my radar !${XTarClearTimer} && ${Me.XTarget} && ${Me.CombatState.NotEqual[COMBAT]}"
			/call ClearXTarget
		}
        DEBUGN MobRadar ${CountRadius} Enter (${calledfrom})"
        /declare NMob int local
        /declare i int local 0
		|/call MuleSpew "${Macro.CurSub}" "${Macro.CurLine}" "Setting MobCount to ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]}"
		DEBUGTARGETCHOICE MobCount to ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]} with ${Me.XTarget} on XTar" 
		/varset MobCount ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]}
        /for i 1 to ${MobCount}
            /varset NMob ${NearestSpawn[${i},npc targetable los radius ${CountRadius} zradius 50 noalert 3].ID}
            /if (${i}>13) /goto :ArrayExceed
            /if (${NMob} && (${Spawn[${NMob}].Type.Equal[Corpse]} || !${Spawn[${NMob}].ID})) /call RemoveFromArray AddsArray ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}
            /if (${MobCount}>0 && ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}==0) /call AddToArray AddsArray ${NMob}
            :ArrayExceed
       /next i
        | Check if NPC Pet is on Xtarget
		/for i 1 to ${Me.XTargetSlots}
			DEBUGTARGETCHOICE MobCount:${MobCount} XTar${i}:${Me.XTarget[${i}].ID} Autohater?:${Me.XTarget[${i}].TargetType.Equal[Auto Hater]}"
			/if (!${MobCount}) {
				/if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]}) {
					DEBUGTARGETCHOICE MobRadar MobCount=0 but Mob on Xtarget Setting Mobcount to 1"
					/varset MobCount 1
				}
			}  
		/next i
        DEBUGN MobRadar Leave MobCount:${MobCount}"
    /return
| -------------------------------------------------------------------------------------
|   Sub MezRadar
| -------------------------------------------------------------------------------------
    Sub MezRadar
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        DEBUGMEZ MezRadar Enter \agLine#:${Macro.CurLine}"
        /declare NMMob int local 0
        /declare i int local 0
        /varset MezMobCount 0
        /varset MezMobAECount 0
        /varset MezAEClosest 0
        /for i 1 to ${Me.XTargetSlots}
			DEBUGMEZ MezRadar:  i:${i} Xtar:${Me.XTarget[${i}].ID} && Auto:${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && NPC or Pet:${Me.XTarget[${i}].Type.Equal[NPC]} || ${Me.XTarget[${i}].Type.Equal[PET]}  \agLine#:${Macro.CurLine}
            /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && (${Me.XTarget[${i}].Type.Equal[NPC]} || ${Me.XTarget[${i}].Type.Equal[PET]})) {
                /varset NMMob ${Me.XTarget[${i}].ID}
                /varcalc MezMobCount ${MezMobCount}+1 
                | Setup closest mob for AE mez target necros can't aemez
                /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
                    /if (!${MezAEClosest} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${MezAEClosest} && ${Spawn[${NMMob}].Distance}<${Spawn[${MezAEClosest}].Distance} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${Spawn[${NMMob}].Distance}<=${MezRadius}) /varcalc MezMobAECount ${MezMobAECount}+1 
                }
                DEBUGMEZ MezRadar: MezMobCount ${MezMobCount} MobID is: ${NMMob}, XTarget${i} which is ${Me.XTarget[${i}]} \agLine#:${Macro.CurLine}
				|/if (${DebugMez}) /echo \atDEBUG MezRadar: Checking if ${NMMob} is a corpse or doesn't exist: (${Spawn[${NMMob}].Type.Equal[Corpse]} || !${Spawn[${NMMob}].ID}) \agLine#:${Macro.CurLine}
                |/if (${NMMob} && (${Spawn[${NMMob}].Type.Equal[Corpse]} || !${Spawn[${NMMob}].ID})) /call RemoveFromArray MezArray ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}
                DEBUGMEZ MezRadar: Going to check if I should add the mob to the mez list: ${MezMobCount}>0 && ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}==0 which is ${MezArray[${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]},3]}) \agLine#:${Macro.CurLine}"
				/if (${MezMobCount}>0 && ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}==0) {
                    DEBUGMEZ MezRadar: ADDING -> Name: ${Spawn[${NMMob}].Name} ID: ${NMMob} to mezlist at position ${i}? \agLine#:${Macro.CurLine}
                    /call AddToArray MezArray ${NMMob} 
                }
                /varset NMMob 0
            }
		|Lemons: This checks all mez entries and removes them if they're stale. Probably can remove the targeted one up above. Will test by commenting it out first. 
		DEBUGMEZ MezRadar: Checking if we need to cleanup the array by removing #${i} ${MezArray[${i},1]}: !${Spawn[${MezArray[${i},1]}].ID} && !${MezArray[${i},3].Equal[NULL]}) || ${Spawn[${MezArray[${i},1]}].Type.Equal[CORPSE]} \agLine#:${Macro.CurLine}"
		/if ((!${Spawn[${MezArray[${i},1]}].ID} && !${MezArray[${i},3].Equal[NULL]}) || ${Spawn[${MezArray[${i},1]}].Type.Equal[CORPSE]} || (!${Spawn[${MezArray[${i},1]}].Aggressive} && (!${Spawn[${MezArray[${i},1]}].CachedBuff[${MezSpell}].ID} && !${Spawn[${MezArray[${i},1]}].CachedBuff[${MezAESpell}].ID}))) {
			DEBUGMEZ Removing Array entry ${i} ${MezArray[${i},3]}| (!${Spawn[${MezArray[${i},1]}].ID} && !${MezArray[${i},3].Equal[NULL]}) || ${Spawn[${MezArray[${i},1]}].Type.Equal[CORPSE]} || (!${Spawn[${MezArray[${i},1]}].Aggressive} && (!${Spawn[${MezArray[${i},1]}].CachedBuff[${MezSpell}].ID} && !${Spawn[${MezArray[${i},1]}].CachedBuff[${MezAESpell}].ID}))"
			/call RemoveFromArray MezArray ${i}
			}
        /next i
        |/if (${DebugMez}) /delay 5
       DEBUGMEZ MezRadar: MezMobCount: ${MezMobCount} Leave \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: Add to Array
| -------------------------------------------------------------------------------------
    Sub AddToArray(ArrayName, int AddMobID)
    /if (!${AddMobID}) /return
        DEBUGN AddToArray ${AddMobID} Enter"
        /declare i int local 0
        /for i 1 to 13
            /if (${${ArrayName}[${i},1].Equal[NULL]}) {
                /varset ${ArrayName}[${i},1] ${Spawn[${AddMobID}].ID}
                /varset ${ArrayName}[${i},2] ${Spawn[${AddMobID}].Level}
                /varset ${ArrayName}[${i},3] ${Spawn[${AddMobID}].CleanName}
                DEBUGMEZ ARRAY: Assign >> ${${ArrayName}[${i},3]} << to ${ArrayName}${i}. \agLine#:${Macro.CurLine}"
				DEBUGMEZ ARRAY: The ${ArrayName} array now looks like ${${ArrayName}[1,3]}|${${ArrayName}[2,3]}|${${ArrayName}[3,3]}|${${ArrayName}[4,3]}|${${ArrayName}[5,3]}|${${ArrayName}[6,3]}|${${ArrayName}[7,3]}|${${ArrayName}[8,3]}|${${ArrayName}[9,3]}|${${ArrayName}[10,3]}|${${ArrayName}[11,3]}|${${ArrayName}[12,3]}|${${ArrayName}[13,3]} "
                DEBUGMEZ ARRAY: The ${ArrayName} array now looks like ${${ArrayName}[1,1]}|${${ArrayName}[2,1]}|${${ArrayName}[3,1]}|${${ArrayName}[4,1]}|${${ArrayName}[5,1]}|${${ArrayName}[6,1]}|${${ArrayName}[7,1]}|${${ArrayName}[8,1]}|${${ArrayName}[9,1]}|${${ArrayName}[10,1]}|${${ArrayName}[11,1]}|${${ArrayName}[12,1]}|${${ArrayName}[13,1]} "
				/return
            }
        /next i
        DEBUGN AddToArray Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: Remove From Array
| -------------------------------------------------------------------------------------
    Sub RemoveFromArray(RArrayName, int ArNum)
        /if (${${RArrayName}[${ArNum},1].Equal[NULL]}) /return
        /if (${ArNum}<1 || ${ArNum}>${${RArrayName}.Size}) /return
        DEBUGN RemoveFromArray ${ArNum} Enter"
        DEBUGN ARRAY Remove >> ${${RArrayName}[${ArNum},3]} << from ${RArrayName}${ArNum}."
        /varset ${RArrayName}[${ArNum},1] NULL
        /varset ${RArrayName}[${ArNum},2] NULL
        /varset ${RArrayName}[${ArNum},3] NULL
        /if (${MezOn} && ${ArNum}<=13) {
            /varset MezCount[${ArNum}] 0
            /varset MezTimer${ArNum} 0
        }
        DEBUGN RemoveFromArray Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: Do Mez Stuff | Mez Array 1=Mob ID, 2=Level, 3=CleanName
| -------------------------------------------------------------------------------------
    Sub DoMezStuff
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /doevents 
        /if (!${MezOn}) /return
        /if (${Me.Hovering}) /return
        /if (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        DEBUGMEZ DoMezStuff: Enter \agLine#:${Macro.CurLine}"
        /declare i int local 0
        /declare j int local 0
        | Reset skip mez on health setting if tank dies to 1%
        /if (!${Spawn[=${MainAssist}].ID}) /varset MezStopHPs 1
		|Lemons: Gonna remove the ohshit call here. Seeing some odd mez behavior.
		|/if (${OhShitOn}) /call OhShitStuff "DoMezStuff"
        /call MezRadar
        DEBUGMEZ DoMezStuff MezMobCount ${MezMobCount} \agLine#:${Macro.CurLine}"
        /if (${MezMobCount}<2 && ${Spawn[=${MainAssist}].ID}) {
			/call GetHostilesOnXTarget
			/if (${Macro.Return} > 1) {
				|/beep
				|/beep
				|/beep
				|/call BCTExec ${Spawn[=${MainAssist}].Name} "/popup well mobradar didn't pick it up because of MezRadius"
				|/echo well mobradar didn't pick it up because of MezRadius
				|/echo however this is a dangerous situation, we do have mobs on xtarget
				/declare ClosestMobDist int local 100000
				/declare ClosestMobID int local 0
				/for i 1 to ${XSlotTotal}
                    /if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].ID}) {
						/if (${Me.XTarget[${i}].Distance3D} < ${ClosestMobDist}) {
							/varset ClosestMobDist ${Me.XTarget[${i}].Distance3D}
							/varset ClosestMobID ${Me.XTarget[${i}].ID}
						}
                    }
				/next i
				|Lemons: Why run out in the pull area instead of waiting for the mobs to come to us?
				|/if (${Spawn[id ${ClosestMobID}].Distance3D} > 50) {
				|	/if (${Spawn[=${MainAssist}].Dead}) {
				|		/echo main assist is dead we better go mez the mobs...
				|		/nav id ${ClosestMobID}
				|		/delay 1s ${Navigation.Active}==TRUE
				|		/delay 10s ${Navigation.Active}==FALSE
				|		/return
				|	} else {
				|		/if (${Spawn[=${MainAssist}].Distance3D} > 50) {
				|			/echo we got to help our guy out...
				|			/nav id ${Spawn[=${MainAssist}].ID}
				|			/delay 1s ${Navigation.Active}==TRUE
				|			/delay 10s ${Navigation.Active}==FALSE
				|			/return
				|		}
				|	}
				|}
			} else {
				DEBUGMEZ MezMobCount was ${MezMobCount} (so less than 2) & ${MainAssist} is alive so we return"
				/return
			}
        }
        | Necros can't AE mez. But you don't need to check it twice.
        /if (${Select[${MezOn},1,3]} && ${MezAECount} > 0 && ${MezMobAECount} >= ${MezAECount} && ${MezAETimer}==0 && ${Select[${Me.Class.ShortName},BRD,ENC]}) {
            DEBUGMEZ I'm about to AEMez \agLine#:${Macro.CurLine}"
            /if (${SpawnCount[npc xtarhater loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]}>=${SpawnCount[npc loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]}) {
				/call MezMobsAE ${MezAEClosest}
			}
        }
        /for i 1 to 13
			/doevents TankTarget
			/if (${Spawn[${MyTargetID}].PctHPs} <= ${PetAssistAt} && (${PetOn} || ${Me.Pet.ID}) && ${PetCombatOn} && !${Me.Pet.Combat}) {
				/pet attack ${MyTargetID}
				/if (${MuleDebug}) /echo Pet attacking in mez loop
			}
            | Every Mez test conditon is listed seperately for clarity
            DEBUGMEZ we are in the mezcondition loop i is: ${i} \agLine#:${Macro.CurLine}"
            | Test -> Is my single mez spell ready
            /if (!${Me.SpellReady[${MezSpell}]} && !${IAmABard}) {
                DEBUGMEZ ${MezSpell} not ready, goto return \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
			| Test -> Is it a friendly pet
            /if (${Spawn[${MezArray[${i},1]}].Type.Equal[PET]} && ${Spawn[${MezArray[${i},1]}].Master.Type.Equal[PC]}) {
                DEBUGMEZ ${i}  MezArray[${i},1] was equal to NULL, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
            | Test -> array not empty,
            /if (${MezArray[${i},1].Equal[NULL]}) {
                DEBUGMEZ ${i}  MezArray[${i},1] was equal to NULL, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
            | Test -> Target is dead
            /if (${MezArray[${i},3].Find[corpse]} ||  !${Spawn[${MezArray[${i},1]}].ID}) {
                DEBUGMEZ ${i}  ${MezArray[${i},3]}, ${MezArray[${i},1]},${MezArray[${i},2]} is dead, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
			/doevents TankTarget
			| Test -> Target is not the one being tanked by MT/MA
            /if (${Spawn[${MezArray[${i},1]}].ID} == ${AssistID} || ${MezArray[${i},1]} == ${Spawn[${Spawn[pc ${MainAssist}].AssistName}].ID}) {
                DEBUGMEZ i:${i}  ${MezArray[${i},1]} is the MA/MT target id: ${AssistID} or AssistName ${Spawn[pc ${MainAssist}].AssistName}].ID}, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            } else {
				|Use dannet to check tanks main target
				/call HomogenizeMainTarget
				/if (${MyTargetID} == ${Spawn[${MezArray[${i},1]}].ID}) {
					DEBUGMEZ i:${i}  ${MezArray[${i},1]} is the MA/MT target id: ${MyTargetID}"
                /goto :SkipMez
				}
			}
			
            | Is mob in MezRadius distance
            /if (${Spawn[${MezArray[${i},1]}].Distance3D}>=${MezRadius}) {
				DEBUGMEZ Mez: I: ${i} ${Spawn[${MezArray[${i},1]}]},${Spawn[${MezArray[${i},1]}].ID} Mob distance is greater than MezRadius: ${Spawn[${MezArray[${i},1]}].Distance} \agLine#:${Macro.CurLine}"
				/if (${Spawn[=${MainAssist}].Distance3D} < 50) {
					|/varcalc MezRadius ${MezRadius} + 10
					|/call BCTExec ${Spawn[=${MainAssist}].Name} "/popup ${i} Mob distance is greater than MezRadius (${MezRadius}) : ${Spawn[${MezArray[${i},1]}].Distance}"
				}
                /goto :SkipMez
            }
            | Test -> is target MA's current Target
			|/if (${DebugMez}) /echo Test ${Spawn[${MezArray[${i},1]}].Name} had the same ID(${Spawn[${MezArray[${i},1]}].ID}) as MyTargetID(${MyTargetID}) & ${MainAssist}(${Spawn[=${MainAssist}].ID}),Whole line:(${Spawn[${MezArray[${i},1]}].ID}==${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Corpse]}) goto :SkipMez \agLine#:${Macro.CurLine}
            /if (${Spawn[${MezArray[${i},1]}].ID}==${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Corpse]}) {
                DEBUGMEZ ${i} ${Spawn[${MezArray[${i},1]}].Name} had the same ID(${Spawn[${MezArray[${i},1]}].ID}) as MyTargetID(${MyTargetID}) & ${MainAssist}(${Spawn[=${MainAssist}].ID}), goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
			|/if (${DebugMez}) /echo Test ${i} ${Spawn[${MezArray[${i},1]}].Name} is the current GroupAssist Target, but isn't set as MyTargetID${MyTargetID} | G:${Group.MainAssist.ID} && MID:${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID} && ${MezArray[${i},1]}==${Me.GroupAssistTarget.ID}, goto :SkipMez \agLine#:${Macro.CurLine}"
            /if (${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID} && ${MezArray[${i},1]}==${Me.GroupAssistTarget.ID} && !${TankAllMobs}) {
                DEBUGMEZ ${i} ${Spawn[${MezArray[${i},1]}].Name} is the current GroupAssist Target, but isn't set as MyTargetID${MyTargetID} | ${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID} && ${MezArray[${i},1]}==${Me.GroupAssistTarget.ID}, goto :SkipMez \agLine#:${Macro.CurLine}"
				/echo Returning from Mez cause mytargetid is stale. let's see if this fixes it: ${MyTargetID}=${Spawn[${MyTargetID}].Name}
				/varset MyTargetID 0
				/return
                /goto :SkipMez
            }
            | Test -> is  MA's a merc skip 1st target so he attackes it.
            /if (${AggroTargetID} && !${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) {
                DEBUGMEZ AggroTargetID = ${AggroTargetID}  MyTargetID = ${MyTargetID} & Spawn[=MainAssist].ID = ${Spawn[=${MainAssist}].ID} & Spawn[=MainAssist].Type.Equal[Mercenary] was true, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
             | Test -> is target above mez hps threshold
            /if (${Spawn[${MezArray[${i},1]}].PctHPs}<${MezStopHPs}) {
                DEBUGMEZ Spawn[MezArray[${i},1]].PctHPs(${Spawn[${MezArray[${i},1]}].PctHPs}) ${Spawn[${MezArray[${i},1]}]} was less than MezStopHPs(${MezStopHPs}), goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
             | Test -> is target within levels defined in ini file
            /if (${MezArray[${i},2]}>${MezMaxLevel} || ${MezArray[${i},2]}<${MezMinLevel}) {
                DEBUGMEZ MezArray[${i},2](${MezArray[${i},2]}) was greater than MezMaxLevel(${MezMaxLevel}) OR less than MezMinLevel(${MezMinLevel}), goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
             | Test -> is the target in line of sight
			/if (${MoveCloserIfNoLOS}) {
				/if (!${Spawn[${MezArray[${i},1]}].LineOfSight} && ${Navigation.MeshLoaded} && ${UseNav} ) {
					/if (${Spawn[=${MainAssist}].Distance3D} < 150) {
						|/beep
						|/call BCTExec ${Spawn[=${MainAssist}].Name} "/popup ${Me.Class} Needs to move closer in DoMezStuff"
						|/call Bind_ToggleVariable ReturnToCamp off
						|/call Bind_ToggleVariable ChaseAssist off
        				/if (${MoveTo.Moving}) /moveto off
						/if (${Stick.Active}) /squelch /stick off
						/if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.Playing}) {
							/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
							/play off
 						}
						|/beep 
						/echo I cant see the mob lets move closer to mainassist and see if we can mez it from there...!${Spawn[${MezArray[${i},1]}].LineOfSight} ${Spawn[${MezArray[${i},1]}]} ${Spawn[${MezArray[${i},3]}]} ${Spawn[${MezArray[${i},1]}].Type} \agLine#:${Macro.CurLine}
						|/nav id ${Spawn[${MezArray[${i},1]}].ID}
						DEBUGMOVE Naving to MainAssist"
						/nav id ${Spawn[=${MainAssist}].ID}
						/varset LastMove ${Macro.CurLine}
						/delay 1s ${Navigation.Active}==TRUE
						/delay 5s ${Navigation.Active}==FALSE
						/call MezRadar
						/return
					} else {
						/if (${DebugMez}) /echo I dont have LineOfSight to Spawn[MezArray[${i},1]](${Spawn[${MezArray[${i},1]}].Name} ID:${Spawn[${MezArray[${i},1]}].ID}), goto :SkipMez \agLine#:${Macro.CurLine}
						/goto :SkipMez
					}
				}
			}
             | Test -> I am a bard and if the player is dumb enough to have me tank then don't mez.
            /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID} && ${MezArray[${i},1].Equal[${MyTargetID}]}) {
                DEBUGMEZ im a bard and stuff, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
             | Test -> is target a giant unmezzable
            /if (${Spawn[${MezArray[${i},1]}].Body.Name.Equal[Giant]}) {
                DEBUGMEZ Spawn[MezArray[${i},1]] (${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]}) is a giant, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
             | Test -> is target on my mez immune list
            /if (${Alert[4].Size}) {
                /for j 0 to ${Alert[4].Size}
                    /if (${Alert[4].List[${j}].Name.Equal[${MezArray[${i},3]}]} && ${Alert[4].List[${j}].Name.Length}) {
                        /if (${MMTimer${i}}==0) /call BroadCast g "MEZ Immune Detected -> ${MezArray[${i},3]} <- ID:${MezArray[${i},1]}"
                        /varset MMTimer${i} 1m
                        DEBUGMEZ i:${i} ${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]} is immune, goto :SkipMez \agLine#:${Macro.CurLine}"
                        /goto :SkipMez
                    }
                /next j
            }
            | Test -> Do i have enough mana to cast the spell 
            /if (${Me.CurrentMana}<${Spell[${MezSpell}].Mana}) {
                DEBUGMEZ i didnt have enough mana to cast ${MezSpell}, goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
            | Test -> Do i have a mez timer on the mob?
            /if (${MezTimer${i}} > 0 && ${Spawn[${MezArray[${i},1]}].CachedBuff[${MezSpell}].ID}) {
                DEBUGMEZ MezTimer${i}(${MezTimer${i}}) was greater than 0 , goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
            | Stop mezzing last mob because pets and mercs won't attack it.
            /if (${MezMobCount}<=1 && ${Spawn[=${MainAssist}].ID} && (${Spawn[=${MainAssist}].Type.Equal[Mercenary]} || ${Spawn[=${MainAssist}].Type.Equal[Pet]})) {
                DEBUGMEZ MezMobCount(${MezMobCount}) was less or equal to 1 & ( MainAssist(${MainAssist}) was a Mercenary OR a Pet ), goto :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
            /if (${Spawn[=${MainAssist} ${MainAssistType} group].ID} && ${Select[${MezArray[${i},1]},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) {
                DEBUGMEZ i:${i} ${MezArray[${i},3]} If tank is alive and mob not on xtarget go to :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
			DEBUGMEZ Checking Mez immune ${i} ${MezImmuneIDs.Find[|${MezArray[${i},1]}]}"
            /if (${MezImmuneIDs.Find[|${MezArray[${i},1]}]}) {
                DEBUGMEZ Mez Immune Mob Detected: ${MezArray[${i},3]} go to :SkipMez \agLine#:${Macro.CurLine}"
                /goto :SkipMez
            }
			| Test -> Is the mob mezzed already and if so, is the timer greater than 3 ticks?
			/target id ${MezArray[${i},1]}
			/delay 5 ${Target.BuffsPopulated}
            /if (${Target.Mezzed.ID} && ${Math.Calc[${Spawn[${MezArray[${i},1]}].CachedBuff[${Target.Mezzed}].Duration}/6000]} > 3) {
                DEBUGMEZ ${Spawn[${MezArray[${i},1]}]} was already mezzed (${Spawn[${MezArray[${i},1]}].CachedBuff[${MezSpell}].ID} && ${Math.Calc[${Spawn[${MezArray[${i},1]}].CachedBuff[${MezSpell}].Duration}/6000]} > 3)"
				/varcalc MezTimer${i} ${Spawn[${MezArray[${i},1]}].CachedBuff[${MezSpell}].Duration}/1000
				/echo Double mez protection check failed (It's already mezzed and duration is greater than 3 ticks)
                /goto :SkipMez
            }
            DEBUGMEZ MezTimer${i} Timer:${MezTimer${i}} ID:${Spawn[${MezArray[${i},1]}].ID} Name:${Spawn[${MezArray[${i},1]}]} i:${i} \agLine#:${Macro.CurLine}"
            /if (${Select[${MezOn},1,2]}) {
                DEBUGMEZ im gonna singlemez ${i} ${MezArray[${i},3]} \agLine#:${Macro.CurLine}"
                /call MezMobs ${MezArray[${i},1]} ${i}
				/doevents TankTarget
				/if (${MezArray[${i},1]} == ${Spawn[${Spawn[pc ${MainAssist}].AssistName}].ID} && ${Spawn[${MezArray[${i},1]}].ID} == ${AssistID}) {
					/echo Oops we were too quick and mezzed the MA. 
					/varset MezTimer${i} 0
					/varset MezBroke 0
				}
            }
            :SkipMez
			DEBUGMEZ Going to next i in mez con loop ${i}"
        /next i
        DEBUGMEZ DoMezStuff: Leave, i= ${i}, ${MezArray[${i},1]} is mob in mez array :${Spawn[${MezArray[${i},1]}]}  \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs AE
| -------------------------------------------------------------------------------------
Sub MezMobsAE(int AEMezID)
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
    | Bard AE mez code
    /declare i int local 1
    /declare WasChasing int local 0
    /if (${IAmABard}) {
        /squelch /twist once ${Me.Gem[${MezAESpell}]}
        /call BroadCast g "MEZZING1-> AE Mezzing Now - ${MezAESpell} "
        /delay 35
        /varset MezAETimer 300
    }
    | Enchanter AE mez code
    /if (${Me.Class.Name.Equal[Enchanter]}) {
        /if (${ChaseAssist}) {
            /varset ChaseAssist 0
            /varset WasChasing 1
            /squelch /stick off
            /if (${MoveTo.Moving}) /moveto off
            /if (${Bool[${Plugin[mq2navigation]}]}==TRUE || ${Bool[${Plugin[mq2nav]}]}==TRUE) {
				/if (${Navigation.Active}) {
					/echo Stopping nav \agLine#:${Macro.CurLine}
					/nav stop
				}
				/delay 30 !${Me.Moving}
			}
		}
        /echo I AM AE MEZZING ${MezAESpell}
        /call CastWhat "${MezAESpell}" ${AEMezID} Mez
        /echo I JUST CAST AE MEZ ${MezAESpell}
        /delay 10 ${Me.SpellReady[${MezAESpell}]}
        /varset MezAETimer ${Spell[${MezAESpell}].Duration.TotalSeconds}s
        DEBUGMEZ TIMER SET ${MezAETimer} \agLine#:${Macro.CurLine}"
        /call BroadCast g "AE MEZZING1-> ${MezAESpell} "
        /if (${WasChasing}) /varset ChaseAssist 1
    }
    | Reset all mez timers to 0 after AE Mez
    /for i 1 to 30
        /varset MezTimer${i} 0
    /next i
/return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs
| -------------------------------------------------------------------------------------
    Sub MezMobs(int MobID, int TimerNum)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}	
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        DEBUGMEZ MezMobs Enter MobID:${MobID} Timer#:${TimerNum} \agLine#:${Macro.CurLine}"
		/if (${Me.Hovering}) /return
        /declare MezFail int local 0
        /declare MezTry int local 1
        /declare ReMez int local 0
        /if (${Me.Combat}) {
                /attack off
                /delay 25 !${Me.Combat}
        }
		/if (${Target.ID}!=${MobID}) {
			/if (${Target.ID}) {
				/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
				/squelch /target clear
				/delay 1s ${Target.BuffsPopulated}==FALSE
			}
			/if (${MuleDebug}) /echo Targeting a mob 14e: ${MobID}
			/squelch /target id ${MobID}
			/delay 1s ${Target.ID}==${MobID}
			/delay 2s ${Target.BuffsPopulated}==TRUE
			/delay 1s ${Target.CachedBuffCount}!=-1
		}
		/if (${Target.ID} == ${AssistID}) {
			DEBUGMEZ MezMobs Leaving cause my target ${Target} is the same as ${Spawn[${AssistID}]} \agLine#:${Macro.CurLine}"
		}
        /if (${Target.ID}==${MobID}) {
            /if (${Target.CachedBuff[^Mezzed].ID} && ${Target.CachedBuff[^Mezzed].Name.Equal[${MezSpell}]}) {
                DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} Target Info: ${Target.CachedBuff[^Mezzed].ID} ${Target.CachedBuff[^Mezzed].Name} ${Target.CachedBuff[^Mezzed].Duration.TotalSeconds} \agLine#:${Macro.CurLine}"
                /if (${Target.CachedBuff[^Mezzed].Duration.TotalSeconds} > ${Math.Calc[(${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*.10]}) {
                    /varcalc MezCount[${TimerNum}] 1
                    /varcalc MezTimer${TimerNum} (${Target.CachedBuff[^Mezzed].Duration.TotalSeconds}*10)*.75
                    /return
                }            
            }
			/if (!${Target.LineOfSight}) {
				DEBUGMEZ I don't have LoS on ${Target} yet. Returning since I can't mez stuff I can't see."
				/return
			}
            /if (${MezCount[${TimerNum}]}<1) {
                /call BroadCast g "MEZZING2-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
            } else {
                /call BroadCast g "ReMEZZING2-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                /varset ReMez 1
            }
            | Chanter mez code
            :retrymez
            /if (${Me.Class.Name.Equal[Enchanter]}) {
                /call CastWhat "${MezSpell}" ${MobID} Mez 1
				/doevents CastMezImmune
                /varcalc MezFail ${MezFail}+1
				DEBUGMEZ MezFail set to ${MezFail}"
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /if (!${ReMez})  /call BroadCast g "JUST MEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                    /if (${ReMez})  /call BroadCast g "JUST REMEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                    /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                    /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.75
                    DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} \agLine#:${Macro.CurLine}"
                }
                /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
					DEBUGMEZ Mez was resisted and mezfail is ${MezFail}, trying again"
                    /call BroadCast g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                    /goto :retrymez
                }
                /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                }
            }
            | Bard mez code
            /if (${IAmABard}) {
                /call CastWhat "${MezSpell}" ${MobID} BardMez
				|/squelch /twist once ${Me.Gem[${MezSpell}]}
                |/delay 35
				/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
                /squelch /target clear
                /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                /varset MezTimer${TimerNum} 110
				/doevents CastMezImmune
            }
            | Necro mez code
            /if (${Me.Class.Name.Equal[Necromancer]}) {
                /call CastWhat "${MezSpell}" ${MobID} Mez
                /call CheckCasting 50
                /varcalc MezFail ${MezFail}+1
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                    /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.95
                    DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} \agLine#:${Macro.CurLine}"
                    | Necro flag to release from mez loop since spell has 6 sec refresh.
                }
                /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
                    /call BroadCast g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                    /goto :retrymez
                }
                /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                }
            }
            /varset MezTry 0
        }
    DEBUGMEZ MezMobs Leave \agLine#:${Macro.CurLine}"
    /return 
| -------------------------------------------------------------------------------------
| SUB: Do Debuff Stuff
| -------------------------------------------------------------------------------------
    Sub DoDebuffStuff(int FirstMobID)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        DEBUGDPS DoDebuffStuff: Enter \agLine#:${Macro.CurLine}"
        /doevents
        /if (!${DebuffAllOn} || !${DebuffCount} || ${Window[RespawnWnd].Open} || (${DMZ} && ${Me.InInstance}==FALSE) || (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]})) /return
        |/if (${Role.Find[tank]}) /return
        /if (${DPSPaused}) {
           DEBUGDPS DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#:${Macro.CurLine}"
           /return
        }
        /declare i               int      local 0
        /declare j               int      local 0
        /declare k               int      local 0
        /declare DebuffTargetID  int      local 0
        /declare DebuffText      string   local

        /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID}) {
           DEBUGCOMBAT im a bard and stuff so im getting out of here. Returning \agLine#:${Macro.CurLine}"
           /return
        }
        /call MobRadar ${MeleeDistance} DoDebuffStuff
        /for i 1 to ${DebuffCount}
           /if (${DBOList${i}.Length}) {
              /varset k 1
              /if (!${DBOTimer${i}}) {
                  | Reset the list with only the current DPS mob ID. So you won't try and debuff the mob again.
                 /varset DBOList${i} |${MyTargetID}
              } else {
                 |Remove mobs from list that are dead or over 200 units away.
                 /while (${DBOList${i}.Arg[${k},|].Length}) {
                    /if (!${Spawn[${DBOList${i}.Arg[${k},|]}].ID} || ${Spawn[${DBOList${i}.Arg[${k},|]}].Distance}>200 || ${Spawn[${DBOList${i}.Arg[${k},|]}].Type.Equal[Corpse]}) {
                       /varset DBOList${i} ${DBOList${i}.Replace[|${DBOList${i}.Arg[${k},|]},]}
                    } else {
                       /varcalc k ${k}+1
                    }
                 }
              }
           }
        /next i
        | For Mobs
        DEBUGCOMBAT MobCount was ${MobCount} MainAssist: ${MainAssist} FirstMobID: ${FirstMobID} MyTargetID: ${MyTargetID} \agLine#:${Macro.CurLine}"
        /call DebuffCast "${FirstMobID}" 1
        /for j 1 to 13
           |--- only call code for GroupEscape kick off.
           /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
           /if (${DPSPaused}) {
              DEBUGCOMBAT DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#:${Macro.CurLine}"
              /return
           }
           /if (!${Me.XTarget[${j}].ID} || (${Me.XTarget[${j}].ID}==${FirstMobID})) /goto :SkipMob
           | Every Debuff test conditon is listed seperately because Maskoi forgets why he does anything.
           DEBUGCOMBAT DoDebuffStuff: we are in the debuffcondition loop j is: ${j} \agLine#:${Macro.CurLine}"
           | Is Xtarget type not of type auto hater
           /if (${Me.XTarget[${j}].TargetType.NotEqual[Auto Hater]} || ${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[Corpse]}) {
              DEBUGDPS XTarget Type: ${Me.XTarget[${j}].TargetType} Spawn Type: ${Spawn[${Me.XTarget[${j}].ID}].Type}  \agLine#:${Macro.CurLine}"
              /goto :SkipMob
           }
           | Is mob in spell Radius distance
           /if (${Spawn[${Me.XTarget[${j}].ID}].Distance}>=${MeleeDistance}) {
              DEBUGCOMBAT DoDebuffStuff: ${j}  Mob distance is greater than MeleeDistance: ${Spawn[${Me.XTarget[${j}].ID}].Distance} goto :SkipMob \agLine#:${Macro.CurLine}"
              /goto :SkipMob
           }
           | Test -> is the target in line of sight
			/if (!${Spawn[${Me.XTarget[${j}].ID}].LineOfSight}) {
			|	/if (${MoveCloserIfNoLOS} && ${Spawn[${Me.XTarget[${j}].ID}].Distance3D} < 50 && ${Navigation.MeshLoaded} && ${UseNav} ) {
			|		/beep
			|		/call BCTExec ${Spawn[=${MainAssist}].Name} "/popup ${Me.Class} Needs to move closer in DoDebuffStuff"
			|		/echo I cant see the mob lets move closer 2
			|		/call Bind_ToggleVariable ReturnToCamp off
			|		/call Bind_ToggleVariable ChaseAssist off
        	|		/if (${MoveTo.Moving}) /moveto off
			|		/if (${Stick.Active}) /squelch /stick off
			|		/if (${Bool[${Plugin[mq2advpath]}]}==TRUE) {
			|			/play off
 			|		}
			|	   	/nav id ${Me.XTarget[${j}].ID}
			|		/delay 2s ${Navigation.Active}==TRUE
			|		/delay 5s ${Navigation.Active}==FALSE
			|	} else {
					DEBUGCOMBAT DoDebuffStuff: I dont have LineOfSight to Spawn[${Me.XTarget[${j}].ID}] ${Spawn[${Me.XTarget[${j}].ID}].Name} so im going to :SkipMob \agLine#:${Macro.CurLine}"
				    /goto :SkipMob
			|	}
			}
			/varset DebuffTargetID ${Me.XTarget[${j}].ID}
			DEBUGCOMBAT DoDebuffStuff Target: ${DebuffTargetID}=${Target.ID} DebuffAllOn: ${DebuffAllOn} J: ${j} \agLine#:${Macro.CurLine}"
			/if (${Me.Combat} && (${MainAssist.NotEqual[${Me}]} || ${DebuffTargetID}!=${Target.ID})) {
				/attack off
				/delay 10 !${Me.Combat}
           }
           | ****************  For Spells  *****************************
              /if (${DebuffAllOn}==2) {
                 /call DebuffCast "${DebuffTargetID}" 1 
              } else {
                 /call DebuffCast "${DebuffTargetID}" 0
              }
           :SkipMob
           DEBUGCOMBAT DoDebuffStuff 4.0 \agLine#:${Macro.CurLine}"
           | Reset values if 3rd value in dps for All
           /varset DebuffTargetID ${MyTargetID}
           | ************ Next Mob ***************
        /next j
        :SkipDoDebuff
        /if (${Target.ID}!=${MyTargetID}) {
           /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]}) {
				/if (${MuleDebug}) /echo Targeting a mob 14f: ${MyTargetID}
              /target id ${MyTargetID}
              /delay 1s ${Target.ID}==${MyTargetID}
           }
        }
        DEBUGDPS DoDebuffStuff: Leave \agLine#:${Macro.CurLine}"
    /return
|--------------------------------------------------------------------------------
| SUB: Event DebuffCast
| -------------------------------------------------------------------------------------
    Sub DebuffCast(int DebuffTargetID, int FWait)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /declare c               int      local 0
        /declare f               int      local 0
        /declare f1              int      local 0
        /declare g               int      local 0
        /declare i               int      local 0
        /declare DebuffText      string   local
        /declare TempTimer       timer    local 0
        /declare Tag1            string   local
        /declare Tag2            string   local 
		/declare Tag3            string   local
        /declare echoTimer       timer    local 0
        | ****************  For Spells  *****************************
        DEBUGDPS DebuffCast Enter. \agLine#:${Macro.CurLine}"
        | g  - is control variable for remaining in loop while checking for mobs to debuff and spell is ready to cast.
        | c  - is to tell if the current mob is NOT on the Debuffed List or the debufftimer has runout. c=1 mob needs debuff, c=0 Mob can be skipped
        | f  - is a flag that is changed if we find a mob to debuff, but the current Spell or AA is not ready for casting, f=1 Spells/AA's were ready, f=0 Spell/AA not ready.
        | i  - is the index of the debuff to cast.
        | !${c} This mob has all debuffs, !${f} There is a debuff that was not ready for this mob.

        /while (1) {
           /varset TempTimer 70
           /varset g 1
           /while (${g} && ${TempTimer}) {
              /varset c 0
              /varset f 1
              /if (${i}==${DebuffCount}) /varset i 0
              /while (${f} && ${i}<${DebuffCount}) {
                 /varset f1 0
                 /varcalc i ${i}+1
                 /varset DebuffText ${DPS[${i}].Arg[1,|]}
                 DEBUGDPS ${DebuffText} ${DPS[${i}].Length}  ${DebuffText.NotEqual[null]} ${DBOList${i}.Find[|${DebuffTargetID}]} ${DBOTimer${i}} ${i} ${DebuffCount} ${TempTimer} \agLine#:${Macro.CurLine}"
				 |/if (${DebugCombat} || ${DebugDPS}) /delay 1s                 
                 |If mob not on list or debuff timer expired then increment counter of mobs needing debuff.
                 /if (${DPS[${i}].Length} && ${DebuffText.NotEqual[null]} && (!${DBOList${i}.Find[|${DebuffTargetID}]} || ${DBOTimer${i}}==0)) {
                    /varset c 1
                    | is spell or AA ready to cast? If ready set flag to drop out of loop.
                    /if (${Select[TRUE,${Me.SpellReady[${DebuffText}]},${Me.AltAbilityReady[${DebuffText}]},${Me.ItemReady[=${DebuffText}]}]}) {
                       /varset f 0
                    } else {
                       /if (${FWait} && !${echoTimer}) {
                          /varset f1 ${Select[TRUE,${Bool[${Me.Book[${DebuffText}]}]},${Bool[${Me.AltAbility[${DebuffText}]}]},${Bool[${FindItem[=${DebuffText}].ID}]}]}
                          | This is a spell.
                          /if (${f1}==1) {
                             /if (${Me.SpellInCooldown}) {
                                /if (${Int[${Me.Gem[${DebuffText}]}]}) {
                                   /if (!${Me.GemTimer[${DebuffText}]}) {
                                      /echo Waiting on Spell Global Cool Down To Cast ${DebuffText}
                                      /varset echoTimer 3s
                                   }
                                }
                             } else /if (${Int[${Me.Gem[${DebuffText}]}]} && ${Me.GemTimer[${DebuffText}]}) {
                                /echo Waiting on Spell: ${DebuffText} to Refresh. Time Remaining: ${Me.GemTimer[${DebuffText}].TotalSeconds} Seconds.
                                /varset echoTimer ${Me.GemTimer[${DebuffText}]}
                             }
                             | This is an AltAbility
                          } else /if (${f1}==2) {
                             /if (${Me.AltAbilityTimer[${DebuffText}]}<=${TempTimer}) {
                                 /echo Waiting on AltAbility To Cast ${DebuffText}
                                 /varset echoTimer 3s
                             }
							 | else {
                                |/echo Skipping AltAbility. Wait time is to long for ${DebuffText}
                             |}
                             | This is an Item
                          } else /if (${f1}==3) {
                             /if (${Math.Calc[${FindItem[=${DebuffText}].TimerReady}*10]}<=${TempTimer}) {
                                 /echo Waiting on Item To Cast ${DebuffText}
                                 /varset echoTimer 3s
                             }
							 | else {
                                |/echo Skipping Item. Wait time is to long for ${DebuffText}
                             |}                          
                          }
                       }
                    }
                 }
              }
			  /if (${OhShitOn}) {
				/call OhShitStuff "DebuffWaitLoop"
			  }
              DEBUGDPS ${c} ${f}  ${FWait} \agLine#:${Macro.CurLine}"
              /if (!${c} || !${f} || (${f} && !${FWait})) /varset g 0 
           }
           DEBUGCOMBAT DebuffCast 0 DebuffTargetID: ${DebuffTargetID} ${i} C: ${c} F: ${f} FWait: ${FWait} \agLine#:${Macro.CurLine}"
           /if (${MezOn}) /varset MezBroke 0
           /doevents
           /if (${DPSPaused}) {
              DEBUGDPS DebuffCast: Return from DebuffCast cause DPSPaused is ${DPSPaused} \agLine#:${Macro.CurLine}"
              /return
           }
           /if (!${c} || ${g} || (${f} && !${FWait})) {
              DEBUGDPS DebuffCast Exit. \agLine#:${Macro.CurLine}"
              /return
           }
           /if (${DebugCombat} || ${DebugDPS}) {
			DEBUGCOMBAT DebuffCast 1 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} \agLine#:${Macro.CurLine}"
           }
			/if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) {
				/call GroupEscape
				/if (${Macro.Return.Equal[TRUE]}) {
					/echo I just evaced! Leaving DebuffAll
					/return
				}
			}
           /if (${MezOn} && !${MezBroke}) /call DoMezStuff
           /varset TempTimer 0
           /varset Tag1 ${DPS[${i}].Arg[4,|]}
           /varset Tag2 ${DPS[${i}].Arg[5,|]}
           /if (${Tag1.Equal[always]}) /varset Tag2 always
           | Test -> Do i have enough mana to cast the spell 
           /if (${Me.CurrentMana}<${Spell[${DebuffText}].Mana}) {
              DEBUGCOMBAT DebuffCast: i didnt have enough mana to cast ${DebuffText} so im going to :SkipCast \agLine#:${Macro.CurLine}"
              /goto :SkipCast
           }
           /if (${Spawn[${DebuffTargetID}].Type.Equal[Corpse]} || ${Int[${Spawn[${DebuffTargetID}].ID}]}==0) /return
			/if (${Target.ID}!=${DebuffTargetID}) {
				/if (${Target.ID}) {
					/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
					/squelch /target clear
					/delay 1s ${Target.BuffsPopulated}==FALSE
				}
				/if (${MuleDebug}) /echo Targeting a mob 14g: ${DebuffTargetID}
				/target id ${DebuffTargetID}
				/delay 1s ${Target.ID}==${DebuffTargetID}
				/delay 2s ${Target.BuffsPopulated}==TRUE
				/delay 2s ${Target.CachedBuffCount}!=-1
		   }
           DEBUGCOMBAT DebuffCast: Debuff: ${DebuffText} TargetID: ${Target.ID} DebuffTargetID: ${DebuffTargetID} : ${Target.Buff[${DebuffText}].ID} ${Target.Buff[${DebuffText}].Caster} ${Me.SpellInCooldown} ${Tag1} ${Tag2} \agLine#:${Macro.CurLine}"
           | Check Target for Buffs
		   /call CacheBuffs ${DebuffTargetID}
           /if (${Spawn[${DebuffTargetID}].CachedBuffCount}) {
              | Does the Target have the debuff I am about to cast
              /if (${Spawn[${DebuffTargetID}].CachedBuff[${DebuffText}].ID}) {
                 /if (${Spawn[${DebuffTargetID}].CachedBuff[${DebuffText}].CasterName.Equal[${Me.CleanName}]} || (${Spawn[${DebuffTargetID}].CachedBuff[${DebuffText}].CasterName.NotEqual[${Me.CleanName}]} && ${Tag2.NotEqual[always]})) {
                    /varcalc TempTimer ${Spawn[${DebuffTargetID}].CachedBuff[${DebuffText}].Duration.TotalSeconds}*10
                 }
              }
              | If timer didn't get set above then check this
              /if (${TempTimer}==0) {          
                  | Does the mob have one of the following debuffs if so lets skip casting
                  /if (${Tag1.Equal[strip]} && (${Spawn[${DebuffTargetID}].CachedBuff[^Beneficial].ID}==0 || ${Spawn[${DebuffTargetID}].CachedBuff[^Beneficial].ID}==38728 || ${Spawn[${DebuffTargetID}].CachedBuff[^Beneficial].ID}==38727 || ${Spawn[${DebuffTargetID}].CachedBuff[^Mezzed].ID})) {
                     /varset TempTimer 70
                  } else /if (${Tag2.NotEqual[always]}) {
                     /if (${Tag1.Equal[slow]} && ${Spawn[${DebuffTargetID}].CachedBuff[^Slowed].ID}) {
                        /varcalc TempTimer ${Spawn[${DebuffTargetID}].CachedBuff[^Slowed].Duration.TotalSeconds}*10
                     } else /if (${Tag1.Equal[tash]} && ${Spawn[${DebuffTargetID}].CachedBuff[^Tashed].ID}) {
                        /varcalc TempTimer ${Spawn[${DebuffTargetID}].CachedBuff[^Tashed].Duration.TotalSeconds}*10
                     } else /if (${Tag1.Equal[malo]} && ${Spawn[${DebuffTargetID}].CachedBuff[^Maloed].ID}) {
                        /varcalc TempTimer ${Spawn[${DebuffTargetID}].CachedBuff[^Maloed].Duration.TotalSeconds}*10
                     } else /if (${Tag1.Equal[crip]} && ${Spawn[${DebuffTargetID}].CachedBuff[^Crippled].ID}) {
                        /varcalc TempTimer ${Spawn[${DebuffTargetID}].CachedBuff[^Crippled].Duration.TotalSeconds}*10
                     } else /if (${Tag1.Equal[snare]} && ${Spawn[${DebuffTargetID}].CachedBuff[^Snared].ID}) {
                        /varcalc TempTimer ${Spawn[${DebuffTargetID}].CachedBuff[^Snared].Duration.TotalSeconds}*10
                     }
                  }
              }
              /if (${TempTimer}) {
                 /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                 /goto :SkipCast
              }
              DEBUGCOMBAT DebuffCast: DebuffTargetID: ${DebuffTargetID} Slowed: ${Spawn[${DebuffTargetID}].CachedBuff[^Slowed].ID} Tashed: ${Spawn[${DebuffTargetID}].CachedBuff[^Tashed].ID} Maloed: ${Spawn[${DebuffTargetID}].CachedBuff[^Maloed].ID} Crippled: ${Spawn[${DebuffTargetID}].CachedBuff[^Crippled].ID} Tag1: ${Tag1} Tag2: ${Tag2} TempTimer: ${TempTimer} \agLine#:${Macro.CurLine}"
           } 
           /if (${HealsOn}) /call CheckHealth
           | Wait here for a sec, your spell bar may still be in global cool down.
           /if (${Me.SpellInCooldown}) {
              /delay 10 !${Me.SpellInCooldown}
           }
           | When you get here you won't want to cast Eradicate Magic if the mob has NO Beneficial Buffs
		   |Modification by Kaen01 to better handle mitigation
			/if (${Tag1.Equal[strip]}) {
				|- if mob has mitigation of the mighty
				/if (${Spawn[${DebuffTargetID}].CachedBuff[Mitigation of the Mighty].ID}) {
					/for c 1 to ${Spawn[${DebuffTargetID}].CachedBuffCount}
						/if (${Spawn[${DebuffTargetID}].CachedBuff[#${c}].SpellType.Find[Beneficial]} && !${Spawn[${DebuffTargetID}].CachedBuff[#${c}].Name.Find[Mitigation of the Mighty]}) {
							/echo \agFound beneficial spell: \at${Spawn[${DebuffTargetID}].CachedBuff[#${c}].Name}
							/break
						}
					/next c
					/if (${c} > ${Spawn[${DebuffTargetID}].CachedBuffCount} ) {
						/if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
						/varset TempTimer 70
						/goto :SkipCast
					}
				} else /if (!${Spawn[${DebuffTargetID}].CachedBuff[^Beneficial].ID} || ${Spawn[${DebuffTargetID}].CachedBuff[^Mezzed].ID} ) {
				|- if mob does not have mitigation of the might and no beneficials or is mezzed
					/if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
					/varset TempTimer 70
					/goto :SkipCast
				}
			}
           | Conditional Check Added.
			/if (${ConditionsOn}) {
				/if (${DPSCOn}) {
					|/echo Why the embedded If? 
					| This is like checking If twice...
					/if (${If[${DPSCond[${i}]},0,1]}) {
						|/if (${i}==1) {
							|/echo The DPSCond${i} (${DPSCond[${i}]}==FALSE) for ${DPS[${i}]} returned FALSE so we skip it.
						|}
						/goto :SkipCast
					}
					| else {
						|/echo The DPSCond${i} (${DPSCond[${i}]}==TRUE) for ${DPS[${i}]} returned TRUE so we move on!
					|}
				}
		   }
           | Everything is ready, lets debuff this mob
           /call CastWhat "${DebuffText}" ${DebuffTargetID} DebuffCast
           DEBUGCOMBAT DebuffCast: Return From CastWhat: ${Macro.Return} \agLine#:${Macro.CurLine}"
           /if (${Macro.Return.Equal[CAST_RESIST]}) {
               /echo [${Time}] ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - RESISTED
               /goto :SkipCast
           }
           /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
              /echo [${Time}] ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - DID NOT TAKE HOLD
              /varset TempTimer 3m
              /goto :SkipCast
           }
           /if (${Macro.Return.Equal[CAST_IMMUNE]} || ${Macro.Return.Equal[CAST_RECOVER]}) {
              /echo [${Time}] ** ${Spawn[${DebuffTargetID}].CleanName} is IMMUNE to - ${DebuffText}
              /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
              /varset TempTimer 3m
              /goto :SkipCast
           }
           /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
              /echo [${Time}] ** Debuffing: ==> ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << DebuffTargetID: ${DebuffTargetID} Target: ${Target.ID} DBOList: ${DBOList${i}}
              /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
              | Timers for items    
              /if (${FindItemCount[=${DebuffText}]}) {
                 /varcalc TempTimer ${FindItem[=${DebuffText}].Spell.Duration.TotalSeconds}*10
                 | Timers for AltAbilities
              } else /if (${Me.AltAbility[${DebuffText}]}) {
                 /varset TempTimer ${Me.AltAbility[${DebuffText}].ReuseTime}s
                 | Timers for spells
              } else /if (${Me.Book[${DebuffText}]}) {
                 | - Custom timer for counterbias
                 /if (${Me.Class.Name.Equal[Shaman]} && ${DebuffText.Find[counterbias]}) {
                    /varset TempTimer 1.5m
                    | Custom timer for Chanter suffocation
                 } else /if (${Me.Class.Name.Equal[enchanter]} && ${DebuffText.Find[suffocation]}) {
                    /varset TempTimer 1m
                    | Custom timer for Beastlord Feralgia Timer
                 } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DebuffText.Find[feralgia]}) {
                    /varset TempTimer 1.5m
                    | Regular spells
                 } else /if (${Spell[${DebuffText}].Duration}>0) {
                    /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                    | Spells with no timers assign DPS interval
                 } else {
                    /varset TempTimer ${DPSInterval}s
                 }
                 | AA and disc timers
              } else /if (${Spell[${DebuffText}].Duration}>0) {
                 /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                 | AA and disc with no timers assign DPS interval
              } else {
                 /varset TempTimer ${DPSInterval}s
              }
           |}
           :SkipCast
           | Check Debuff Timer not set and the Temp Timer has been set.
           | You only want to set the DBOTimer for the first mob you get the Debuff to land on. Don't need a timer for every mob.
           /if (!${DBOTimer${i}} && ${TempTimer}) {
              /varcalc DBOTimer${i} ${TempTimer}*.95
           }
        }
        | ************ Next Spell ***********
        	/if (${DebugCombat} || ${DebugDPS}) {
				DEBUGCOMBAT DebuffCast 2 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} \agLine#:${Macro.CurLine}"
        	}
	}
        DEBUGDPS DebuffCast Exit. \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezBroke
| -------------------------------------------------------------------------------------
Sub Event_MezBroke(meztext,mezmob,mezbreaker)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
    DEBUGMEZ event mezbroke Enter \agLine#:${Macro.CurLine}"
        /if (!${MezOn}) /return
        |/if (${MyTargetID}==${Spawn[${mezmob}].ID}) /return
        /if (${Spawn[${mezbreaker}].CleanName.Equal[${MainAssist}]}) /return
        /if (${Spawn[=${MainAssist}].Type.Equal[pet]} && ${Spawn[=${MainAssist}].Master.CleanName.Equal[${mezbreaker}]}) /return
        /declare tempMobID int local ${Target.ID}
        |/delay 5s ${Me.AssistComplete}==TRUE AssistComplete is broken and pretty sure this did nothing.
        /if (${Spawn[${Spawn[${mezbreaker}].AssistName}].ID} && ${Spawn[${Spawn[${mezbreaker}].AssistName}].ID}==${MyTargetID} && ${Spawn[${Spawn[${mezbreaker}].AssistName}].Name.Find[${mezmob}]}) {
			/if (${MuleDebug}) /echo Targeting a mob 15p
           /target id ${tempMobID}
           /delay 10 ${Target.ID}==${tempMobID}
           /return
        }
        /declare i int local 0
        /call BroadCast g ">>  ${Spawn[${mezbreaker}].CleanName} << has awakened -> ${mezmob}<-"
        /for i 1 to 30
            /if (${MezArray[${i},3].Equal[${mezmob}]}) {
                /echo Resetting Mez Timer${i} ${mezmob} ArrayEntry${i}ID: ${MezArray[${i},1]}, currently at ${MezTimer${i}}
                /varset MezTimer${i} 0
            }
        /next i
        |/doevents flush MezBroke
        /call DoMezStuff
        | Set MezOn = 2 to let us know that the event was triggered. Will be set back to 1 in other location
        /varset MezBroke 1
    DEBUGMEZ event mezbroke Leave \agLine#:${Macro.CurLine}"
/return
| -------------------------------------------------------------------------------------
| SUB: Event MezImmune
| -------------------------------------------------------------------------------------
    Sub Event_MezImmune(int MezID)
    /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
        | Assign temp var MezImmune list
        /declare ImmuneAdd string local ${MezImmune}
        | If mezimmune default text with the word null in it assign var spawn clean name
        /if (${ImmuneAdd.Find[null]}) {
            /varset ImmuneAdd ${Spawn[${MezID}].CleanName}
        } else {
            /varset ImmuneAdd ${ImmuneAdd},${Spawn[${MezID}].CleanName}
        }
        /if (!${MezImmune.Find[${Spawn[${MezID}].CleanName}]}) /ini "${InfoFileName}" "${Zone}" "MezImmune" "${ImmuneAdd}"
        /call BroadCast g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Adding to MezImmune list."
        | Reassign mezimmune var the new list
        /varset MezImmune ${ImmuneAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: AddMezImmune
| -------------------------------------------------------------------------------------
    Sub AddMezImmune(int MezID)
    /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
    /if (${MezImmuneIDs.Find[|${MezID}]}) /return
    /varset MezImmuneIDs ${MezImmuneIDs}|${MezID} 
    /call BroadCast g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Skipping."
    /return

Sub CrapTest

/return 1

Sub PlayersInGroup
	|/call CrapTest
	|/echo CrapTest returned ${Macro.Return}
	/declare i int local 0
	/declare gcnt int local 0
	/for i 1 to ${Group.Members}
		/if (${Group.Member[${i}].Type.Equal[PC]}) {
			/varcalc gcnt ${gcnt}+1
		}
	/next i
/return ${gcnt}

Sub CheckHideResult
	/echo CheckHideResult called going to /con. \agLine#:${Macro.CurLine}
	/consider
	/delay 1s
	/doevents MeHidden
	/if (${HideResult}) {
		/varset HideResult 0
		/varset DoMuleHideID 0
		/if (${Group}) {
			/call BCTell ${Group.Leader.Name} "I am hidden and will pause macro."
		}
		/echo I am Hidden pausing macro
		/delay 5
		/mqp on
	} else {
		/if (${Group}) {
			/call BCTell ${Group.Leader.Name} "I am NOT hidden."
		}
		/echo I am NOT hidden.
		/delay 1
		/doability hide
		/delay 1s ${Me.AbilityReady[Hide]}==TRUE
	}
/return
Sub DoMuleHide(int id)
	/echo DoMuleHide called. \agLine#:${Macro.CurLine}
	/if (${Me.AbilityTimer[Hide]}==0) {
		/declare TheID int local 0
		/varset TheID ${id}
		/if (${Target.ID}!=${TheID}) {
			/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
			/target id ${TheID}
			/delay 1s ${Target.ID}==${TheID}
			/delay 1s ${Target.BuffsPopulated}
			/delay 1s ${Target.CachedBuffCount}!=-1
		}

		/if (${Me.AbilityReady[Hide]}==FALSE) {
			|it's already clicked
			|Let's see if we are actually hiddden	
			/call CheckHideResult
		} else {
			/doability hide
			/delay 1s ${Me.AbilityReady[Hide]}==FALSE
			/delay 1s
			/call CheckHideResult
		}
	}
	/delay 1s
/return


| -------------------------------------------------------------------------------------
| SUB: DoMiscStuff
| -------------------------------------------------------------------------------------
    Sub DoMiscStuff
    /if (!${ChainPull} && (${CombatStart} || ${AggroTargetID})) /return
    DEBUGN DoMiscStuff Enter"
		|Lemons: Should be ALW_Dismiss_Button. Removed for Redbot 4/8/21
        |/if (${Window[alertwnd].Open}) /nomodkey /notify alertwnd ALW_Close_Button leftmouseup
        | Accept trades
        /if (${Window[TradeWnd].Open} && ${Window[TradeWnd].HisTradeReady} && !${Cursor.ID}) /notify TradeWnd TRDW_Trade_Button leftmouseup
        | Accept group invite
        /if (${Window[GroupWindow].Child[GW_FollowButton]} && ${AcceptInvitesOn}) /invite
        | Open HoTT window if available
        /if (${HoTTOn} && !${Window[TargetOfTargetWindow].Open}) /windowstate TargetOfTargetWindow open
        | Ditch wizards familiar
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]} && ${Me.Class.ShortName.Equal[Wiz]}) /pet get lost
        | Drop random items on cursor like drive by mod rods into inventory after 30s min
        /if (${Cursor.ID} && !${CursorIDTimer}) {
            /varset CursorIDTimer 20s
            /if (${Me.FreeInventory}) {
                /echo ${Cursor.Name} is stuck on my cursor. Dropping it into inventory in 15s.
                /timed 150 /autoinventory
            } else /if (!${Me.FreeInventory}) {
                 /call BroadCast t "HEY YOUR INVENTORY IS FULL!"
				 /echo "HEY, YOUR INVENTORY IS FULL!"
            }
        }      

    /if (${ChainPull} && ${ChainPullPause.NotEqual[0]} && !${ChainPullHold} && !${ChainPullTimer2}) {
           /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
           /varset ChainPullTimer2 ${ChainPullPause.Arg[2,"|"]}m
    }
    /if (${ChainPull} && ${ChainPullPause.NotEqual[0]} && !${ChainPullTimer}) {
            /if (!${ChainPullHold}) {
            /echo Pausing Pulls for ${ChainPullPause.Arg[2,"|"]} Minutes. 
            /varset ChainPullHold 2
            /varset ChainPullTimer ${ChainPullPause.Arg[2,"|"]}m
            } else /if (${ChainPullHold}==2) {
            /echo Resetting Pull Timer for ${ChainPullPause.Arg[1,"|"]} Minutes. 
            /varset ChainPullHold 0
            /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
            /varset ChainPullTimer2 ${ChainPullPause.Arg[2,"|"]}m
            }
        } 
        DEBUGN DoMiscStuff Leave"
/return

| -------------------------------------------------------------------------------------
| SUB: Can I do Stuff  - Check if invis moving ducked etc
| -------------------------------------------------------------------------------------
    Sub CanIDoStuff
	DEBUGN CanIDoStuff Enter"
	/if (${ChaseAssist}!=0) {
		|Lemons: Need to check that a mesh exists, otherwise /nav id fails. Could use an alert to let them know that the box needs help finding you.
		|This should make it so if your group is following you, they continue to do so even if you have something on Xtarget. I see problems with this but it's late and I'm tired.
		/if (${Spawn[=${ChaseName}].Distance3D} > ${ChaseDistance} && ${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]} && ${Stick.Status.NotEqual[ON]}) {
			DEBUGMOVE CanIDoStuff Exceeding chase distance with nav path: ${Spawn[=${ChaseName}].Distance3D} > ${ChaseDistance} && ${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]} && ${Stick.Status.NotEqual[ON]}"
			/if (!${Me.FeetWet}) {
				DEBUGMOVE CanIDoStuff Not in water, stopping others and going to Nav"
				/if (${Stick.Active}) /stick off
				/if (${MoveTo.Moving}) /moveto off
				/if (!${Me.Standing}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return
					}
				}
				/if (${Bool[${Plugin[mq2advpath]}]}==TRUE) {
					
					/if (${AdvPath.State}) {
						/play off
						DEBUGMOVE Stopping AdVPath at ${Macro.CurLine}"
					}
				}
				/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
				/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
				/if (!${Navigation.Active} || ${Navigation.Paused}) {
					/varset LastMove ${Macro.CurLine}
					/nav id ${Spawn[=${ChaseName}].ID}
				}
				/delay 1s ${Navigation.Active}==TRUE
				|/delay 10s ${Navigation.Active}==FALSE
				/return
			} else {
				/if (${Navigation.Active}) {
					/echo Stopping nav \agLine#:${Macro.CurLine}
					/nav stop
				}
				DEBUGMOVE I'm in water so I'm gonna use Stick \agLine#:${Macro.CurLine}"
				/if (${Me.Sitting}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return
					}
				}
				/if (${Stick.StickTarget} != ${Spawn[=${ChaseName}].ID} || ${Stick.Status.Equal[OFF]}) /stick uw id ${Spawn[=${ChaseName}].ID}
			}
		}
	}	
    /if ((${CombatStart} || ${AggroTargetID})) /return
    /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0) ) {
		/varset IAmDead 0
	}
    | Turn off twist while invis
    /if (${Me.Invis}) {
		/if (${IAmABard}) {
			/if (${Twist}) {
				/if  (!${Me.Gem[${Twist.Current}].HasSPA[12]}) {
					/twist stop
					/stopsong
					/varset TwistStop ${Macro.CurLine}
					/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
				}
			}
		}
    }
    | Assign Master looter    
    /if (${Select[${Me},${Group.Leader}]}==1) /call AssignLooter
	/declare dontgetstuckhereforever timer local
	/varset dontgetstuckhereforever 60s
    :IAmBusy
        /doevents
		|ok so custom is basically where people can add special code, we dont care at all if they are invis, it should still check it...
		/if (${bCallCustom}==1) {
			/call Custom
		}
		/if (${ChaseAssist}!=0) {
			|Lemons: Need to check that a mesh exists, otherwise /nav id fails. Could use an alert to let them know that the box needs help finding you.
			/if (${Spawn[=${ChaseName}].Distance3D} > ${ChaseDistance} && ${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.PathExists[id ${Spawn[=${ChaseName}].ID}]}) {
				/if (!${Me.FeetWet}) {
					DEBUGMOVE CanIDoStuff Not in water going to nav inside loop IAmBusy"
					/if (${Stick.Active}) /stick off
					/if (${MoveTo.Moving}) /moveto off
					/if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.Playing}) {
						/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
						/play off
					}
					/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
					/if (${Me.Mount.ID} && !${TravelOnHorse}) /dismount
					/nav id ${Spawn[=${ChaseName}].ID}
					/varset LastMove ${Macro.CurLine}
					/delay 1s ${Navigation.Active}==TRUE
					|/delay 10s ${Navigation.Active}==FALSE
					/return
				} else {
					/if (${Navigation.Active}) {
						/echo Stopping nav \agLine#:${Macro.CurLine}
						DEBUGMOVE CanIDoStuff Stopping nav which is active and I'm in water"
						/nav stop
					}
					DEBUGMOVE I'm in water so I'm gonna use Stick \agLine#:${Macro.CurLine}"
					/if (${Me.Sitting}) {
						DEBUGN going to stand"
						/if (!${standTimer}) /stand
						/delay 1s ${Me.Standing}
						/if (!${Me.Standing}) {
							DEBUGN Returning cause I'm not standing"
							/return
						}
					}
					/if (${Stick.StickTarget} != ${Spawn[=${ChaseName}].ID} || ${Stick.Status.Equal[OFF]}) /stick uw id ${Spawn[=${ChaseName}].ID}
				}
			}
			/call GetHostilesOnXTarget
			/if (${Macro.Return} > 0) {
				|Seriously, in manual mode, I need to MOVE when I have targets.  BS 04282020
				/if (${Role.NotEqual[manual]}) {
					/if (${Stick.Active}) /stick off
					/if (${MoveTo.Moving}) /moveto off
				}
				/if ((${Bool[${Plugin[mq2advpath]}]}==TRUE) && (${AdvPath.Playing})) {
					/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
					/play off
				 }
				/return
			}
			/call WriteDebuffs
			/call Roguestuff
			/call EndMacroIf
			/if (${BandolierOn}) /call DoBandolier
			/if (${Navigation.Active} && ${Navigation.Velocity} == 0) {
				/delay 5
				/if (${Navigation.Active} && ${Navigation.Velocity} == 0) {
					DEBUGMOVE I'm navigating but have no speed. Returning"
					/squelch /play off
					/nav stop
					/return
				}
			}
			/if (${Me.Moving} || ${Me.State.Equal[feign]} || (${ChaseAssist}==0 && ${AggroTargetID}==0 && ${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || ${Me.Stunned} || ${Me.Ducking} || (${Me.State.Equal[BIND]} && !${Window[LootWnd].Open})) {
				DEBUGN I'm currently busy doing something, looping in CanIDoStuff(${Me.Moving} || ${Me.State.Equal[feign]} || (${ChaseAssist}==0 && ${AggroTargetID}==0 && ${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || ${Me.Stunned} || ${Me.Ducking} || (${Me.State.Equal[BIND]} && !${Window[LootWnd].Open}))"
				/delay 1
				/if (${dontgetstuckhereforever}==0 && !${Me.Invis}) {
					/echo [${Time}] We returned from CanIDoStuff due to a 60s timeout... this is possibly a bug...
					/return
				}
				/goto :IAmBusy
			}
		}
        /if (${Window[MerchantWnd]} || ${Window[GiveWnd]} || ${Window[SpellBookWnd]} || ${Window[BigBankWnd]} || ${Window[BankWnd]} || ${Window[GuildBankWnd]}  || ${Window[TributeMasterWnd]} || ${Window[GuildTributeMasterWnd]}) /goto :IAmBusy
	DEBUGN CanIDoStuff Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: Mercs Do What
| -------------------------------------------------------------------------------------
    Sub MercsDoWhat
        /if (!${MercOn}) /return
        /if (${Group.Member[1].Owner.Name.Equal[${Me}]}) /varset MyMerc ${Group.Member[1].Name}
        DEBUGN MercsDoWhat Enter"
        /if (${Mercenary.State.Equal[Active]}) /varset MercInGroup 1
        | Revive the merc if dead and previously detected in group
        /if (${MercInGroup} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
		/if (${MercAssistAt}>=${Spawn[${MyTargetID}].PctHPs} && ${Mercenary.State.Equal[Active]} && ${MercAssisting} != ${MyTargetID} && (${CombatStart} || ${Select[${Role},Puller]} && ${Pulled})) {
			/mercassist
			DEBUGCOMBAT MercsDoWhat ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID} \agLine#: ${Macro.CurLine}"
			/varset MercAssisting ${MyTargetID}
			}
        DEBUGN MercsDoWhat Leave"
    /return


| -------------------------------------------------------------------------------------
| Check and set roles
| -------------------------------------------------------------------------------------
    Sub CheckRoles
        /if (${Debug}) {
			DEBUGN CheckRoles Enter"
		}
        /if (${Role.Equal[assist]}) {
            DEBUGN Looks like I am assisting."
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
        } else /if (${Role.Equal[tank]}) {
            /if (${Debug}) {
				DEBUGN Looks like I am Main Tank. Wish me luck. \agLine#:${Macro.CurLine}"
			}
            /if (!${Defined[MainAssist]}) {
				/echo I am setting MainAssist to ${Me} in CheckRoles
				/varset MainAssist ${Me}
			}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
        } else /if (${Role.Equal[puller]}) {
            DEBUGPULL role puller \agLine#:${Macro.CurLine}"
            DEBUGPULL Looks like I am Puller. \agLine#:${Macro.CurLine}"
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) /pet follow        
        } else /if (${Role.Equal[pullertank]}) {
            DEBUGPULL role pullertank \agLine#:${Macro.CurLine}"
            DEBUGPULL Looks like I am Puller and Tank. \agLine#:${Macro.CurLine}"
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) {
				/pet guard
			}
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) {
				/pet follow
			}
        } else /if (${Select[${Role},hunter]}) {
            DEBUGPULL role hunter \agLine#:${Macro.CurLine}"
            DEBUGPULL Looks like I am Hunting. \agLine#:${Macro.CurLine}"
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset StickHow 12
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /varset ReturnToCamp 0
            /varset MobsTooClose 15
            /if (${Pet.ID}) {
				/pet follow
			}
        } else /if (${Role.Equal[hunterpettank]}) {
            DEBUGPULL role hunterpettank \agLine#:${Macro.CurLine}"
            DEBUGPULL Looks like I am Hunting and my pet is tanking. \agLine#:${Macro.CurLine}"
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange 115            
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset MountOn 0
            /varset MobsTooClose 15
            /if (${Pet.ID}) {
				/pet follow
			}
        } else /if (${Select[${Role},petassist]}) {
            DEBUGPULL role petassist \agLine#:${Macro.CurLine}"
            DEBUGPULL Looks like I am assisting a pet. \agLine#:${Macro.CurLine}"
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
			/assist off
        } else /if (${Select[${Role},pettank]}) {
            DEBUGPULL role pettank \agLine#:${Macro.CurLine}"
            DEBUGPULL Looks like my pet is tanking. \agLine#:${Macro.CurLine}"
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange 115
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            :PTauntOn1
            /if (${Me.Pet.ID} && !${PetTauntOn}) {
                /pet taunt on
                /delay 10
                /doevents PTaunt
                /if (!${PetTauntOn}) /goto :PTauntOn1
            }            
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
				/pet guard
			}
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) {
				/pet follow
			}
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend}) /call PetStateCheck                        
        } else /if (${Select[${Role},pullerpettank]}) {
            DEBUGPULL role pullerpettank \agLine#:${Macro.CurLine}"
            DEBUGPULL Looks like I am pulling and my pet is tanking. \agLine#:${Macro.CurLine}"
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset MeleeOn 0
			/assist off
            /varset PetTanking 1
            /varset PetAttackRange 115
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            :PTauntOn2
            /if (${Me.Pet.ID} && !${PetTauntOn}) {
                /pet taunt on
                /delay 10
                /doevents PTaunt
                /if (!${PetTauntOn}) /goto :PTauntOn2
            }
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
				/pet guard
			}
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) {
				/pet follow
			}
            /if (${PullRoleToggle} && ${Group.Leader.ID}!=${Me.ID}) {
                /echo You are set to toggle puller mode but are NOT the group leader.
                /echo Please correct this and restart MuleAssist. 
                /end
            }
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend}) /call PetStateCheck           
        } else /if (${Role.Equal[manual]}) {
                /if (${UseMQ2Melee}) /squelch /melee aggro=0
                /varset MeleeOn 0
				/assist off
                /varset ReturnToCamp 0
                /varset ChaseAssist 0
                /varset DPSOn 0
                /varset BuffsOn 0
                /varset DebuffAllOn 0
                /if (${Defined[HealsOn]}) /varset HealsOn 0
                /if (${Defined[MezOn]}) /varset MezOn 0
        }    
        /if (${Select[${Role},puller,pullerpet]}==0 && ${ChainPull}) /varset ChainPull 0 
        /if (${Debug}) {
			DEBUGN CheckRoles Leave \agLine#:${Macro.CurLine}"
		}
		/if (${MainAssistID} != ${Spawn[${MainAssist}].ID}) /varset MainAssistID ${Spawn[${MainAssist}].ID}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullRange
| -------------------------------------------------------------------------------------
   Sub SetPullRange(int p3_flag)
       DEBUGPULL PullRange Enter \agLine#:${Macro.CurLine}"
       /declare PullItemRange int local
        /if (${Select[${FindItem[=${PullWith.Arg[1,|]}].Type},Archery,Throwing,Throwingv1,Throwingv2,ammo]} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItem ${PullWith.Arg[1,|]}
            /varset PullItemRange ${FindItem[=${PullWith.Arg[1,|]}].Range}
            /if (!${PullItemRange}) /varset PullItemRange 50
            /if (${FindItem[=${PullWith.Arg[2,|]}].WornSlot[ammo]} && ${FindItemCount[=${PullWith.Arg[2,|]}]}) {
                /varset PullAmmo ${PullWith.Arg[2,|]}
                /if (${FindItem[=${PullWith.Arg[1,|]}].Type.Equal[Archery]}) {
                    /varcalc PullItemRange ${PullItemRange}+${FindItem[=${PullWith.Arg[2,|]}].Range}
                }
                /call PullVars ${Math.Calc[${PullItemRange}*.9]} Ranged ${PullItemRange}
            } else {
                /echo I can't find any ammo defaulting to Melee for PullWith
                /varset PullWith Melee
                /call PullVars 15 Melee 15
                /return
            }
			/if (${DebugPull}) /echo \atPullWith=(${PullWith}) PullItem=(${PullItem}) PullItemRange=(${PullItemRange}) PullItemCount=(${FindItemCount[=${PullWith.Arg[1,|]}]}) PullAmmo=(${PullAmmo})\agLine#:${Macro.CurLine}
        }
        /if (${FindItemCount[=${PullWith}]} && !${PullWith.Arg[2,|].Length} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItemRange ${FindItem[=${PullWith}].Spell.Range}
            /call PullVars  ${Math.Calc[${PullItemRange}*.9]} "${PullWith}" ${PullItemRange}
            /return
        }
        DEBUGPULL PullRange PullWith: ${PullWith} - CA:${Me.CombatAbility[${PullWith}]}/SPELL:${Me.Book[${PullWith}]}/ AA: ${Me.AltAbility[${PullWith}]} \agLine#:${Macro.CurLine}"
        /if (${Me.CombatAbility[${PullWith}]} || ${Me.Book[${PullWith}]} || ${Me.AltAbility[${PullWith}]})  {
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]} || ${p3_flag}==3) {
				/call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].Range}/1.11]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].Range}
            }
			/if (${Select[${Role},hunter]})  {
                /if (${DebugPull}) /echo ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].Range}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].Range} \agLine#:${Macro.CurLine}
                /call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].Range}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].Range}
            }
        }
        /if (${PullWith.Equal[Pet]}) {
            /if (${Role.Equal[hunterpettank]}) {
                /call PullVars ${Math.Calc[${PetAttackRange}*.80]} Pet ${Math.Calc[${PetAttackRange}*.80]}
            } else {
                /call PullVars 185 Pet 185
            }
        }
        /if (${PullWith.Equal[Melee]}) {
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /popup You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /if (${DebugPull}) /echo ${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}
                /echo You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /endmac
            } else {
                /call PullVars 15 Melee 15
            }
        }
        DEBUGPULL PullRange Leave \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: PullVars
| -------------------------------------------------------------------------------------
    Sub PullVars(int pRange, pType, int pRange2)
        DEBUGPULL PullVars Enter \agLine#:${Macro.CurLine}"
        /varset PullRange ${pRange}
        /varset PullWith ${pType}
        /varset PullRangeActual ${pRange2}
        /if (${Bool[${Plugin[MQ2Map]}]}) {
			/squelch /mapfilter CastRadius ${PullRange}
            /squelch /mapfilter SpellRadius ${MaxRadius}
            /squelch /mapfilter PullRadius ${MaxRadius}
            /squelch /mapfilter CampRadius ${CampRadius}
		}
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) /varcalc MaxRadius ${TempMaxRadius}+${PullRangeActual}
        /if (${DebugPull}) /echo MaxRadius is now ${MaxRadius} \agLine#:${Macro.CurLine}
        DEBUGPULL PullVars Leave \agLine#:${Macro.CurLine}"
    /return

Sub CheckHealer
	/declare i int local 0
	/for i 0 to ${Group}
            /if (!${Group.Member[${i}].ID}) /next i
            /if (!${Group.Member[${i}].Present}) /return 1
            /if (${Group.Member[${i}].Hovering}) /return 1
            /if (${Group.Member[${i}].Dead}) /return 1
            |/if (${Select[${Group.Member[${i}].Class.ShortName},CLR,DRU,SHM]} && ${Group.Member[${i}].Dead}) /return 1
            
            |/if (${Group.Member[${i}].Type.Equal[corpse]}) /varset ChainPullHold 1
        /next i
/return 0

| -----------------------------------------------------------------------------------------------------------
| SUB: FindMobToPull(int PullFlag) (NEW VERSION) PullFlag 1 - Find mob and pull  0 - Check to see if there is a mob
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobToPull(int PullFlag)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
		|if we have this on, better check if they have a bandolier they want to use while pulling
		/if (${BandolierOn}) {
			|/echo [${Time}] player wants us to activate Bandolier: ${BandolierPull} for PULL. \agL:${Macro.CurLine}
			|Lemons: Checking all 4 slots here since it's about throwing and stuff. I didn't elsewhere cause it's so long, but I probably should. 
			/if (${Me.Bandolier[${Bandolier[${BandolierPull}]}].Item[1].ID} != ${Me.Inventory[mainhand].ID} || ${Me.Bandolier[${Bandolier[${BandolierPull}]}].Item[2].ID} != ${Me.Inventory[offhand].ID} || ${Me.Bandolier[${Bandolier[${BandolierPull}]}].Item[3].ID} != ${Me.Inventory[ranged].ID} || ${Me.Bandolier[${Bandolier[${BandolierPull}]}].Item[4].ID} != ${Me.Inventory[ammo].ID}) {
	    			/invoke ${Me.Bandolier[${BandolierPull}].Activate}
	    			/delay 1s ${Me.Bandolier[${Bandolier[${BandolierPull}]}].Item[1].ID} == ${Me.Inventory[mainhand].ID}
					/delay 1s ${Me.Bandolier[${Bandolier[${BandolierPull}]}].Item[2].ID} == ${Me.Inventory[offhand].ID}
				|/echo [${Time}] Activated Bandolier: ${BandolierPull}.
			} else {
				|/echo [${Time}] Bandolier: ${BandolierPull} is already active.
			}
		}
		/if (${Group}) {
			|ABOSLUTELY DO NOT PULL IF HEALER IS DEAD YOU IDIOT.
			/call CheckHealer
			/if (${Macro.Return}==1) {
				|/beep
				/echo ${Group Member is dead or gone, holding pulls \agL:${Macro.CurLine}
				/delay 1s
				/return 0
			}
		}
		/if (${Me.Class.CanCast} && ${Me.PctMana}<${MedStart} && !${Me.Mount.ID}) {
			/if (!${Me.Sitting}) {
				/call SitIfNotBard FindMobToPul
			}
		}
        /if (${ChainPull}==2 && ${PullFlag}) /varset ChainPull 1
        /if ((${DMZ} && ${Me.InInstance}==FALSE) || (${PullFlag} && !${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) || (!${PullFlag} && !${Role.Find[puller]}) || ${Pulled} || (${AggroTargetID} && !${ChainPull}) || ${ChainPullHold} || ${DPSPaused}) {
			|A Special flag which means pull once...
			/if (${PullFlag} != 3) {
				/return 0
			} else {
				/echo We are going to pull ONCE in ${Macro.CurSub} \agL:${Macro.CurLine}
			}
		}
		/call MobRadar ${MeleeDistance} FindMobToPull
        /if (${ChainPull} && (${MobCount} > 1 || ${Me.XTarget[${XTSlot2}].ID})) {
			/if (${PullFlag} == 3) {
				/echo Well no mobs found for once pull? ${Macro.CurSub} \agL:${Macro.CurLine}
			}
			/return 0
		}
        /if (${PullFlag}) {
            /if (${ChainPull}) {
                /if (${Target.ID}==${Me.ID}) {
					/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
                    /squelch /target clear
                    /delay 10 !${Target.ID}
                }
                /if (${Me.XTarget[${XTSlot}].ID} && ((!${MyTargetID} && !${Target.ID}) || ${Target.PctHPs}>=${ChainPullHP} || (${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}>=${ChainPullHP}))) {
					/return 0
				}
                /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>75) {
					/return 0
				}
            }
			/if (!${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID} || ${IAmDead}) {
				/if (${PullFlag} != 3) {
					/return 0
				}
			}
			/if (${Select[${Me.Class.ShortName},MAG,NEC,BST]}) {
				/if (${PetRampPullWait} && !${Me.CombatState.Equal[COMBAT]} && ${Select[${Role},pullerpettank]}) /call CheckRampPets
			}
		}
        /if (${DebugPull}) {
			DEBUGPULL FindMobToPull Enter ${PullFlag} \agLine#:${Macro.CurLine}"
		}
        /call SetPullRange ${PullFlag}
        /doevents
        /declare i int local 0
        /declare j int local
        /declare k int local
        /declare l int local
        /declare f1 int local 0
        /declare secpullon int local 0
        /declare PullMob int local 0
        /declare PullMobName string local 0
        /declare PullMobDistance float local 0
        /declare PullMobValid int local 0
        /declare PullCount int local
        /declare DistanceCheck int local
        /declare MobsNearCamp int local
        /declare PullingTimer timer local 5s
        /declare Start1 int local
        /declare WPMobCount int local
        | Sort by path-lengths for MQ2Nav vars
        /declare PathArray[999] int local 0
        /declare PathDistance[999] float local 0
        /declare Smallsub int local 0
        /declare tempSortID int local 0
        /declare tempSortDist float local 0
        /declare i2 int local 0
        /declare CanUseNav int local 0
		/if (${mq2navloaded}) {
			/if (${Navigation.MeshLoaded} && ${UseNav} ) {
				/varset CanUseNav 1
				/if (${PullFlag} == 3) {
					/varset PullMoveUse nav
				}
			}
		}
        /varset Pulling 0
        /call GroupWatch
        /if (${ChainPullHold}) /return 0
	:checksecs
		/if (${PullFlag}) {
           |/echo Looking for Close Range Mobs secpullon = ${secpullon} \agLine#:${Macro.CurLine}
        } else {
           /if (!${SpamTimer}) {
              /echo Checking for Close Range Mobs ${secpullon} \agLine#:${Macro.CurLine}
              /varset SpamTimer 50
           }   
        }
        | Clear alert list 1, add mobs to ignore alert list1, set timer to keep alert list manageable for pulling no alert 1
        /if (!${PullAlertTimer}) {
            | Add Ignore Mob list to alert list
            /call AlertAddToList 1 "${MobsToIgnore}"
            /varset PullAlertTimer 5m
        }
        :FindMob
        | Advpath searches for mobs along the path using Pullwith radius not Maxradius
        /if (${PullPathWpCount} && ${PullPath.Length} && ${PullMoveUse.Equal[advpath]}) {
			/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
            /if (${Target.ID}) /squelch /target clear
            /varset PullMobValid 0 
            | loop through pathwaypoints and check for mobs
            /for k 1 to ${PullPathWpCount}
            /varset WPMobCount 0
            /varset PullMob 0
                /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${Math.Calc[${PullRange}*.8]} zradius ${MaxZRange} targetable noalert 1]}
                /if (${WPMobCount}) {
                    /varset i 0
                    /for l 1 to ${WPMobCount}
                        /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${Math.Calc[${PullRange}*.8]} zradius ${MaxZRange} targetable noalert 1].ID}
                            DEBUGPULL FindMobToPull 1: WP: ${k} MobID ${PullMob} LOS ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} YXZ ${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z} \agLine#:${Macro.CurLine}"
                        /if (${DebugPull}) /delay 1
                        /if (${PullMob} && ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                /if (${k}<${PullPathWpCount}) {
                                    /varcalc i ${k}+1
                                    /while (${i}<=${PullPathWpCount} && ${DistanceCheck}>${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                        /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                        /varcalc i ${i}+1
                                    }
                                    /varset k ${i}
                                }
                            DEBUGPULL FindMobToPull: WP ${k} MobCount ${l} ${WPMobCount} \agLine#:${Macro.CurLine}"
                            /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                            /varset PullMobDistance ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                                /varcalc AdvpathPointNum ${k}
                            /varset AdvpathPointX ${PullPathArrayX[${k}]}
                            /varset AdvpathPointY ${PullPathArrayY[${k}]}
                            /varset AdvpathPointZ ${PullPathArrayZ[${k}]}
                            DEBUGPULL FindMobToPull 2: WP: ${k} Pullmob ${PullMob} Waypoint: ${AdvpathPointNum} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}<${PullRange} \agLine#:${Macro.CurLine}"
                            DEBUGPULL FindMobToPull 2: AdvPull: Pullmob: ${PullMobName} ID ${PullMob} Waypoint: ${PullPathWpCount} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} \agLine#:${Macro.CurLine}"
                            /echo Calling PullValidate for ${PullMob} \agLine#:${Macro.CurLine}
							/call PullValidate ${PullMob} ${PullFlag} ${secpullon}
                            /varset PullMobValid ${Macro.Return}
                            /if (${PullMobValid}) /goto :FoundMob
                        }
                    /next l
                }
            /next k        
            DEBUGPULL FindMobToPull: Mob Not Found. AdvPull: PullFlag: ${PullFlag} Role: ${Role} ID: ${PullMob} PullRange: ${PullRange} \agLine#:${Macro.CurLine}"
            /return 0            
            | Check for mobs in max pull radius for normal,MQ2nav pulling
        } else /if (${CanUseNav} && ${PullMoveUse.Equal[nav]}) {    
            /varset PullCount ${SpawnCount[range ${PullMin} ${PullMax} npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[range ${PullMin} ${PullMax} npc loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else /if (${Select[${Role},hunter,hunterpettank]}) {
            /varset PullCount ${SpawnCount[range ${PullMin} ${PullMax} npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[range ${PullMin} ${PullMax} npc radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else {
            /varset PullCount ${SpawnCount[range ${PullMin} ${PullMax} npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[range ${PullMin} ${PullMax} npc los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        }
        DEBUGPULL FindMobToPull PullFlag:${PullFlag} Pullcount: ${PullCount} MobsNearCamp: ${MobsNearCamp} \agLine#:${Macro.CurLine}"
        /if (!${PullFlag} && ${PullCount} > 0  && ${Spawn[${LastMobPullID}].Distance}>=${MeleeDistance}) {
			/return 0
		}
        /if (!${PullFlag}) /varcalc PullCount ${PullCount}-${MobsNearCamp}
        /if (${PullCount}) {
			/if (!${PullFlag} && ${MobsNearCamp}) {
				/varset f1 2
            } else {
                /varset f1 1
            }
                | Pull mob with shortest path JooJooBean
                /if (${CanUseNav} && ${PullMoveUse.Equal[nav]}) {
                    /varset PullCount ${SpawnCount[range ${PullMin} ${PullMax} npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
                    |/echo NAV Pullcount is:  ${PullCount}  range is: ${MaxRadius} \agLine#:${Macro.CurLine}

                    /for i 1 to ${PullCount}
						|/echo adding ${NearestSpawn[${i}, range ${PullMin} ${PullMax} npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID} \agLine#:${Macro.CurLine}
                        /varset PathArray[${i}] ${NearestSpawn[${i}, range ${PullMin} ${PullMax} npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                        /varset PullMob    ${PathArray[${i}]}
						/if (${Navigation.PathExists[locxyz ${Spawn[${PullMob}].X} ${Spawn[${PullMob}].Y} ${Spawn[${PullMob}].FloorZ}]}) {
							/if (${PullNamedsFirst} && ${Spawn[${PullMob}].Named}) {
								/echo Lets pull nameds first mkay...
								/varset PathDistance[${i}] 1
							} else {
								/varset PathDistance[${i}] ${Navigation.PathLength[locxyz ${Spawn[${PullMob}].X} ${Spawn[${PullMob}].Y} ${Spawn[${PullMob}].FloorZ}]}
								}
							/if (${DebugPull}) /echo [${i}] Succsesfully Added ${Spawn[${PullMob}].ID} ${Spawn[${PullMob}]} at ${Spawn[${PullMob}].X} ${Spawn[${PullMob}].Y} ${Spawn[${PullMob}].FloorZ} (dist :${PathDistance[${i}]}) to the pull array.    
						} else {
							/varset PathDistance[${i}] 100000
						}
                    /next i

                    /for i 1 to ${PullCount}
                        /varset Smallsub ${i}
                        /varset i2 ${Math.Calc[${i} + 1]}
                        /for j ${i2} to ${PullCount}
                            /if (${PathDistance[${j}]} < ${PathDistance[${Smallsub}]}) /varset Smallsub ${j}
                        /next j
                        /varset tempSortID ${PathArray[${i}]}
                        /varset tempSortDist ${PathDistance[${i}]}
                        /varset PathArray[${i}] ${PathArray[${Smallsub}]}
                        /varset PathArray[${Smallsub}] ${tempSortID}
                        /varset PathDistance[${i}] ${PathDistance[${Smallsub}]}
                        /varset PathDistance[${Smallsub}] ${tempSortDist}
                        /if (${i2}==${PullCount}) /break
                        DEBUGPULL FindMobToPull: PathNum: ${PathDistance[${i}]} PathDistance:${PathDistance[${Smallsub}]} \agLine#:${Macro.CurLine}"
                    /next i
                }
				/for i 1 to ${PullCount}
					DEBUGPULL FindMobToPull 1.0:  PullFlag: ${PullFlag} Pullcount: ${PullCount} \agLine#:${Macro.CurLine}"
					/if (${CanUseNav} && ${PullMoveUse.Equal[nav]}) {
						/varset PullMob ${PathArray[${i}]}
						/varset PullMobName ${Spawn[id ${PullMob}].CleanName}
						/if (${PullFlag} == 3) {
							/echo Setting PullMob ${PullMobName} to ${PullMob} \agLine#:${Macro.CurLine}
						}
					   DEBUGPULL FindMobToPull: PullFlag: ${PullFlag} MQ2Nav: Name: ${PullMobName} ID: ${PullMob} \agLine#:${Macro.CurLine}"
					} else /if (${Select[${Role},hunter,hunterpettank]} && ${PullMoveUse.NotEqual[advpath]}) {
					   /varset PullMob ${NearestSpawn[${i}, range ${PullMin} ${PullMax} npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
					   /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
					   /echo Setting PullMob to ${PullMob} ${PullMobName} \agLine#:${Macro.CurLine}
					   DEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Role: ${Role} Name: ${PullMobName} ID: ${PullMob} \agLine#:${Macro.CurLine}"
					} else /if (${PullMoveUse.NotEqual[advpath]}) {
					   /varset PullMob ${NearestSpawn[${i}, range ${PullMin} ${PullMax} npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
					   /if (${PullMob}) /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
					   /echo Setting PullMob to ${PullMob} ${PullMobName} \agLine#:${Macro.CurLine}
					   DEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Normal Name: ${PullMobName} ID: ${PullMob} LOS: ${LineOfSight[${CampYLoc},${CampXLoc},${CampZLoc}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} \agLine#:${Macro.CurLine}"
					}
					/if (${DebugPull}) /echo PullMob is set to ${PullMob}
					/if (${PullMob}) {
						/if (${PullFlag} == 3) {
							/echo we have a mob to pull its ${Spawn[id ${PullMob}]} ${Spawn[id ${PullMob}].Distance} feet away \agLine#:${Macro.CurLine}
						}
						/varset PullMobDistance ${Spawn[id ${PullMob}].Distance}
					}
					DEBUGPULL FindMobToPull 1.1:  PullFlag: ${PullFlag} Pullcount: ${PullCount} Name:  ${PullMobName} MobID: ${PullMob} MobDistance: ${PullMobDistance} MaxRadius: ${MaxRadius} PullRange: ${PullRange} \agLine#:${Macro.CurLine}"
					/varset PullMobValid 0
					/if (${PullMob}) {
						/call PullValidate ${PullMob} ${PullFlag} ${secpullon}
						
						/if (${Macro.Return}) { 
							/varset PullMobValid 1
							/varset ChainPullTemp ${PullMob}
						}
					}
					/if (${PullMobValid}) {
						/if (${PullFlag} == 3) {
							/echo Found a mob to pull: ${Spawn[id ${PullMob}].Name}\agLine#:${Macro.CurLine}
						}
						/goto :FoundMob
					}
				/next i
				/varset ChainPullTemp 0
				/varset PullMob 0
				/varset PullMobDistance 0
			} else {
			   /varset PullMob 0
			   /varset PullMobValid 0
			   /varset ChainPullTemp 0
			   /varset PullMobDistance 0
			}
        :FoundMob
		/if (${PullFlag} == 3) {
			/echo PullMobValid = ${PullMobValid} PullFlag = ${PullFlag} \agLine#:${Macro.CurLine}
        }
		DEBUGPULL FindMobToPull: 1.2: PullFlag: ${PullFlag} Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} Valid: ${PullMobValid} PullCount: ${PullCount} \agLine#:${Macro.CurLine}"
		/if (${PullMobValid}) {
			/if (${PullFlag}) {
				/if (!${PullPathWpCount} && ${Spawn[${PullMob}].Distance3D} < 120 && ${Spawn[${PullMob}].LineOfSight}) {
					/if (${MuleDebug}) /echo Targeting a mob \agLine#:${Macro.CurLine}
					/if (${Spawn[${PullMob}].Type.NotEqual[Corpse]}) /target id ${PullMob}
					/delay 20 ${Target.ID}==${PullMob}
				}
			} else {
				/return ${PullCount}
			}
		} else {
			/if (!${PullFlag}) {
				/return 0
			} else {
				|/echo ok we got this far and there was no valid mob \agLine#:${Macro.CurLine}
				|/echo lets check secondary then, maybe its a slow day... \agLine#:${Macro.CurLine}
				/delay 1s
				/if (!${secpullon} && ${MobsToPullSecondary.NotEqual[NULL]}) {
					/varset secpullon 1
					/goto :checksecs
				}
			}
		}
		DEBUGPULL FindMobToPull: 2.0: PullFlag: ${PullFlag} MobID: ${PullMob} Valid: ${PullMobValid} \agLine#:${Macro.CurLine}"
		/if (${PullMob} && ${Spawn[${PullMob}].ID}) {
			/varset Pulling 1
			| Advpath skill validate mob
			/if (${PullMob} && ${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
				/varset MyTargetID ${PullMob}
				/varset MTIDSetAt ${Macro.CurLine}
				/varset MyTargetName ${Spawn[${PullMob}].CleanName}
				/if (${Spawn[${PullMob}].Distance3D} < 120 && ${Spawn[${PullMob}].LineOfSight}) {
					/if (${MuleDebug}) /echo Targeting a mob 15r
					/target id ${PullMob}
					/delay 20 ${Target.ID}==${PullMob}
				}
				| Is mob really in range. check for spawn lag
				/if (${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}>${PullRange}) {
					/alert add 1 id ${PullMob}
					/echo Mob is OOR after targeting. Trying Again.
					/squelch /target clear
					/varset Pulling 0
					/goto :FindMob
				}
				|/echo Going to validate ${Target} \agLine#:${Macro.CurLine}
				/call ValidateTarget ${PullMob} ${PullFlag}
			} else /if (${Target.ID} && ${Target.ID}==${PullMob}) {
				/if (${PullFlag} == 3) {
					/echo Going to validate ${Target} AGAIN? \agLine#:${Macro.CurLine}
				}
				/call ValidateTarget ${PullMob} ${PullFlag}
			} else {
				/if (${PullMob} && ${Spawn[${PullMob}].ID}) {
					/if (${PullFlag} == 3) {
						/echo Going to validate ${PullMob} AGAIN? \agLine#:${Macro.CurLine}
					}
					/call ValidateTarget ${PullMob} ${PullFlag}
				}
			}
			DEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Target: ${Spawn[${PullMob}].CleanName} Valid: ${ValidTarget} MacReturn ${Macro.Return} \agLine#:${Macro.CurLine}"
			/if (${ValidTarget}==0 || (${Target.ID} && ${PullMoveUse.NotEqual[advpath]} && ${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) {
				DEBUGPULL Failed validate (${ValidTarget}==0 || (${Target.ID} && ${PullMoveUse.NotEqual[advpath]} && ${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}>${MaxRadius}))"
				/squelch /alert add 1 id ${PullMob}
				/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
				/squelch /target clear
				/varset Pulling 0
				/goto :FindMob
			}
            /varset MyTargetID ${PullMob}
			/varset MTIDSetAt ${Macro.CurLine}
            /varset MyTargetName ${Spawn[${PullMob}].CleanName}
			/if (${PullFlag} == 3) {
				/echo Pulling = ${Pulling} MyTargetID = ${MyTargetID} \agLine#:${Macro.CurLine}
				|/mqp on
			}
            /if (${Pulling} && ${MyTargetID}) {
                /if (${PullWith.Equal[Pet]} && (${Me.Pet.Stance.NotEqual[FOLLOW]})) {
					/pet follow
				}
                /if (${Target.ID} && ${Target.ID}!=${PullMob}) {
                   /if (${Me.Combat}) {
						/echo TURNING OFF ATTACK FOR SOME REASON \agLine#:${Macro.CurLine}
						/attack off
					}
					/if (${MuleDebug}) /echo Targeting clear at\agLine#:${Macro.CurLine}
                   /squelch /target clear
                }
				/if (${PullFlag} == 3) {
					/echo calling Pull \agLine#:${Macro.CurLine}
				}
				|/call BroadCast t "PULLING-> Level ${Spawn[${PullMob}].Level} ${Spawn[${PullMob}].CleanName} <- ID:${PullMob} at ${Int[${Math.Distance[${Spawn[${PullMob}].Y},${Spawn[${PullMob}].X}:${CampYLoc},${CampXLoc}]}]} feet.\agLine#:${Macro.CurLine}"
                /call Pull ${PullFlag}
                /if (${ChainPull} && ${ChainPullPause.NotEqual[0]}) {
					/varset ChainPullTimer2 ${Math.Calc[${ChainPullPause.Arg[2,"|"]}+1]}m
				}
                /return 0
            }
        }
        /if (!${PullMob}) {
            /varcalc FailCounter ${FailCounter}+1
            DEBUGPULL FindMobToPull: PullFlag: ${PullFlag} No Valid Target in Range ${MaxRadius} - ${FailCounter} Time(s) Line#:${Macro.CurLine}"
            /if (${FailCounter}>=${FailMax}) {
                /call ClearOutAlerts 1
                /varset FailCounter 0
                /varset PullAlertTimer 0
                /if (${PullWait}) {
                    |/echo Waiting ${PullWait} seconds for mobs to respawn. \agLine#:${Macro.CurLine}
                    /call BroadCast t "PULLING-> Waiting ${PullWait} seconds for mobs to respawn. Line#:${Macro.CurLine}"
                    /call PullDelay ${PullWait}
					/if (!${Me.Sitting} && (${Me.PctMana} < ${MedStart} || ${Me.PctEndurance} < ${MedStart} || ${Me.PctHPs} < ${MedStart}) && ${MedOn}) {
						/call SitIfNotBard
					}
                }
                /if (${Select[${Role},hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    DEBUGPULL FindMobToPull Returning hunter to camp \agLine#:${Macro.CurLine}"
                    /varset ReturnToCamp 1
					/varset ChaseAssist 0
                    /echo ${Role}: There are no mobs within ${MaxRadius} trying to return to camp.
                    /call DoWeMove "FindMobToPull"
                }    
                /return 0
            }
            /if (!${PullingTimer}) /return 0
            /goto :FindMob
        }
        DEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Leave \agLine#:${Macro.CurLine}"
    /return 0
| -------------------------------------------------------------------------------------
| SUB: PullDelay
| -------------------------------------------------------------------------------------
    Sub PullDelay(int TimerAmount)
        /if (${DebugPull}) /echo PullDelay ${TimerAmount} Enter \agLine#:${Macro.CurLine}
        /declare PDTimer timer local ${TimerAmount}s
        /varset Pulling 0
        :WaitForTimer
            /doevents
            /call CheckForCombat 1 PullDelay
            /delay 1
            /if (${PDTimer}) /goto :WaitForTimer
        /if (${DebugPull}) /echo PullDelay Leave \agLine#:${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: PullValidate
| ----------------------------------------------------------------------------
    Sub PullValidate(PVPullMob, int PFlag, int checksec)
        /declare j int local
		/if (!${MobsToPull.Find[All for all]} && ${MobsToPull.NotEqual[All]} && ${MobsToPull.NotEqual[NULL]}) {
			/for j 1 to 25
	            /if (${DebugPull}) {
					DEBUGPULL PullValidate: PFlag: ${PFlag} j = ${j} PullList ${Spawn[id ${PVPullMob}].CleanName}/${MobsToPull.Arg[${j},,]} ${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]} \agLine#:${Macro.CurLine}"
				}
	            /if (${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]}) /goto :MobToPullSkip
	        /next j
			|lets check secondary as well
			/if (${checksec} && ${MobsToPullSecondary.NotEqual[NULL]}) {
				/for j 1 to 25
		        		/if (${DebugPull}) {
							DEBUGPULL PullValidate: PFlag: ${PFlag} j = ${j} PullList ${Spawn[id ${PVPullMob}].CleanName}/${MobsToPullSecondary.Arg[${j},,]} ${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPullSecondary.Arg[${j},,]}]} \agLine#:${Macro.CurLine}"
						}
		        		/if (${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPullSecondary.Arg[${j},,]}]}) {
							/echo nice its slim pickings, and i have a secondary mob to pull its a ${MobsToPullSecondary.Arg[${j},,]}
							/goto :MobToPullSkip
						}
				/next j
			}
			DEBUGPULL PullValidate ${Spawn[id ${PVPullMob}].CleanName} NOT on MobsToPull List \agLine#:${Macro.CurLine}"
			/return 0
        }
	:MobToPullSkip
        DEBUGPULL PullValidate Pulling: ${Spawn[id ${PVPullMob}].CleanName} \agLine#:${Macro.CurLine}"
        | Check spawn for out of range - macro start point as epicEnter
        /if (!${PullPathWpCount} && ${Math.Distance[${Spawn[id ${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Out of Range ${Math.Distance[${Spawn[id ${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius}  \agLine#:${Macro.CurLine}"
            /return 0
        }
        | Check spawn for eye of zomm/tallon ${SpawnCount[pc ${PVPullMob.Right[${Math.Calc[${PVPullMob.Length}-7]}]}]}
        /if (${Spawn[${PVPullMob}].CleanName.Find[Eye of]} && ${SpawnCount[pc ${PVPullMob.Right[${Math.Calc[${PVPullMob.Length}-7]}]}]}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Eye of Zomm/Tallon \agLine#:${Macro.CurLine}"
                /return 0
        }
        | Check spawn for line of sight - no mq2nav
        /if (!${PullPathWpCount} && ${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${PVPullMob}].LineOfSight}) {
			/if (${mq2navloaded}) {
				/if (!${Navigation.MeshLoaded} && ${UseNav} ) {
            		DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No line of sight \agLine#:${Macro.CurLine}"
					/return 0
				}
			} else {
				/return 0
			}
        }
        | Check spawn for Level Range
        /if (${Spawn[${PVPullMob}].Level}<${PullMin} || ${Spawn[${PVPullMob}].Level}>${PullMax}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].Level} invalid target Reason: Invalid NPC Level \agLine#:${Macro.CurLine}"
            /return 0
        }
		| Check pull arc
		/if (${PullArcWidth} > 0) {
            /call FigureMobAngle ${Int[${PVPullMob}]} 
            /if (!${Macro.Return}) {
                DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} ${PullLSide} ${Spawn[id ${PVPullMob}].HeadingTo[${CampYLoc},${CampXLoc}].Degrees} ${PullRSide} invalid target Reason: Mob not within Pull Arc"
                /return 0
            }
        }
        | Check if any PC/toon is near the mob
        /if (${SpawnCount[loc ${Spawn[${PVPullMob}].Y} ${Spawn[${PVPullMob}].X} radius 50 pc]} >= 1 && ${Pulling} && ${Math.Distance[${Spawn[${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${Me.Y},${Me.X}]}>=16) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: PCs near mob \agLine#:${Macro.CurLine} \agLine#:${Macro.CurLine}"
                /return 0
        }
        | Check spawn for 100% health
        /if (${Spawn[${PVPullMob}].PctHPs} <= 99) {
            /if (${DebugPull}) {
				DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Mob not 100% health \agLine#:${Macro.CurLine} \agLine#:${Macro.CurLine}"
            }
			| If chain pulling then target mob to update server.
            /if (${PFlag} && ${Target.ID} != ${PVPullMob}) {
                /echo ${Spawn[${PVPullMob}].CleanName} not at 100% HPs Double checking for server lag PFlag: ${PFlag} MobCount: ${MobCount}\agLine#:${Macro.CurLine}
                /if (${Target.ID}!=${Spawn[${PVPullMob}].ID}) {
					/if (${Target.ID}) {
						/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
						/squelch /target clear
						/delay 1s ${Target.BuffsPopulated}==FALSE
					}
					/if (${MuleDebug}) /echo Targeting a mob 15s
					/target id ${Spawn[${PVPullMob}].ID}
					/delay 1s ${Target.ID}==${Spawn[${PVPullMob}].ID}
					/delay 1s ${Target.BuffsPopulated}
					/delay 1s ${Target.CachedBuffCount}!=-1
				}
                /if (${Target.PctHPs} > 99) /return 1
            }
            /return 0                
        }
        /if (${Spawn[${PVPullMob}].Named} && ((${PFlag} && ${MobCount} && ${Me.XTarget[${XTSlot}].ID}) || !${PFlag})) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No Pull Nameds with Mobs in Camp \agLine#:${Macro.CurLine}"
            /return 0
        }
	/if (${Spawn[${PVPullMob}].Named}) {
		/echo Found a named to pull: ${Spawn[${PVPullMob}].Name}
	}
    /return 1
|-------------------------------------------------------------------------------- 
|SUB: CheckRampPets - Writtten by Trehuggindruid for MuleAssist
|-------------------------------------------------------------------------------- 
    Sub CheckRampPets
        /declare i int local 0
        /if (!${Me.CombatState.Equal[COMBAT]}) {
            | Wait for rampage pets to poof before pulling.
            /for i 0 to 20
                /if (${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /echo +++ My rampage pet is up: (${Spawn[${Me.CleanName}`s_pet0${i}]}|${Spawn[${Me.CleanName}`s_pet0${i}].ID}), HOLDING . . .
                :WaitOnRampagePets
                /delay 1
                    /if (!${Me.CombatState.Equal[COMBAT]} && ${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /goto :WaitOnRampagePets
            /next i
            | /echo - No rampage pet is active, starting pulls.
        }
    /return    
	Sub GrabTheDead
		/if (${DeadGroupMember}==0) {
			/if (${Spawn[group pccorpse].ID}) {
				/if (${Spawn[group pccorpse].Distance3D} < 90) {
					/varset DeadGroupMember ${Spawn[group pccorpse].ID}
					/echo Targeting at\agLine#:${Macro.CurLine}
					/target id ${DeadGroupMember}
					/delay 1s ${Target.ID}==${DeadGroupMember}
					/popup I found ${Target} while pulling. Better grab it. \agLine#:${Macro.CurLine}
					/corpsedrag
					/varset ImDraggingACorpse 1
					/delay 1s ${Target.Distance3D} < 10
					/if (${Target.Distance3D} > 10) {
						/varset DeadGroupMember 0
					}
				}
			} else /if (${Spawn[${Me} pccorpse].ID}) {
				/if (${Spawn[${Me} pccorpse].Distance3D} < 90) {
					/varset DeadGroupMember ${Spawn[${Me} pccorpse].ID}
					/echo Targeting at\agLine#:${Macro.CurLine}
					/target id ${DeadGroupMember}
					/delay 1s ${Target.ID}==${DeadGroupMember}
					/popup I found ${Target} while pulling. Better grab it. \agLine#:${Macro.CurLine}
					/corpsedrag
					/varset ImDraggingACorpse 1
					/delay 1s ${Target.Distance3D} < 10
					/if (${Target.Distance3D} > 10) {
						/varset DeadGroupMember 0
					}
				}
			}
		}
	/return
|-------------------------------------------------------------------------------- 
|SUB: RogDragging - Dragging group corpses
|-------------------------------------------------------------------------------- 	
Sub RogDragging
/if (${Me.Class.Name.Equal[Rogue]} && ${RogCorpseRetrieval} && ${Spawn[group corpse radius ${RogCorpseRadius}].ID} && ${ReturnToCamp}) {
	/declare j int local
	/declare numCorpses ${SpawnCount[group corpse]}
	/declare corpseName1 int local
	/declare corpseName2 int local
	/if (${SpawnCount[group corpse]} == ${SpawnCount[group corpse radius ${CampRadius}]}) /return
	/echo Gonna try to retrieve group corpses back to camp
	/varset rogInvisTimer ${rogInvisTimer.OriginalValue}
	:rogInvis
	/if (!${Me.Invis[4]}) {
		/doability hide
		/doability sneak
	}
	/delay 1s ${Me.Invis[4]}
	/if (!${Me.Invis[4]} && ${rogInvisTimer}) /goto :rogInvis
	/if (!${Me.Invis[4]}) {
		/echo Couldn't sneak/hide
	} else {
		/for j 1 to ${SpawnCount[group corpse]}
			/declare groupCorpse${j} int local ${NearestSpawn[${j}, group corpse].ID}
		/next j

		/for j 1 to ${numCorpses}
			/if (${corpseName2}) /varset corpseName2
			/nav id  ${groupCorpse${j}}
			/tar id  ${groupCorpse${j}}
			/varset corpseName1  ${groupCorpse${j}}
			/delay 1s ${Navigation.Velocity}
			/if (!${Navigation.PathExists[id  ${groupCorpse${j}}]}) {
				DEBUGMOVE No path to corpse"
				/return
			}
			/while (${Spawn[${groupCorpse${j}}].Distance} > 100) {
				/delay 1
			}
			/nav stop
			/delay 2
			/corpsedrag 
			/varset corpseName1 ${groupCorpse${j}}
			/delay 8
			/if (${numCorpses} > ${j}) {
				/if (${Spawn[${groupCorpse${Math.Calc[${j}+1]}}].Distance} < 100) {
					/tar id ${groupCorpse${j}}
					/delay 1s ${Target.ID} == ${groupCorpse${j}}
					/corpsedrag
					/varset corpseName2 ${groupCorpse${Math.Calc[${j}+1]}}
					/delay 5
				}
			}
			/call DoWeMove RogDrag
			/while (!WITHINCAMP) {
				/delay 1
			}
			/if (${corpseName1}) {
				/tar id ${corpseName1}
				/delay 1s ${Target.ID} == ${corpseName1}
				/corpsedrop
				/delay 7
			}
			/if (${corpseName2}) {
				/tar id ${corpseName2}
				/delay 1s ${Target.ID} == ${corpseName2}
				/corpsedrop
				/delay 7
			}
		/next j
	}
}
/return


|Work in progress I can't get this to work... -eqmule
Sub CheckforSpotWithinPetRangeNearTheMob(int targetID, string radius)
	/declare i int local 0
	/declare j float local 0
	/declare XOff float local 0
	/declare YOff float local 0
	/declare ZOff float local 0
	/declare YOffRet float local 0
	/declare XOffRet float local 0
	/declare XMove float local 0
	/declare YMove float local 0
	/declare BaseRadians local
	/declare TempDist int local
	/declare LastDist int local 10000
	|we incrememnt by 5 feet around the circle...
	/declare Multiplier local 10
	/declare FoundZ float local 0
	
	/declare MyHeading float local ${Math.Calc[${Spawn[${targetID}].Heading.Degrees} - ${Multiplier}]}
	/declare BaseRadian float local ${Math.Calc[360 / 36]}
	/for i 1 to 36
		/varcalc XMove ${Math.Cos[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
		/varcalc YMove ${Math.Sin[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
		/varcalc XOff ${Spawn[${targetID}].X} + ( ${Int[${radius}]} * ${XMove} )
		/varcalc YOff ${Spawn[${targetID}].Y} + ( ${Int[${radius}]} * ${YMove} )

		/if (${Navigation.PathExists[locyx ${YOff} ${XOff}]}) {
			/varset TempDist ${Math.Distance[${Me.Y},${Me.X}:${YOff},${XOff}]}
			|/echo ${i}] We have a valid loc at ${YOff} ${XOff} (${TempDist}ft away) \agLine#:${Macro.CurLine}
			/if (${TempDist} < ${LastDist}) {
				/varset LastDist ${TempDist}
				/varset YOffRet ${YOff}
				/varset XOffRet ${XOff}
			}
		}
	/next i
	/if (${LastDist}!=10000) /return ${YOffRet} ${XOffRet}
/return NOT_FOUND
| -------------------------------------------------------------------------------------
| SUB: Pull
| -------------------------------------------------------------------------------------
    Sub Pull(int p_flag)
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
		/if (${p_flag}==3) {
			|Do nothing its a forced pull
			/echo Forced Pull \agLine#:${Macro.CurLine}
		} else {
			/if (${DMZ} && ${Me.InInstance}==FALSE) {
				/return
			}
			/if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}==0) {
				/return
			}
			/if (!${Pulling}) /return
			/if (${DPSPaused}) /return
		}
        DEBUGPULL Pull Enter \agLine#:${Macro.CurLine}"
        /declare PullTimer timer local 50
        /declare PetPullTimer timer local 0
        /declare PullAttempts int local 0 
        /declare StuckCount int local 0 
        /declare PullDist float local ${PullRange}
        /declare tempAmmo string local ${InvSlot[ammo].Item.Name}
        /declare rangedSwitch int local 0
        /declare CalmOldID int local 0
        /declare CalmID int local 0
        /declare CanUseNav int local 0
		/declare NavToSpot int local 0
		/if (${mq2navloaded}) {
			/if (${Navigation.MeshLoaded} && ${UseNav} ) /varset CanUseNav 1
		}
        /declare ammoSwitch int local 0
        /declare WasTwistingPull bool local ${Twist}
        /declare AdvpathPaused int local 0
        /declare WPCurrent int local 0
        /declare AdvpathDirection string local
        /varset Pulled 0
        /varset PullTooFar 0
        /varset CantHit 0
        /varset ToClose 0
        /declare AutoFireOff int local ${AutoFireOn}
        /declare X1 int local
        /declare Y1 int local
        /declare X2 int local
        /declare Y2 int local
        /declare BeginMobID string local
        /declare AdjustHeadingTimer timer local 0
        DEBUGPULL Pull: PullWith:${PullWith} PullDist: ${PullDist} \agLine#:${Macro.CurLine}"
        | Set autofire setting off during pulls if not using ranged item to pull
        /if (${AutoFireOff}) /varset AutoFireOn 0
        /if (${IAmABard}) {
			/if (!${PullTwistOn} && ${WasTwistingPull}) { 
				/squelch /twist stop
				/varset TwistStop ${Macro.CurLine}
				/if (${MuleDebug}) /echo Stopping twist \ag${Macro.CurLine}
			}
        }
        |/if (!${Me.Mount.ID} && ${Me.Sitting}) {
		|	/echo going to stand \agLine#:${Macro.CurLine}
		|	/multiline ; /echo Standing at ${Macro.CurLine} ; /if (!${standTimer}) /stand
		|}
        /if (${p_flag}!=3 && ${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}!=${Me.ID}) {
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) {
				/call TogglePullMode TurnOn
			}
        }
		/varset BeginMobID ${Me.XTarget[${XTSlot}].ID}
		:PullAgain
		/if (${GrabDeadGroupMembers}) {
			/call GrabTheDead
		}
		/doevents 
        /if (${DPSPaused}) /return  
        | vars used to determine if we are stuck
        /varset X1 ${Int[${Me.X}]}
        /varset Y1 ${Int[${Me.Y}]}            
        /if ((${AggroTargetID} && !${ChainPull}) || (${ChainPull} && ${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID}))) {
			DEBUGPULL Pulling 1.1 \agLine#:${Macro.CurLine}
            /varset Pulled 1
            /varset MyTargetID ${AggroTargetID}
			/varset MTIDSetAt ${Macro.CurLine}
            /varset MyTargetName ${Spawn[${AggroTargetID}].CleanName}
            /if (${mq2navloaded}) {
				/if (${Navigation.Active}) {
					/echo stopping nav \agLine#: Pull\agLine#:${Macro.CurLine}
					/nav stop
				}
			}
            /if (${MoveTo.Moving}) /moveto off
            DEBUGPULL Pull Aggro detected \agLine#:${Macro.CurLine}"
            /goto :DonePulling
        }
		| Exit pull and reset if timed out or wandered too far from camp
		DEBUGPULL Pulling 1.2 PullTimer: ${PullTimer} Distance: ${Math.Distance[${CampYLoc},${CampXLoc}]} MaxRadius: ${MaxRadius} PullAttempts: ${PullAttempts} MyTargetID: ${Spawn[${MyTargetID}].ID}  Target LOS: ${Spawn[${MyTargetID}].LineOfSight} \agLine#:${Macro.CurLine}"
        
		/if (${CanUseNav}) {
			/if (${Navigation.PathLength[locxyz ${Spawn[${MyTargetID}].X} ${Spawn[${MyTargetID}].Y} ${Spawn[${MyTargetID}].FloorZ}]} > ${MaxRadius}) {
				/squelch /alert add 1 id ${MyTargetID}
				DEBUGPULL Pull: /echo Adding ${Spawn[${MyTargetID}].CleanName} ID: ${MyTargetID} to temp ignore list \agLine#:${Macro.CurLine}"
				/if (${ReturnToCamp}) {
					/call DoWeMove "FindMobToPull 2" ${p_flag}
				}
				DEBUGPULL Pull: Done Pulling, Mob unreachable or exceeded max pull radius. \agLine#:${Macro.CurLine}"
				/call PullReset
				/return
			}
		}
		/if (${PullTimer}==0 || ${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius} || ${PullAttempts}>=7 && !${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]} || !${Spawn[${MyTargetID}].ID}) {
            /squelch /alert add 1 id ${MyTargetID}
            DEBUGPULL Pull: Adding ${Spawn[${MyTargetID}].CleanName} ID: ${MyTargetID} to temp ignore list (${PullTimer}==0 || (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius} && ${ReturnToCamp}) || ${PullAttempts}>=7 && !${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]} || !${Spawn[${MyTargetID}].ID})"
            /if (${ReturnToCamp}) {
                /call DoWeMove "FindMobToPull 2" ${p_flag}
            }
            DEBUGPULL Pull: Done Pulling-Timer expired, Mob unreachable or exceeded max pull radius. \agLine#:${Macro.CurLine}"
			|Lemons: Removed (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) cause we have to reset the pull no matter what. Also not sure why we are checking for campradius after we've determined we are outside the MaxRadius
			/call PullReset
			/return
        }
        /if (((${AggroTargetID} && !${ChainPull}) || (${Me.XTarget[${XTSlot2}].ID} && ${ChainPull})) && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
            /echo Looks like mobs in camp aborting pull.
            /call PullReset
            /if (!${ChainPull}) /call CheckForCombat 1 Pull
            DEBUGPULL Pull Mobs in camp detected \agLine#:${Macro.CurLine}"
            /return
        }
        /if (${PullWith.Equal[Ranged]}) {
            DEBUGPULL Pull: Ranged \agLine#:${Macro.CurLine}"
            | Cursor check sometimes summoned items get stuck on cursor.
            /if (${Cursor.ID}) /autoinventory
            /if (${OrigRanged.NotEqual[${PullItem}]} && ${OrigRanged.NotEqual[null]}) {
                /call CheckCasting 50
                /exchange "${PullItem}" ranged
                /varset rangedSwitch 1
                /delay 10
            }
            /if (${tempAmmo.NotEqual[null]} && ${tempAmmo.NotEqual[${PullAmmo}]}) {
                /call CheckCasting 50
                /exchange "${PullAmmo}" ammo
                /delay 10
                /if (${tempAmmo.NotEqual[${PullAmmo}]}) /varset ammoSwitch 1
            }
        }
        | - Filter to prevent pulling until AA/Disc/Spell/Item is ready.
        DEBUGPULL Check Ability: ${AggroTargetID} ${ChainPull} ${Select[${PullWith},Melee,Pet,Ranged]} ${Me.SpellReady[${PullWith}]} ${Me.AltAbilityReady[${PullWith}]} ${Me.CombatAbilityReady[${PullWith}]} ${Me.ItemReady[${PullWith}]} ${PullWith} ${PullWith.Equal[Ranged]} ${Me.RangedReady} \agLine#:${Macro.CurLine}"
        /if (${PullTimer} && (!${AggroTargetID} && !${ChainPull}) && ((!${Select[${PullWith},Melee,Pet,Ranged]} && !${Select[TRUE,${Me.SpellReady[${PullWith}]},${Me.AltAbilityReady[${PullWith}]},${Me.CombatAbilityReady[${PullWith}]},${Me.ItemReady[${PullWith}]}]}) || (${PullWith.Equal[Ranged]} && !${Me.RangedReady}))) {
			DEBUGPULL PullingAgain (${PullTimer} && (!${AggroTargetID} && !${ChainPull}) && ((!${Select[${PullWith},Melee,Pet,Ranged]} && !${Select[TRUE,${Me.SpellReady[${PullWith}]},${Me.AltAbilityReady[${PullWith}]},${Me.CombatAbilityReady[${PullWith}]},${Me.ItemReady[${PullWith}]}]}) || (${PullWith.Equal[Ranged]} && !${Me.RangedReady})))"
			/goto :PullAgain
		}
        DEBUGPULL Pull Starting \agLine#:${Macro.CurLine}"
        /varset PullAttempts 0
        | Set group role puller to adjust for merc running up while pulling if soloing
        /if (${Group}==1 && !${Group.Puller.Name.Equal[${Me}]} && ${Select[${Role},puller]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) {
			/call AssignGroupRole set "${Me.CleanName}" 3
		}
		DEBUGPULL Pull: ((${Spawn[${MyTargetID}].Distance} > ${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]} < ${MaxRadius})"		
		/if ((${Spawn[${MyTargetID}].Distance} > ${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]} < ${MaxRadius}) {
			DEBUGPULL Pull is fine PullDist = ${PullDist} ${Spawn[${MyTargetID}]}.LineOfSight = ${Spawn[${MyTargetID}].LineOfSight}"
			:WeThereYet
			| Advpath pull does not use max pull radius. It uses pullwith radius
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]} && ${mq2advpathloaded}) {
                /play ${PullPath} nodoor smart normal 
                DEBUGPULL Pull /play ${PullPath} nodoor smart normal \agLine#:${Macro.CurLine}"
				:RunningThePath 
                |/if (${DebugPull}) /delay 5 
                /if (${DebugPull}) {
					DEBUGPULL Pull /echo Waypoint: ${AdvPath.NextWaypoint} Target: ${Target.ID} MyTargetID: ${MyTargetID} Aggro: ${AggroTargetID} MobToWPDist: ${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}<${PullDist} MeToWPDist: ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}>50 WP<NWP: ${AdvPath.NextWaypoint}>=${AdvpathPointNum} \agLine#:${Macro.CurLine}"
                }
				| Do we have aggro?
				/if (${AggroTargetID}) {
					/goto :StopPath
				}
				| Has the mob moved out of range from the original way point
                /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}>${PullDist}) {
					/goto :StopPath
				}
                | Is mob within pull range and LOS
                /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${Me.Y},${Me.X}]}<${PullDist} && ${Spawn[${MyTargetID}].LineOfSight}) {
					/goto :StopPath
				}
                | Stop at our waypoint
                /if (${AdvPath.NextWaypoint}>=${AdvpathPointNum} && ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}<=5) {
                    /varset WPCurrent ${AdvPath.NextWaypoint}
                    /goto :StopPath
                }
                /goto :RunningThePath
                :StopPath
				/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
				/if (${AdvPath.Playing}) /play off
                DEBUGPULL Pull /play ${PullPath} nodoor smart normal \agLine#:${Macro.CurLine}"
				|/echo Is Pull mob inside range of max pull radius and not using advpath
            } else /if (${CanUseNav} && !${Select[${Role},hunter,hunterpettank]}) {
				/varset PullDist ${PullRange}
               	/if (${Navigation.PathExists[id ${MyTargetID}]}==FALSE) {
					/if (${PullWith.Equal[Pet]}) {
						 /if (${Spawn[${MyTargetID}].Distance} > 150) {
							/call CheckforSpotWithinPetRangeNearTheMob ${MyTargetID} 160
							|/echo CheckforSpotWithinPetRangeNearTheMob returned ${Macro.Return} \agLine#:${Macro.CurLine}
							/if (${Macro.Return.NotEqual[NOT_FOUND]}) {
								/varset NavToSpot 1
								/squelch /nav locyx ${Macro.Return}
								/echo Ok Cool, we actually CAN pull it with pet I found a nice loc at ${Macro.Return} \agLine#:${Macro.CurLine}
								/delay 1s ${Navigation.Active}==TRUE
								/delay 20s ${Navigation.Active}==FALSE
							} else {
								/echo Can't Pull with pet even because I can't get closer to ${Spawn[id ${MyTargetID}]} No Path exist\agLine#:${Macro.CurLine}
								/return
							}
						 }
					} else {
						|/call CheckforSpotWithinPetRangeNearTheMob ${MyTargetID} 50
						/if (${Macro.Return.NotEqual[NOT_FOUND]}) {
							/varset NavToSpot 1
							/squelch /nav locyx ${Macro.Return}
							/echo Ok Cool, we actually CAN pull it I found a nice loc at ${Macro.Return} \agLine#:${Macro.CurLine}
							/delay 1s ${Navigation.Active}==TRUE
							/delay 40s ${Navigation.Active}==FALSE

						} else {
							/echo Can't Pull ${Spawn[id ${MyTargetID}]} (${MyTargetID}) No Path exist.\agLine#:${Macro.CurLine}
							/delay 5
							/squelch /alert add 1 id ${MyTargetID}
							/return
						}
					}
				}
				/if (${p_flag}==3) {
					/echo Issuing nav command for forced pull \agLine#:${Macro.CurLine}
				}
				/if (${PullWith.Equal[Pet]} && ${Spawn[${MyTargetID}].Distance} > 150) {
					/echo PullWith = ${PullWith} PullDist = ${PullDist} (real dist is ${Navigation.PathLength[locxyz ${Spawn[${MyTargetID}].X} ${Spawn[${MyTargetID}].Y} ${Spawn[${MyTargetID}].FloorZ}]} Issuing /nav id in Pull to spawn ${Spawn[id ${MyTargetID}]} \agLine#:${Macro.CurLine}
					/if (${NavToSpot}==0) {
						/nav spawn id ${MyTargetID} | dist=150
						/varset PullDist 150
					} else {
						|special pull. called above already
					}
				} else {
					/if (${PullWith.Equal[Pet]}) {
						/echo no need to run to it we are pet pulling
						/goto :NavPullRelease
					} else {
						/nav spawn id ${MyTargetID} | dist=10
						/varset LastMove ${Macro.CurLine}
					}
				}
               	| Timer for /nav to adjust heading when mob is moving
               	/varset AdjustHeadingTimer 20
				:DistanceCheck
               	/delay 2
               	/if (${PullTimer}==0) {
					/goto :NavPullRelease
				}
               	|Corrects heading when mob is moving and you're using Navigation.
               	/if (${Spawn[${MyTargetID}].Speed} > 25 && !${AdjustHeadingTimer}) {
               	    /nav id ${MyTargetID}
               	    /varset AdjustHeadingTimer 20
               	}
               	| Check for Unexpected Aggro
               	/if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID})) && ${ChainPull})) {
					/goto :PullAgain
				}
				| Check for being to far from camp.
               	/if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius}) {
               		/if (${Navigation.Active}) {
						DEBUGPULL Stopping nav cause I'm too far from camp (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius})"
						|/nav stop
					}
					/if (${ReturnToCamp}) {
						/call DoWeMove "FindMobToPull 3" ${p_flag}
					}
                   	/if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                   		/call PullReset
						/if (${DebugPull}) /echo Returning from ${Macro.CurSub} \agLine#:${Macro.CurLine}
                    	/return
                    }
				}
                /if ((${Spawn[${MyTargetID}].Distance} > ${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) {
					/goto :DistanceCheck
				}
				:NavPullRelease
                /if (${Navigation.Active} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance} < ${Math.Calc[${PullDist}-3]}) {
					/echo Stopping nav \agLine#:${Macro.CurLine}
					/nav stop
				}
				/if (${DebugPull}) /echo Pulling ${PullDist} ${Target.Distance} \agLine#:${Macro.CurLine}
				| We are pulling by LOS.  
			} else /if (${Spawn[${MyTargetID}].LineOfSight}) {
						/if (${DebugPull} || ${p_flag}==3) /echo using moveto because we can see the target \agLine#:${Macro.CurLine}
						/moveto id ${MyTargetID} mdist ${PullDist}
						/delay 3
						/varset X2 ${Int[${Me.X}]}
						/varset Y2 ${Int[${Me.Y}]}            
						DEBUGPULL Pull LOS ${Spawn[${MyTargetID}].LineOfSight} ${PullDist} \agLine#:${Macro.CurLine}"
					} else {
						DEBUGPULL We can NOT see the mob yet "
						|Lemons: I don't understand this. We can't see the mob....and we haven't even tried to move yet as a hunter. Does hunter ONLY work on LoS? Why?
						|I added in an attempt to Nav to the mob. This fixed the LoS issue I was seeing. Not sure if this will break other Hunter behavior.
						/nav spawn id ${MyTargetID} | dist=10
						| Timer for /nav to adjust heading when mob is moving
						/varset AdjustHeadingTimer 20
						:DistanceCheckH
						/delay 2
						/if (${PullTimer}==0) {
							/goto :NavPullReleaseH
						}
						|Corrects heading when mob is moving and you're using Navigation.
						/if (${Spawn[${MyTargetID}].Speed} > 25 && !${AdjustHeadingTimer}) {
							/nav id ${MyTargetID}
							/varset AdjustHeadingTimer 20
						}
						| Check for Unexpected Aggro
						/if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID})) && ${ChainPull})) {
							/goto :PullAgain
						}
						| Check for being to far from camp.
						/if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius}) {
							/if (${Navigation.Active}) {
								/echo Stopping nav \agLine#:${Macro.CurLine}
								/nav stop
							}
							/if (${ReturnToCamp}) {
								/call DoWeMove "FindMobToPull 3" ${p_flag}
							}
							/if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
								/call PullReset
								/if (${DebugPull}) /echo Returning from ${Macro.CurSub} \agLine#:${Macro.CurLine}
								/return
							}
						}
						/if ((${Spawn[${MyTargetID}].Distance} > ${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) {
							/goto :DistanceCheckH
						}
						:NavPullReleaseH
						/if (${Navigation.Active} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance} < ${PullDist}) {
							/echo Stopping nav \agLine#:${Macro.CurLine}
							/nav stop
						}
				
				
						/if (${X2}!=0 && ${Math.Distance[${Me.Y},${Me.X}:${Y2},${X2}]} > 200) {
							/if (${Select[${Role},hunter,hunterpettank]}) {
								/call PullReset
								/echo Returning from ${Macro.CurSub} because pullmob is more than 200 ft away.\agLine#:${Macro.CurLine}
								/delay 1s
								/return
							}
							/echo Mob is no Longer in LOS. Returning to Camp. \agLine#:${Macro.CurLine}
							/squelch /alert add 1 id ${MyTargetID}
							/if (${MoveTo.Moving}) {
								/moveto off
							}
							/if (${ReturnToCamp}) {
								/call DoWeMove "FindMobToPull 4" ${p_flag}
							}
							/if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
								/call PullReset
								/if (${DebugPull}) /echo Returning from ${Macro.CurSub} \agLine#:${Macro.CurLine}
								/return
							}
						}
					}
			}
			DEBUGPULL We got this far... \agLine#:${Macro.CurLine}"
			/varset CantSee 0
			/doevents
			|Checking to see if you are far from camp to try and fix the exceed to far from camp check.
			/if (!${PullPathWpCount} && (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius})) {
				DEBUGPULL Pull: Pulling again"
				/goto :PullAgain
			}
			/if (${DPSPaused} && ${p_flag}!=3) /return 
			| Extending PullTimer if moving closer or target moving && !${Select[${Role},hunter]})
			/if (!${PullPathWpCount}) {
				/if (${mq2navloaded}) {
					/if (${Navigation.Active} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed} > 25 && ${Spawn[${MyTargetID}].Distance} > ${PullRange})) {
						/varcalc PullTimer ${PullTimer}+50
					}
				} else {
					/if (${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed} > 25 && ${Spawn[${MyTargetID}].Distance} > ${PullRange})) {
						/varcalc PullTimer ${PullTimer}+50
					}
				}
			}
            | Pull counter used to in conjunction with 1s delay for timing
            /varcalc PullAttempts ${PullAttempts}+1
            | Try and pull again after 7 seconds or 3 seconds if target is moving
            /if (!${PullPathWpCount}) {
                /if (${PullAttempts} >= 7) {
                    | Make range smaller to creep closer to mob if not los
                    /if (${Spawn[${MyTargetID}].Distance}<=${PullDist} && !${Spawn[${MyTargetID}].LineOfSight}) {
						/varcalc PullDist ${PullDist}*.6
					}
                    DEBUGPULL Pull PullDist: ${PullDist} - PullLoops: ${PullAttempts} LineOfSight: ${Spawn[${MyTargetID}].LineOfSight} \agLine#:${Macro.CurLine}"
                    /goto :PullAgain
                } else /if (${PullAttempts}>=3 && ${Spawn[${MyTargetID}].Speed}>25) {
                    | Make range smaller to creep closer to mob if Mob is Moving
                    /varcalc PullDist ${PullDist}*.6
                   DEBUGPULL Pull PullDist: ${PullDist}*.6 - PullLoops: ${PullAttempts} \agLine#:${Macro.CurLine}"
                    /goto :PullAgain
                }
            }
            | Timer used in conjunction with PullAttempts to control pulling
            /delay 2
			DEBUGPULL are we stuck? better check \agLine#:${Macro.CurLine}"
			/if ((${Int[${Me.X}]}==${X1}) && (${Int[${Me.Y}]}==${Y1})) {
				/varcalc StuckCount (${StuckCount})+1
				/if (${StuckCount}>=2) {
					/if (${IAmDead} || ${Me.Hovering}) {
						/echo Stopping now because im dead. and returning from ${Macro.CurSub} \agLine#:${Macro.CurLine}
						/if (${MoveTo.Moving}) {
							/moveto off
						}
						/if (${Navigation.Active}) {
							/echo Stopping nav \agLine#:${Macro.CurLine}
							/nav stop
						}
						/if (${AdvPath.State}) {
							/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
							/play off
						}
						/return
					} else {
						/call Stuck
					} 
				}
				/if (${StuckCount} >= 7 && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) {
					/echo I am stuck aborting pull
					/varset StuckCount 0
					/squelch /alert add 1 id ${MyTargetID}
					/if (${MoveTo.Moving}) /moveto off
					/if (${mq2navloaded}) {
						/if (${Navigation.Active}) {
							/echo Stopping nav \agLine#:${Macro.CurLine}
							/nav stop
						}
					}
					/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
					/if (${AdvPath.State}) /play off
					/if (${ReturnToCamp}) {
						/call DoWeMove "FindMobToPull 5" ${p_flag}
					}
					/if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
						/call PullReset
						/if (${DebugPull}) /echo Returning from ${Macro.CurSub} \agLine#:${Macro.CurLine}
						/return
					}
				}
			}
			DEBUGPULL Pull Loop Count: ${PullAttempts} \agLine#:${Macro.CurLine}"
			| Not using advpath
			/if (!${PullPathWpCount}) {
				| Distance loop check until mob in range to pull
				/if ((${Spawn[${MyTargetID}].Distance} > ${PullRange} || (!${Spawn[${MyTargetID}].LineOfSight} && ${PullWith.NotEqual[Pet]})) && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) {
					|/echo \atDEBUGPULL Looping up to WeThereYet ${Spawn[${MyTargetID}]}.LineOfSight = ${Spawn[${MyTargetID}].LineOfSight} PullRange = ${PullRange}\agLine#:${Macro.CurLine}
					|/if (${DebugPull} || ${p_flag}==3) /echo \atDEBUGPULL Looping up to WeThereYet ${Spawn[${MyTargetID}]}.LineOfSight = ${Spawn[${MyTargetID}].LineOfSight} PullRange = ${PullRange}\agLine#:${Macro.CurLine}
					/goto :WeThereYet
				}
				| If mob moves out of line of sight during pull try moveto mob again
				/if ((!${Spawn[${MyTargetID}].LineOfSight} && ${PullWith.NotEqual[Pet]}) && !${Select[${Role},hunter,hunterpettank]} && ${PullTimer}) {
					/varcalc PullDist ${PullDist}*.8
					DEBUGPULL Pull Decrease pull distance to ${PullDist} \agLine#:${Macro.CurLine}"
					/goto :PullAgain
				}
				/if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID})) && ${ChainPull})) {
					/goto :PullAgain
				}
			}
			/if (${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance} < ${PullRange} && ((!${AggroTargetID} && !${ChainPull} ) || ( !${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull} ))) {
				/if (${MoveTo.Moving}) /moveto off
				/if (${mq2navloaded}) {
					/if (${Navigation.Active}) {
						/echo Stopping nav \agLine#:${Macro.CurLine}
						/nav stop
					}
				}
				/if (${mq2advpathloaded}) {
					/if (${AdvPath.State}) /play off
					/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
	    		}
				| Target mob before Aggroing
				/if (${DebugPull} || ${p_flag}==3) /echo Targeting a mob ${Spawn[${MyTargetID}]} \agLine#:${Macro.CurLine}
				/target id ${MyTargetID}
				/delay 1s ${Target.ID}==${MyTargetID}
				/delay 1s ${Target.BuffsPopulated}
				/delay 1s ${Target.CachedBuffCount}!=-1
				| Validate target one more time before pulling
				DEBUGPULL Going to validate ${Target} \agLine#:${Macro.CurLine}"
				/call ValidateTarget ${MyTargetID} ${p_flag}
				/if (${Target.ID}==${MyTargetID}) {
					/if (${Me.TargetOfTarget.ID}) {
						/if (${Me.TargetOfTarget.ID} != ${Me.ID} && !${Group[${Spawn[${Me.TargetOfTarget.ID}]}]}) {
							/if (${Me.TargetOfTarget.Type.Equal[PC]} || ${Me.TargetOfTarget.Type.Equal[PET]}) {
								|/beep
								/echo Crap ${Me.TargetOfTarget} has ${Spawn[${MyTargetID}]} engaged, not gonna pull it. \agLine#:${Macro.CurLine}
								/varset ValidTarget 0
							}
						}
					}
				}
				DEBUGPULL PullCondition Check: |${PullCond}| on target: ${Target}"
				/if (${If[${PullCond},0,1]}) {
					/echo Pull Condition is False ${PullCond} | ${PullCond.Replace[$,#]}|. Setting ValidTarget to 0
					DEBUGPULL Pull Condition is False ${PullCond}. Setting ValidTarget to 0"
					/varset ValidTarget 0
					/if (${ReturnToCamp}) {
						/call DoWeMove "FindMobToPull 6" ${p_flag}
					}
					/if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
						/call PullReset
						/if (${DebugPull}) /echo Returning from ${Macro.CurSub} \agLine#:${Macro.CurLine}
						/return
					}
					/return
				}
				/if (${ValidTarget}==0) {
					/squelch /alert add 1 id ${Target.ID}
					/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
					/squelch /target clear
					/echo Aborting Pull! Target invalid now! Reason:${Macro.Return}
					/if (${ReturnToCamp}) {
						/call DoWeMove "FindMobToPull 6" ${p_flag}
					}
					/if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
						/call PullReset
						/if (${DebugPull}) /echo Returning from ${Macro.CurSub} \agLine#:${Macro.CurLine}
						/return
					}
					/return
				}
				DEBUGPULL Pull: ${PullWith} should pull ${Spawn[${MyTargetID}]} (${MyTargetID})\agLine#:${Macro.CurLine}"
				/if (${PullWith.Equal[Melee]} || (${PullWithAlt.Equal[Melee]} && ${ToClose})) {
					/if (${DebugPull}) /echo Handle pulling with Melee setting \agLine#:${Macro.CurLine}
					/if (!${Select[${Role},hunter,hunterpettank]}) {
						| Turn off mq2melee function so puller and pullertank doesn't attack mob on pull
						/if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) {
							/squelch /melee melee=0
						}
						:AttackAgain
						DEBUGMOVE Moveto "
						/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
						/moveto id ${MyTargetID} mdist 5
						/if (${Target.ID}) {
							/if (${MuleDebug}) /echo face \agLine#:${Macro.CurLine}
							/face nolook
							DEBUGCOMBAT Facing ${Target}"
						}
						/look 0
						DEBUGCOMBAT I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
						/attack on
						/if (${PullMeleeStick} && !${AggroTargetID}) {
							/stick id ${MyTargetID} 30%
						}
						/delay 5
						/if (((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${ChainPull})) && ${Target.PctHPs}==100) {
							/goto :AttackAgain
						}
						| Turn off combat so puller returns to camp. You mean run like hell.
						/if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) {
							:StopCombat
							/attack off
							/if (${Stick.Active}) /stick off
							/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
							/squelch /target clear
							| Cycle until combat off and mob is aggro'd
							/if (${Me.Combat} && ((${AggroTargetID} && !${ChainPull}) || ${Target.PctHPs}<100)) {
								/goto :StopCombat
							}
							| Turn on mq2melee function back on after pull
							/if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=1
						}
					}
					/varset Pulled 1
					/varset ToClose 0
				} else /if (${PullWith.Equal[Ranged]} && !${ToClose}) {
					DEBUGPULL PULL: Ranged \agLine#:${Macro.CurLine}"
					:RangedAgain
                    /doevents
                    /if (${ToClose}) {
						/varset PullDist 15
						/goto :PullAgain
                    }
                    /if (${DPSPaused}) {
						DEBUGPULL Returning from ${Macro.CurSub} because dps is paused... \agLine#:${Macro.CurLine}"
						/return
					}
                    /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})) {
                        /varset Pulled 1
						DEBUGPULL going to jump down to DonePulling \agLine#:${Macro.CurLine}"
                        /goto :DonePulling
                    }
                    /if (${CantHit}) {
                        /varset CantHit 0
                        /varcalc PullDist ${PullDist}*.8
                        /goto :PullAgain
                    }
					/if (${CantSee}) {
						/if (${Target.ID}) {
							/if (${MuleDebug}) /echo face 3
							/squelch /face nolook
						}
						/delay 5
						/varset CantSee 0
						/if (${DebugPull}) /echo Cannot Not see the Target. Trying Again. \agLine#:${Macro.CurLine}
					}
					| Mod for puller to turn back to camp after /range this saves on the puller turning AFTER mob is aggroed  and turns facing camp while waiting for mob to aggro.
					/if (${Me.Combat}) {
						/Attack off
						/delay 20 !${Me.Combat}
					}
					/if (${Stick.Active}) /stick off
					/if (${Target.ID}) {
						/if (${MuleDebug}) /echo face 4
						/squelch /face nolook
						DEBUGCOMBAT Facing ${Target}"
					}
					/look 0
					/delay 20 ${Me.Heading.ShortName.Equal[${Target.HeadingTo}]}
					/if (${Target.ID}==${MyTargetID}) /range
					/if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
						/delay 5
						/if (${Target.ID}) {
							/if (${MuleDebug}) /echo facing nolook loc ${CampYLoc},${CampXLoc}
							/squelch /face nolook loc ${CampYLoc},${CampXLoc}
						}
                    }
                    /if (!${ChainPull}) {
                        /delay ${Math.Calc[1+${Target.Distance}/50].Int}s ${AggroTargetID}
                    } else {
                       /delay ${Math.Calc[1+${Target.Distance}/50].Int}s ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}
                    }
                    DEBUGPULL Pull: ${PullTimer} && (!${AggroTargetID} || ${Target.PctHPs}==100) ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID} \agLine#:${Macro.CurLine}"
                    /if (${PullTimer} && !${PullTooFar} && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${ChainPull}))) {
						/goto :RangedAgain
					}
                    /if (${AggroTargetID}) {
                        /varset Pulled 1
						DEBUGPULL going to jump down to DonePulling \agLine#:${Macro.CurLine}"
                        /goto :DonePulling
                    }
				| PetPull section - Written by TreeHuginDruid for RedGuides
				} else /if (${PullWith.Equal[Pet]}) {
					|DEBUGPULL Pull: Pet \agLine#:${Macro.CurLine}"
					/echo \atPull: ${PullWith} should pull ${Spawn[${MyTargetID}]} (${MyTargetID})\agLine#:${Macro.CurLine}
					/if (${Target.ID}) {
						| It's a pet pull who cares if i face the mob...
						|/if (${MuleDebug}) /echo face \agLine#:${Macro.CurLine}
						|/echo face \agLine#:${Macro.CurLine}
						|/face nolook
					}
					|- Ensure we are in pull range and pet is following!                              
					/if (${Me.Pet.Stance.NotEqual[FOLLOW]}) {
						/pet follow
					}
					| - Send in pet if I don't have a mob in extended target)
					/varset PetPullTimer 45s
					| We don't have to spam the server with this packet, once should be enough
					/if (${MuleDebug}) /echo Pet attacking at \ag${Macro.CurLine}
					/pet attack ${MyTargetID}
					:SendInPet
					/if ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${ChainPull})) {
						|/echo \atPull: sending in pet to attack ${Spawn[${MyTargetID}]} (${MyTargetID})\agLine#:${Macro.CurLine}
						/delay 10 (${AggroTargetID} && !${ChainPull}) || ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID} 
						| Fix for HunterPetTank
						/if (${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Type.NotEqual[corpse]} && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Me.Pet.ID} && ${ChainPull}))) {
							/if (${PetPullTimer}) {
								/goto :SendInPet
							} else {
								|/beep
								/echo Timer expired we are obviously in a spot where pet cannot attack the target for some reason, lets fix that. \agLine#:${Macro.CurLine}
								/call CheckforSpotWithinPetRangeNearTheMob ${MyTargetID} 100
								/if (${Macro.Return.NotEqual[NOT_FOUND]}) {
									/varset NavToSpot 1
									/squelch /nav locyx ${Macro.Return}
									/echo Ok Cool, we actually CAN pull it with pet I found a nice loc at ${Macro.Return} \agLine#:${Macro.CurLine}
									/delay 1s ${Navigation.Active}==TRUE
									/delay 20s ${Navigation.Active}==FALSE
									/pet attack ${MyTargetID}
									/if (${MuleDebug}) /echo Pet attacking at \ag${Macro.CurLine}
									/varset PetPullTimer 45s
									/goto :SendInPet
								} else {
									/echo Can't Pull with pet even because I can't get closer to ${Spawn[id ${MyTargetID}]} No Path exist\agLine#:${Macro.CurLine}
									/return
								}
							}
						}
					}
					| - If I have a extended target, flag as pulled.
					/if ((${AggroTargetID} && !${ChainPull}) || ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) {
						/varset Pulled 1
						/if (${PetHoldOn}) /pet ${PetHold} on
						/pet back off
						/goto :DonePulling
					} 
				} else {
					DEBUGPULL Pull: ${PullWith} should pull ${Spawn[${MyTargetID}]} (${MyTargetID})\agLine#:${Macro.CurLine}"
					| Pull with cast
					/if (${DebugPull} || ${p_flag}==3) {
						DEBUGPULL Pull: Casting to pull mob \agLine#:${Macro.CurLine}"
					}
					/delay 1s !${Me.Moving} || (${AggroTargetID} && !${ChainPull}) || ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}
					/if (${Target.ID}) {
						/if (${MuleDebug}) /echo face \agLine#:${Macro.CurLine}
						/face nolook
					}
					/look 0                 
					/if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})) {
						DEBUGPULL Jumping up to PullAgain. \agLine#:${Macro.CurLine}"
						/goto :PullAgain
					}
					/if (!${SpawnCount[npc los id ${Target.ID}]}) {
						/varcalc PullDist ${PullDist}*.8
						DEBUGPULL Jumping up to PullAgain. \agLine#:${Macro.CurLine}"
						/goto :PullAgain
					}
					/if (!${Me.Moving}) {
						/if (${UseCalm}) {
							/varset CalmOldID ${Target.ID}
							/echo in calm sequence, CalmOldID is ${Target.ID}
							/echo there are ${SpawnCount[npc loc ${Target.X} ${Target.Y} radius ${CalmRadius}]} mobs within a ${CalmRadius} radius of our target.
							|only cast if its needed...
							/if (${SpawnCount[npc loc ${Target.X} ${Target.Y} radius ${CalmRadius}]} > 1) {
								/echo there are more than 1 mob within a ${CalmRadius} radius of our target...
								/varset CalmID ${NearestSpawn[2,NPC loc ${Target.X} ${Target.Y} radius ${CalmRadius}]].ID}
								/echo CalmID is ${CalmID}
								/echo ${Spawn[id ${CalmID}]} is ${Spawn[id ${CalmID}].Distance} away, the ${CalmWith} spell range is ${Spell[${CalmWith}].Range}
                				:moveabitcloserforcalm
								/if (${Spawn[id ${CalmID}].Distance3D} > ${Spell[${CalmWith}].Range}) {
									/squelch /face nolook id ${CalmID}
									/keypress forward hold
									/delay 1
									/keypress forward up
									/goto :moveabitcloserforcalm
								}
								/if (${CalmID} && ${Spawn[id ${CalmID}].Distance3D} <= ${Spell[${CalmWith}].Range}) {
									/echo its ok to calm them down!
									/call CacheBuffs ${CalmID} calm				
									/if (!${Spawn[${CalmID}].CachedBuff[${CalmWith}].ID}) {
										/if (${Target.ID}!=${CalmID}) {
											/if (${Target.ID}) {
												/squelch /target clear
												/delay 1s ${Target.BuffsPopulated}==FALSE
											}
											/if (${MuleDebug}) /echo Targeting a mob 15u
											/target id ${CalmID}
											/delay 1s ${Target.ID}==${CalmID}
											/delay 1s ${Target.BuffsPopulated}
											/delay 1s ${Target.CachedBuffCount}!=-1
										}
										/echo time to calm down the situation... casting ${CalmWith} on ${Target}
										/call CastWhat "${CalmWith}" ${CalmID} Calm
										/delay 2s ${Target.Buff[${CalmWith}].ID} > 0
									}
									/if (${MuleDebug}) /echo Targeting a mob 15v
									/target id ${CalmOldID}
									/delay 2s ${Target.ID}==${CalmOldID}
								}
							}
						}

						DEBUGPULL Going to cast ${PullWith} on ${Target} \agLine#:${Macro.CurLine} from the ${Macro.CurSub} sub."
						/call CastWhat "${PullWith}" ${Target.ID} "Pull"
                		/if (${Macro.Return.Equal[CAST_SUCCESS]} || (${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})) /varset Pulled 1
                		|Lemons: Try to smooth out the pulling process a bit.
						|/delay 1s (${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})
            		}
				}
				|- Toggle puller mode off if option enabled.
				/if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}==${Me.ID}) {
					/call TogglePullMode TurnOff
				}
			} else /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${MyTargetID}) && ${ChainPull})) {
				| The else /if fixes when puller stalls because puller grabs aggro with out getting to pull.
				/varset Pulled 1
			}
			| If pull failed start over while timer > 0
			/if (!${PullPathWpCount} && !${Pulled}) {
				/goto :PullAgain
			}
			:DonePulling
			DEBUGPULL DonePulling \agLine#:${Macro.CurLine}"
			| reset mq2moveutils mdist back to 8 from pull distance to ensure correct movement
			/if (${MuleDebug}) /echo moveto \agLine#:${Macro.CurLine}
			/moveto mdist 8
			/if (${rangedSwitch}) {
				/call CheckCasting 50
				/exchange "${OrigRanged}" ranged
				/varset rangedSwitch 0
				/delay 1s
			}
			/if (${ammoSwitch}) {
				/call CheckCasting
				/if (${Cursor.ID}) /autoinventory
				/exchange "${tempAmmo}" ammo
				/varset ammoSwitch 0
				/delay 1s
			}
			/varset Pulling 0
			| Turn autofire back on
			/if (${AutoFireOff}) {
				DEBUGPULL Pull AutoFire on \agLine#:${Macro.CurLine}"
				/varset AutoFireOff 0
				/varset AutoFireOn 1
			}
			|Lemons: Hard use on Moveto instead of Nav. Potential problem. 
			/if (${Select[${Role},hunter,hunterpettank]} && ${MyTargetID}) {
				DEBUGPULL Pull Enter hunter combat \agLine#:${Macro.CurLine}"
				/if (${PullWith.Equal[Melee]} && ${Target.Moving}) {
					DEBUGMOVE Moveto "
					/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
					/moveto id ${MyTargetID} mdist 5
					/if (${Target.ID}) {
						|/echo facing ${Target.ID} FaceMobOn = ${FaceMobOn} \agLine#:${Macro.CurLine}
						/face nolook
					}
					/if (${Me.FeetWet}) {
						/if (${Navigation.Active}) {
							/echo Stopping nav \agLine#:${Macro.CurLine}
							/nav stop
						}
						/stick uw ${StickHow} 5 id ${MyTargetID}
					} else {
						/stick ${StickHow} 5 id ${MyTargetID}
					}
				}
				/echo turning on attack for hunter \agLine#:${Macro.CurLine}
				/if (${UseMQ2Melee}) {
					/squelch /melee melee=1
				}
				DEBUGCOMBAT I'm turning attack on target is ${Spawn[${MyTargetID}].Distance} ft out.\agLine#:${Macro.CurLine}"
				DEBUGMOVE Moveto "
				/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
				/attack on
				/moveto id
				|delayremove/delay 2
				/if (${PullWith.Equal[melee]}) {
					/stick 4
					/delay 3s ${Target.PctHPs} != 100
				}
				/call Combat
				/call CombatReset Pull
				/call PullReset
				| Try to return home if exceeding max radius while in ANY hunter mode
				/if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]} > ${Math.Calc[${MaxRadius}*.95]}) {
					DEBUGPULL Pull Returning hunter to camp \agLine#:${Macro.CurLine}"
					/echo ${Role}: Reached edge of ${MaxRadius} hunting radius. Trying to return to camp.
					/varset ReturnToCamp 1
					/call DoWeMove "FindMobToPull 7" ${p_flag}
				}    
				DEBUGPULL Pull Leaving hunter combat \agLine#:${Macro.CurLine}"
				/return
			}
			DEBUGPULL Pull Done Pulling \agLine#:${Macro.CurLine}"
			/if (${ReturnToCamp} && ${Pulled}) {
				/call WaitForMob
				/varset Pulled 0
			}
			|this bracket should it be here?
		}
		DEBUGPULL Pull Leave Mob ID:${Spawn[${MyTargetID}].ID} \agLine#:${Macro.CurLine}"
    /return

Sub DoThePullDance
	/if (${Target.Distance3D} <= 80 || ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]} < ${CampRadius}) /return
	/declare RandTargetHeading float local 0
	/if (${ActNatural} && ${PullWith.NotEqual[Pet]}) {
		/echo doing the pulldance
		/keypress forward hold
		/delay 2
		/keypress forward
	}
	/if (${Math.Rand[2]}) {
		/varcalc RandTargetHeading ${Target.HeadingTo.DegreesCCW} + ${Math.Rand[5,10]}
		/if (${ActNatural}) {
			/keypress left hold
			/delay 4
			/keypress left
		}
	} else {
		/varcalc RandTargetHeading ${Target.HeadingTo.DegreesCCW} - ${Math.Rand[5,10]}
		/if (${ActNatural}) {
			/keypress right hold
			/delay 4
			/keypress right
		}
	}
	/face nolook heading ${RandTargetHeading}
	/if (${ActNatural}) {
		/if (${Math.Rand[2]}) {
			/keypress back hold
			/delay 1
			/keypress back
		} else {
			/keypress forward hold
			/delay 1
			/keypress forward
		}
	}
/return
| -------------------------------------------------------------------------------------
| SUB: Wait for Mob
| -------------------------------------------------------------------------------------
    Sub WaitForMob
		/declare bDanceDone int local 0
        /if (${Select[${Role},hunter,hunterpettank]} || ${DPSPaused}) /return
        DEBUGPULL WaitForMob Enter \agLine#:${Macro.CurLine}"
        /varset WaitTimer 45s
        /if (${Pulled}) {
            DEBUGPULL WaitForMob Waiting for mob \agLine#:${Macro.CurLine}"
            /call DoWeMove WaitForMob
			/if (${DismountDuringFights}==1) {
				/if (${Me.Mount.ID}) {
					/echo getting off the horse because DismountDuringFights=1
					/dismount
				}
			}
            /if (${ChainPull}) /varset LastMobPullID ${Target.ID}
            /declare FaceTimer timer local 0
            /if (${InvSlot[ranged].Item.Name.NotEqual[${OrigRanged}]} && ${OrigRanged.NotEqual[null]}) {
                /call CheckCasting 50
                /exchange "${OrigRanged}" ranged
			}
			|do the campdance... i.e act like a player, take a step back etc.
			|run a half circle, back up just a little and face the direction of the incomming mob.
			|todo add that code... we can do it with keypresses, its easier than using nav
			|
			/if (${DeadGroupMember}!=0) {
				/varset DeadGroupMember 0
			}
			/if (${ImDraggingACorpse}) {
				/corpsedrop	
				/delay 1
				/varset ImDraggingACorpse 0
			}
		:WaitForMob
			/if (!${bDanceDone} && ${SpawnCount[npc radius 100]}==0) {
                /if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) {
					/call DoThePullDance
					/varset bDanceDone 1
					|/echo dance done...
				}
			}
			/if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${ReturnToCampAccuracy} && !${Navigation.Velocity}) {
				/if (${Navigation.MeshLoaded} && ${UseNav}  && ${Navigation.PathExists[id ${MainAssistID}]}) {
					/echo Naving back to middle of camp in pull wait
					/nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
				} else {
					/echo Moving to middle of camp in pull wait
					DEBUGMOVE Moveto "
					/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
					/moveto loc ${CampYLoc} ${CampXLoc} mdist 10
				}
			}
			/if (${OhShitOn}) {
				/call OhShitStuff "WaitForMob"
			}
            /doevents
            /call MobRadar ${CampRadius} WaitForMob
            | If NOT chain pulling and multiple mobs in camp. /return
            /if (${MobCount}>=2 && !${ChainPull}) {
                /call PullReset
                /return
            } 
            DEBUGPULL - WaitTimer: ${WaitTimer} Target Distance: ${Target.Distance} Mob Dist from Camp: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>=${CampRadius} Mob Dist from tank: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Me.Y},${Me.X}]}>=20 \agLine#:${Macro.CurLine}"
            | if target lost somehow add to ignore list and continue pulls
            /if ((!${AggroTargetID} && !${ChainPull}) || ${WaitTimer}==0) {
                DEBUGPULL WaitForMob /return no AggroTargetID \agLine#:${Macro.CurLine}"
                /squelch /alert add 1 id ${Target.ID}
                /call PullReset 
                /return
            }
            |/varset FaceTimer 1s
            |/delay 1
			/if (!FACING && ${FaceMobOn}) {
				/if (${ActNatural}) {
					/face nolook id ${MyTargetID}
				} else {
					/face fast id ${MyTargetID}
				}
			}
            | I am PULLER with PET TANK            
            /if (${Select[${Role},pullerpettank]}) {
                |- Make sure pet is returning to camp with me.
                /if (${Me.Pet.ID} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${Me.Y},${Me.X}]}>20) {
                    /pet back off
                    /delay 1
                    /pet follow
                } 
                | If the mob is within pet attack distance from camp send the pet in to attack
                /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${PetAttackRange}) {
					/delay 1
					/goto :WaitForMob
				}
                /if (!${PetAttack}) /call CombatPet
            }
            | I am PULLER TANK
            /if (${Select[${Role},pullertank]}) {
                | Wait in camp for mob if timer active and mob is outside of camp radius and mob is farther away from tank than 20 feet
                /if (${WaitTimer} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>${MeleeDistance}) {
					/delay 1
					/goto :WaitForMob
				}
            }
            | If I am PULLER and NOT chain pulling
            /if (${Select[${Role},puller]} && !${ChainPull}) {
                /if ((${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${CampRadius} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20) || (${ChaseAssist} && ${Math.Distance[${Spawn[${MainAssistID}].Y},${Spawn[${MainAssistID}].X}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${CampRadius} && ${Math.Distance[${Spawn[${MainAssistID}].Y},${Spawn[${MainAssistID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20) ) {
					/delay 1
					/goto :WaitForMob
				}
                /if (${MercOn} && ${MercAssisting} != ${MyTargetID} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
            }
            | If I am PULLER and chain pulling
            /if (${Select[${Role},puller]} && ${ChainPull}) {
                | Leave if multi mobs or no mobs 
                /if (${MobCount}>=2 || !${MyTargetID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot2}].ID})) { 
                    /call PullReset
                    /return
                }
                /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20 && ${Target.ID}==${Spawn[${MyTargetID}].ID} && ${Me.TargetOfTarget.ID}==${Me.ID}) {
					/delay 1
					/goto :WaitForMob
				}
			}
        }
        /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Spawn[${MyTargetID}].Distance}<=${MeleeDistance}) /call AssignGroupRole unset "${Me.CleanName}" 3            
        /if (${MyTargetID} && (!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull})) /call PullReset
        /if (${IAmABard}) /call DoBardStuff
        /varset WaitTimer 0
        /call MercsDoWhat
        DEBUGPULL WaitForMob Leave \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: Reset Pull variables
| -------------------------------------------------------------------------------------
    Sub PullReset
        DEBUGPULL PullReset Enter \agLine#:${Macro.CurLine}"
        /moveto mdist 10
        /varset Pulling 0
        /varset Pulled 0
        /varset MyTargetID 0
		/varset MTIDSetAt ${Macro.CurLine}
        /varset MyTargetName
        /varset ToClose 0
		DEBUGMOVE Stopping movement"
		DEBUGPULL PullReset Stopping movement and attack"
        /if (${Me.Combat}) /attack off
        /if (${MoveTo.Moving}) /moveto off
        /if (${mq2navloaded}) {
			/if (${Navigation.Active}) {
				/echo PullReset stopping nav 
				/nav stop
			}
		}
        /varset WaitTimer 0
		/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
        /squelch /target clear
        DEBUGPULL PullReset Leave \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: TogglePullMode
| -------------------------------------------------------------------------------------
    Sub TogglePullMode(ToggleState)
        /if (!${Select[${Me},${Group.Leader}]} || !${SpawnCount[group mercenary]}) /return
        /if (${ToggleState.Equal[TurnOn]}) {   
            :TurnOnPullRole
            /if (${Target.Distance} > ${CampRadius}) {                
                /if (${Group.Puller.ID}!=${Me.ID}) /grouproles set ${Me.CleanName} 3
                /delay 10 ${Group.Puller.ID}==${Me.ID}
                /if ((${Target.Distance}>${CampRadius}) && (${Group.Puller.ID}!=${Me.ID})) /goto :TurnOnPullRole  
                /if (${Group.Puller.ID}==${Me.ID}) /echo + You have been set be group puller.        
            }
        }
        /if (${ToggleState.Equal[TurnOff]}) {    
            :TurnOffPullRole
            /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) {        
                DEBUGN KICKIT! ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) \agLine#:${Macro.CurLine}"
                /if (${Group.Puller.ID}==${Me.ID}) /grouproles unset ${Me.CleanName} 3
            } else {
				DEBUGMOVE Moveto "
				/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
                /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) /moveto loc ${CampYLoc} ${CampXLoc} mdist 10
            }
            /delay 10 ${Group.Puller.ID}!=${Me.ID}    
            /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} || (${Group.Puller.ID}==${Me.ID})) /goto :TurnOffPullRole   
            /if (${Group.Puller.ID}!=${Me.ID}) /echo + You are no longer group puller.
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: GroupWatch
| -------------------------------------------------------------------------------------
    Sub GroupWatch
        /if (!${GroupWatchOn} ) /return 
        /if ((${AggroTargetID} && !${ChainPull}) || ${Role.Equal[manual]}) /return
        DEBUGN GroupWatch Enter"
        /declare i int local 0
        /declare GrpMemType string local
        /declare GrpMemName string local
        /declare GrpMemClass string local
        /declare GrpMemStat string local
        /if (!${Spawn[=${MainAssist}].ID} && !${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]} && ${CampZone}==${Zone.ID}) {
            /echo I am not detecting Main Assist pausing.
			/keypress forward hold
			/delay 5
			/keypress forward
            :WaitForMA
                /doevents
                /call CheckForCombat 1 GroupWatch
                /call WaitSubs
                /if (${Spawn[=${MainAssist}].ID}) {
                    /echo Main Assist is back resuming action.
                    /return
                }
                /delay 3
            /goto :WaitForMA
        }
        /if (${ChainPullHold}==1) /varset ChainPullHold 0
        /for i 1 to 5
            /if (!${Group.Member[${i}].ID} || ${Group.Member[${i}].Type.Equal[corpse]} ) /goto :SkipCheck
            /if (${GroupWatchOn}==2 && !${Select[${Group.Member[${i}].Class.ShortName},CLR,DRU,SHM]}) /goto :SkipCheck
			/if (${GroupWatchOn}==3 && !${Select[${Group.Member[${i}].Class.ShortName},${GroupWatchClasses}]})  /goto :SkipCheck
            /varset GrpMemType ${Group.Member[${i}].Type}
            /varset GrpMemName ${Group.Member[${i}].CleanName}
            /varset GrpMemClass ${Group.Member[${i}].Class.ShortName}
            /if (${Select[${GrpMemClass},BER,MNK,ROG,WAR]}) {
                /varset GrpMemStat Endurance
            } else {
                /varset GrpMemStat Mana
            }
            DEBUGN ${i} /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" ${GrpMemStat} ${GroupWatchPct} 90"
            /call CheckStats 1 "${GrpMemName}" ${GrpMemClass} ${GrpMemType} ${GrpMemStat} ${GroupWatchPct} 90
            /if (${Select[${GrpMemClass},BST,PAL,RNG,SHD]}) /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" Endurance ${GroupWatchPct} 90
            :SkipCheck
            /if (${Group.Member[${i}].Type.Equal[corpse]}) /varset ChainPullHold 1
        /next i
        DEBUGN GroupWatch Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckStats
| -------------------------------------------------------------------------------------
    Sub CheckStats(int statcheck, charname, ckclass, cktype, stat, int pause,int resume)
        /if (!${statcheck}) /return
        /if (!${Spawn[${ckclass} ${cktype} ${charname}].ID}) /return
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}>${pause}) /return
		/if ((${ChaseAssist} && ${Spawn[=${MainAssist}].Distance} > ${ChaseDistance}) || ${Me.Speed}) /return
        DEBUGN CheckStats Enter"
        DEBUGN statcheck ${statcheck} charname ${charname} ckclass ${ckclass} stat ${stat} pause ${pause} resume ${resume}"
        /if (${Role.Equal[puller]} && ${ChainPull} ) {
                /call MobRadar ${MeleeDistance} CheckStats
                /if (${MobCount}>0) {
                 /varset ChainPullHold 1
             /return
            }
        }
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) {
            /call BroadCast t "Waiting for >> ${charname} << to med up to ${resume}% ${stat}. Line#:${Macro.CurLine}"
        } else {
            /echo  Waiting for >> ${charname} << to med up to ${resume}% ${stat}. Line#:${Macro.CurLine}
        }
        | target toon to make sure they aren't at full mana due to lag
		/if (${MuleDebug}) /echo Targeting a mob \agLine#:${Macro.CurLine}
        /target id ${Spawn[${ckclass} ${cktype} ${charname}].ID}
        /delay 1s ${Target.ID}==${Spawn[${ckclass} ${cktype} ${charname}].ID}
        /varset Pulling 0
        | Only twist med if song no aggro others fighting willnegate bard fast med
        /if (${IAmABard} && !${AggroTargetID}) {
			/if (${Bool[${TwistMed}]} && ${TwistOn} && !${Me.Gem[${Twist.Current}].HasSPA[12]}) {
				/if (!${Me.Standing}) {
					DEBUGN going to stand"
					/if (!${standTimer}) /stand
					/delay 1s ${Me.Standing}
					/if (!${Me.Standing}) {
						DEBUGN Returning cause I'm not standing"
						/return
					}
				}
			/squelch /twist ${TwistMed}
			}
		}
        /varset Medding 1
	:wait_for_resume
        /doevents
        /if ((${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) || ${ChaseAssist}) {
			|Lemons: Standing and then sitting in the same sub is...bad
            |/if (!${Me.Mount.ID} && ${Me.Sitting} && !${Me.Rooted.ID}) {
			|	/echo going to stand \agLine#:${Macro.CurLine}
			|	/multiline ; /echo Standing at ${Macro.CurLine} ; /if (!${standTimer}) /stand
			|}
            /call DoWeMove CheckStats
            /delay 100 !${Me.Moving}
        }
        |delayremove/delay 5
        /call CheckCasting 50
        |delayremove/delay 5
        /call CheckForCombat 1 CheckStats
		/if (${PullOnce}) {
			/varset PullOnce 0
			/call FindMobToPull 3
		}
        /if (${AggroTargetID}) {
            /varset Medding 0
            /return
        }
		/if (${IAmABard}) /call DoBardStuff
		/if (!${Me.Mount.ID} && !${Me.Speed}) {
			/if (!${Me.Sitting} && ${Me.Class.ShortName.NotEqual[BRD]}) {
				/call SitIfNotBard CheckStats
				/delay 1
				/if (!${sitTimer}) /echo might as well sit down while we wait for ${ckclass} to med up past ${resume}... \agLine#:${Macro.CurLine}
			}
		}
		|Lemons: Can get stuck in here doing nothing while waiting for someone to med. Gonna try out Waitsubs
		/call WaitSubs check
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}} < ${resume}) {
			/goto :wait_for_resume
		}
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) /call BroadCast t "${charname} is now above ${resume}% ${stat} resuming activity."
        /echo ${charname} is now above ${resume}% ${stat} resuming activity.
        /if (!${Me.Mount.ID} && !${Me.Standing}) {
				DEBUGN going to stand"
				/if (!${standTimer}) /stand
				/delay 1s ${Me.Standing}
				/if (!${Me.Standing}) {
					DEBUGN Returning cause I'm not standing"
					/return
				}
			}
		/if (!${Me.Mount.ID} && !${Me.Standing}) {
			DEBUGN going to stand"
			/if (!${standTimer}) /stand
			/delay 1s ${Me.Standing}
			/if (!${Me.Standing}) {
				DEBUGN Returning cause I'm not standing"
				/return
			}
		}
        /varset Medding 0
        /varset ChainPullHold 0 
        /if (${IAmABard}) {
			/if (${Bool[${TwistMed}]} && ${Twist}) {
				/if  (!${Me.Gem[${Twist.Current}].HasSPA[12]}) {
					/twist stop
					/stopsong
					/varset Twisting 0
					/varset TwistStop ${Macro.CurLine}
					/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
				}
			}
		}
        /if (${ChainPull} && ${ChainPullPause.NotEqual[0]}) /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
        DEBUGN CheckStats Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: alert clear
| -------------------------------------------------------------------------------------
    Sub ClearOutAlerts(int ListToClear)
        /if (${DebugPull}) {
            DEBUGPULL ClearOutAlerts Enter  \agLine#:${Macro.CurLine}"
            DEBUGPULL Clearing Alert list ${ListToClear}. \agLine#:${Macro.CurLine}"
        }
        /squelch /alert clear ${ListToClear}
        DEBUGPULL ClearOutAlerts Leave \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: Assign Group Role
| -------------------------------------------------------------------------------------
    Sub AssignGroupRole(ASGOnOff, AGRName, AGRRole)
        DEBUGN AssignGroupRole ${ASGOnOff} ${AGRName} ${AGRRole}"
        /docommand /grouproles ${ASGOnOff} ${AGRName} ${AGRRole}
        /delay 10
    /return
	
| -------------------------------------------------------------------------------------
| SUB: HomogenizeMainTarget - Make sure everyone connected to dannet in my group has the correct MyTargetID assigned.
| -------------------------------------------------------------------------------------
    Sub HomogenizeMainTarget
		/if (!${Bool[${Plugin[MQ2DanNet]}]}) /return
		/if (${SwitchWithMA}) /return
		/dquery ${MainAssist} -q MyTargetID
		|/delay 10 ${DanNet.Q} == ${MyTargetID}
		/if (!${Int[${DanNet.Q}]}) /return
		/if (${DanNet[${MainAssist}].Q[MyTargetID]} != ${MyTargetID} && ${DanNet.Q}) {
			|Group Member does not have my same Main Target
			/varset MyTargetID ${DanNet.Q}
			DEBUGCOMBAT Just reset Myt MTID From ${DanNet.Q} ${Spawn[${DanNet.Q}]} to ${MyTargetID} ${Spawn[${MyTargetID}]}"
		}
	/return
	
| -------------------------------------------------------------------------------------
| SUB: Event CantSee CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantSee
        DEBUGN Event_CantSee"
        | Reset position via stick
        /if (${Pulling}) {
           /varset CantSee 1
           /return
        }
        /if (${Attacking}) {
            DEBUGN Can't See my target. Moving Closer. \agLine#:${Macro.CurLine}"
            /if (!${Me.Standing}) {
				DEBUGN going to stand"
				/if (!${standTimer}) /stand
				/delay 1s ${Me.Standing}
				/if (!${Me.Standing}) {
					DEBUGN Returning cause I'm not standing"
					/return
				}
			}
            /if (${Target.ID}) {
		/if (${MuleDebug}) /echo facing 10
		/squelch /face fast nolook
	    }
            /look 0
            /if (${StickHow.NotEqual[0]}) {
                /if (${Me.FeetWet}) {
					/if (${Navigation.Active}) {
						/echo Stopping nav \agLine#:${Macro.CurLine}
						/nav stop
					}
					/stick uw ${StickHow} id ${MyTargetID}
                } else {
                    /stick ${StickHow} id ${MyTargetID}
                }
            } else {
                /if (${Me.FeetWet}) {
					/if (${Navigation.Active}) {
						/echo Stopping nav \agLine#:${Macro.CurLine}
						/nav stop
					}
                    /stick uw pin id ${MyTargetID}
                } else {
                    /stick pin id ${MyTargetID}
                }
            }
        }
        DEBUGN Leave Event_CantSee \agLine#:${Macro.CurLine}"
        /doevents flush CantSee
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantHit
        DEBUGN Event_CantHit \agLine#:${Macro.CurLine}"
        | Reset position via stick
        /if (${Pulling}) {
            /varset CantHit 1
        }
        DEBUGN Leave Event_CantHit \agLine#:${Macro.CurLine}"
    /return
| -------------------------------------------------------------------------------------
| SUB: Event Missing
| -------------------------------------------------------------------------------------
    Sub Event_Missing

    /return 1
	
| -------------------------------------------------------------------------------------
| Sub RGRez - Thanks RGMercs!
| -------------------------------------------------------------------------------------
	Sub Bind_RGRez
		/declare SoulStoneMerchant     	string local   "A Vendor of Reagents"
		/declare CorpseSummoner 	    string local   "A Priestess of Luclin"
		/declare RangeDist              int    local   8
		/declare SoulStoneName		    string local
		/declare bag               	    string local
		/declare slot              	    string local
		/declare ItemToGet              string local
		/declare MercClass              string local
		/declare i			            int    local
		|Lemons: Cause macros are dumb and you can't use the math in the delay line or something (something about spaces)
		/declare DelayT					int		local ${Math.Abs[${Math.Calc[10-${Select[${Me.CleanName},${EQBC.Names.Replace[ ,,]}]}*2].Int}]}

		/squelch /target clear
		/delay 10
		|/echo ${Math.Calc[10 - ${Select[${Me.CleanName},${EQBC.Names.Replace[ ,,]}]} * 2].Int}s
		/if (${EQBCOn}) {
			/if (${EQBC.Connected}) /delay ${DelayT}s
		}
		/if (!${Plugin[MQ2Nav].Name.Equal[MQ2Nav]}) {
			/echo Loading MQ2Nav
			/squelch /plugin MQ2Nav load
			/delay 1s
			/if (!${Plugin[MQ2Nav].Name.Equal[MQ2Nav]}) {
				/beep
				/echo Unable to load MQ2Nav plugin, stopping.
				/end
			}
		} else {
			/echo MQ2Nav plugin is loaded.
		}
		/if (!${Zone.Name.Equal[Guild Lobby]}) {
			/echo Get your lazy self to the Guild Lobby!
			/return
		}
		|** dont need anymore cause stones are gone
		/if (${Me.Level}<=115) /varset SoulStoneName Velium Soulstone
		/if (${Me.Level}<=110) /varset SoulStoneName Draconic Soulstone
		/if (${Me.Level}<=105) /varset SoulStoneName Torrential Soulstone
		/if (${Me.Level}<=100) /varset SoulStoneName Coalescent Soulstone
		/if (${Me.Level}<=95) /varset SoulStoneName Luminous Soulstone
		/if (${Me.Level}<=90) /varset SoulStoneName Phantasmal Soulstone
		/if (${Me.Level}<=85) /varset SoulStoneName Iridescent Soulstone
		/if (${Me.Level}<=80) /varset SoulStoneName Prismatic Soulstone
		/if (${Me.Level}<=75) /varset SoulStoneName Glowing Soulstone
		/if (${Me.Level}<=70) /varset SoulStoneName Pristine Soulstone
		/if (${Me.Level}<=55) /varset SoulStoneName Faceted Soulstone
		/if (${Me.Level}<=50) /varset SoulStoneName Greater Soulstone
		/if (${Me.Level}<=40) /varset SoulStoneName Soulstone
		/if (${Me.Level}<=30) /varset SoulStoneName Lesser Soulstone
		/if (${Me.Level}<=20) /varset SoulStoneName Minor Soulstone
		/delay 10
		/echo Soulstone for my level (${Me.Level}) is (${SoulStoneName}).
		
		
		/if (${FindItem[${SoulStoneName}].ID}) {
			/echo I already have a (${SoulStoneName}).
		} 
		/if (!${FindItem[${SoulStoneName}].ID}) {
			/echo I do not have a (${SoulStoneName}).

			/nav spawn npc ${SoulStoneMerchant}
			/while (${Navigation.Active}) {
			/if (${Spawn[npc ${SoulStoneMerchant}].Distance3D} < 20) /break
			/delay 5
			}
			/squelch /target npc ${SoulStoneMerchant}
			/delay 2s ${Target.ID}==${Spawn[npc ${SoulStoneMerchant}].ID}
			/face
		} 

		/echo We have arrived at ${SoulStoneMerchant}
		/nomodkey /click right target
		/delay 10s ${Merchant.ItemsReceived}

		/if (${Merchant.ItemsReceived}) {
			/delay 3s
			/varset ItemToGet ${Window[MerchantWnd].Child[ItemList].List[=${SoulStoneName},2]}
		}

		/if (!${ItemToGet}) {
			/echo I couldn't find (${SoulStoneName})  to purchase!
			/end
		} else {
			/echo Found (${SoulStoneName}) to purchase!
			/notify MerchantWnd ItemList listselect ${ItemToGet}
			/delay 10
			/notify MerchantWnd ItemList LeftMouseUp ${ItemToGet}
			/delay 10
			/nomodkey /notify MerchantWnd MW_Buy_Button LeftMouseUp
			/delay 10
		}
		:CloseMerchantWnd1
		/if (${Window[MerchantWnd].Open}) {
			/nomodkey /notify MerchantWnd MW_Done_Button LeftMouseUp
			/delay 10
			/if (${Window[MerchantWnd].Open}) /goto :CloseMerchantWnd1
		}
		**|
		/nav spawn npc ${CorpseSummoner}
		/while (${Navigation.Active}) {
			/if (${Spawn[npc ${CorpseSummoner}].Distance3D} < 20) /break
			/delay 5
		}
		/squelch /target npc ${CorpseSummoner}
		/delay 2s ${Target.ID}==${Spawn[npc ${CorpseSummoner}].ID}
		|**
		/face
		/echo Attempting to grab (${SoulStoneName}).
		/if (!${Window[InventoryWindow].Open}) /keypress Inventory
		/delay 5
		/itemnotify "${SoulStoneName}" leftmouseup
		/delay 5

		/if (${Cursor.ID} && ${Cursor.Name.Equal[${SoulStoneName}]}) {
			/echo I have (${SoulStoneName}) on my cursor.
			/echo Giving (${Cursor.Name}) to (${Target.CleanName}).
		}
		:OpenGiveWindowB
			/nomodkey /click left target
			/delay 5s ${Window[GiveWnd].Open}
			/if (!${Window[GiveWnd].Open}) /goto :OpenGiveWindowB
		:GiveSoulStone
			/if (${Window[GiveWnd].Open}) {
				/notify GiveWnd GVW_Give_Button leftmouseup
				/delay 3s
				/if (${Window[GiveWnd].Open}) /goto :GiveSoulStone
			}
		:CloseInvWnd
			/if (${Window[InventoryWindow].Open}) {
				/nomodkey /notify InventoryWindow IW_DoneButton LeftMouseUp
				/delay 5
				/if (${Window[InventoryWindow].Open}) /goto :CloseInvWnd
			} else {
			/echo I couldn't find (${SoulStoneName}) on my cursor!
			/end
		}
		/if (${Window[InventoryWindow].Open}) /nomodkey /notify InventoryWindow IW_DoneButton LeftMouseUp
		**|
		/say summon
		/delay 15
		/squelch /target clear
		/delay 10

	/return
	
| -------------------------------------------------------------------------------------
| Sub Assign Main Assist
| -------------------------------------------------------------------------------------
Sub Bind_AssignMainAssist(string maname)
	/declare maclean string local ${Target.CleanName}
	/declare matype string local ${Target.Type}
	/declare maclass string local ${Target.Class.ShortName}
	/declare r int local
	/declare BlankX int local 0
	/declare q int local
	/if (${maname.Length}) {
		/varset maclean ${Spawn[=${maname}].CleanName}
		/varset matype ${Spawn[=${maname}].Type}
		/varset maclass ${Spawn[=${maname}].Class.ShortName}
		/echo Changing MA to ${maclean}
	}  
	/if (${Debug}) {
		DEBUGN AssignMainAssist Enter \agLine#:${Macro.CurLine}"
	}   
	/varset MainAssist ${maclean}
	/varset MainAssistType ${matype}
	/varset MainAssistClass ${maclass}
	/if (${MainAssistID} != ${Spawn[${MainAssist}].ID}) /varset MainAssistID ${Spawn[${MainAssist}].ID}
	/if (${Debug}) {
		DEBUGN AssignMainAssist Leave \agLine#:${Macro.CurLine}"
	}
	|Lemons: I think this is setting your out of group MainAssist to the first available slot....Fuck me if I know though. But that's how I changed it to handle new XTarHeal
	|Well, something is making it set any blank slot to your MA if your first XTar slot isn't them
	|I fixed this at some point
	/if (!${Group.Member[${MainAssist}].ID} && ${Spawn[${MainAssist}].ID}!=${Me.ID}) {
		/if (${Int[${XTarHeal}]}) {
			/for r 1 to ${Me.XTargetSlots}
				/for q 1 to ${Math.Calc[${XTarHeal.Count[|]} + 1]}
					/if (${XTarHeal.Arg[${q},|]} != ${r}) {
						/varset BlankX ${XTarHeal.Arg[${q},|]}
						|/echo Setting slot ${r} to blank cause I didn't find it in ${XTarHeal.Arg[${q},|]}\agLine#:${Macro.CurLine}
						/break
					}
				/next q
				/if (!${BlankX}) {
					/xtarget set ${r} ${MainAssist}
				}
			/next r
		}
		/if (${Bool[${Plugin[MQ2XAssist]}]}==TRUE) {
			/if (${Me.Level} > 19) {
				|yes this stupid but i dont have time to add a check if extended target is actually enabled if its a tlp server
				|so just level up to 20 mkay...
				/echo We will be using XAssist for a outside group MA \agLine#:${Macro.CurLine}
				/varset AssistOutside 1
				/xtarget assist ${Target.ID}
			}
		}
	}
/return

| ----------------------------------------------------------------------------
| SUB: Bind Switch
| ----------------------------------------------------------------------------
    Sub Bind_Switch(newTarget)
        /echo New target called! Current is ${MyTargetID}, ${Spawn[${MyTargetID}]}, ${AggroTargetID}, ${AssistID}
		/if ((${newTarget.Equal[NULL]} || ${newTarget.Equal[0]} || ${newTarget.Length} == 0) && ((!${Target.ID} || ${Target.Type.NotEqual[NPC]} || ${Target.ID} == ${MyTargetID}) && !${Me.XTarget[2].ID})) {
			/echo No valid ID. Not changing my target.
			/return
		}
		/if ((${newTarget.Equal[NULL]} || ${newTarget.Equal[0]} || ${newTarget.Length} == 0) && ${Target.ID} && ${Target.Type.Equal[NPC]} && ${Target.ID} != ${MyTargetID}) /varset newTarget ${Target.ID}
		/if (${Me.ID} != ${MainAssistID}) {
			/call BCTExec ${MainAssist} "/switchnow ${newTarget}"
			/return
		}
		/echo (${newTarget.Equal[NULL]} || ${newTarget.Equal[0]} || ${newTarget.Length} == 0)
		/echo ${Me.ID} != ${MainAssistID}, (${newTarget.Equal[NULL]} || ${newTarget.Equal[0]} || ${newTarget.Length} == 0), (${Me.XTarget[2].ID}==${Target.ID} && ${Me.XTarget[1].ID}), 
		|We are the MA and need to switch targets to newTarget or Xtarget 1/2
 		/if (${newTarget.Equal[NULL]} || ${newTarget.Equal[0]} || ${newTarget.Length} == 0) {
			/if (${Me.XTarget[1].ID}==${Target.ID} && ${Me.XTarget[2].ID}) {
				/echo switching to 2 ${Me.XTarget[2]}
				/tar id ${Me.XTarget[2].ID}
				/varset MyTargetID ${Me.XTarget[2].ID}
				/varset MTIDSetAt ${Macro.CurLine}
			} else /if (${Me.XTarget[2].ID}==${Target.ID} && ${Me.XTarget[1].ID}) {
				/echo switching to 1 ${Me.XTarget[1]}
				/tar id ${Me.XTarget[1].ID}
				/varset MyTargetID ${Me.XTarget[1].ID}
				/varset MTIDSetAt ${Macro.CurLine}
			}
			|Lemons: This is bad. We can't change what AggroTargetID is. 
			|/varset AggroTargetID ${MyTargetID}
			/varset AssistID ${MyTargetID}
		} else {
			/echo Switching my target to ${newTarget} ${Spawn[${newTarget}]}
			/tar id ${newTarget}
			/varset MyTargetID ${newTarget}
			/varset MTIDSetAt ${Macro.CurLine}
			|/varset AggroTargetID ${newTarget}
			/varset AssistID ${newTarget}
		}
	/call BCTExec all "/backoff"
	/delay 3
	/call DPSTimerReset "SwitchBind"
	/call BCTExec all "/varset MyTargetID 0"
	/varset MTIDSetAt ${Macro.CurLine}
	/call BCTExec all "/varset MyTargetName "
	/delay 3
	/call BCTExec all "/backoff"
	/call BCTExec all "/varset DPSPaused 0"
	/echo Leaving New Target. Now is ${MyTargetID}, ${Spawn[${MyTargetID}]}, ${AggroTargetID}, ${AssistID}
	/if (${Select[${Role},hunter,tank,pullertank,pullerpettank,hunterpettank]}) /call BroadCast y "TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
    /return
| ----------------------------------------------------------------------------
| SUB: Event GotHit - Written by TreeHuginDruid for RedGuides
| ----------------------------------------------------------------------------
    Sub Event_GotHit(string Line, string AttackingMob)
		/if (${Defined[MeleeHit]}) {
			/varset MeleeHit 1
		}
		|Kaen01::Resetting sittomedtimer after we get hit, so we dont try and sit while mob is mauling us
		/if (${SitToMedTimer.OriginalValue} != 100) /varset SitToMedTimer 10s
		DEBUGN LemonsDebug: I got hit! STM set to ${SitToMedTimer}"
		/doevents flush GotHit
        /declare GotHitDistChk int local 10
        /varset GotHitToggle 1
        /declare AttackingMobID int local
		|This is causing a very long, non inifinite loop when you get hit multiple times. Hopefully flushing will fix this? Otherwise we have to check everywhere where it was sent from, which is a problem with events, or just remove this call. 
        /if (${AggroTargetID} && !${Target.ID} && !${ReturnToCamp}) {
			/doevents flush GotHit
            |/call CheckForCombat 1 Event_GotHit
        }
        /if (${Pulled} && ${WaitTimer} && ${Select[${Role},pullertank,pullerpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
            /if (${NearestSpawn[npc los radius ${CampRadius} targetable].ID}!=${MyTargetID}) {
                /varset MyTargetID 0
                /varset MyTargetName
				/varset MTIDSetAt ${Macro.CurLine}
            }
            /varset WaitTimer 0s
            /echo I got hit (${Line}) by >> ${AttackingMob} << ID:${AttackingMobID} while waitng for mob.
        }     
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) {   
            /doevents flush GotHit        
            /varset AttackingMobID ${NearestSpawn[npc radius 39 targetable "${AttackingMob}"].ID}
			/if (${MuleDebug}) /echo Targeting a mob 14i
            /squelch /target id ${Spawn[${AttackingMobID}].ID}                         
            /delay 10 ${Target.ID}==${AttackingMobID}            
            |- If mob that hit me still too close, move to camp or away from mob.
            /if (${GotHitToggle} && ${AttackingMobID}>0) {
                /echo I got hit (${Line}) by >> ${AttackingMob} << ID:${AttackingMobID}!
                /moveto mdist 5
                /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && !${Select[${Role},hunterpettank]} && ${ReturnToCamp}) {
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Moving back to camp!
						DEBUGMOVE Moveto target between 10-100"
						/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
                        /moveto loc ${CampYLoc} ${CampXLoc}
                    }
                } else {
                    |- If mob is in pet attack range from camp, send pet in.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Target.Y},${Target.X}:${Me.Pet.Y},${Me.Pet.X}]}<=${PetAttackRange} && !${Me.Pet.Combat}) {
						/pet attack
						/if (${MuleDebug}) /echo Pet attacking at \ag${Macro.CurLine}
						}
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Trying to get away from >>${AttackingMob}<<.
						DEBUGMOVE Moveto target between 10-100"
						/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
                        /if (${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}<=${GotHitDistChk}) /moveto loc ${Target.Y} ${Math.Calc[${Target.X}-${GotHitDistChk}]}
                    }
                }
            }
            /if (${MoveWhenHit}) /delay 15 ${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}>${GotHitDistChk}
            /if (${Target.ID}) {
				/if (${MuleDebug}) /echo facing ${Target.ID} FaceMobOn = ${FaceMobOn} \agLine#:${Macro.CurLine}
				/if (!FACING) /face nolook
			}
		}
        /varset GotHitToggle 0
        /doevents flush GotHit
    /return
| ----------------------------------------------------------------------------
| SUB: Event Zoned
| ----------------------------------------------------------------------------
    Sub Event_Zoned(Message)
        /if (${Message.Find[Drunken Monkey]} || ${Message.Find[effects]}) /return
        /delay 60s ${Me.ID}
        /if (!${JustZoned}) /echo Just zoned
        /call CombatReset zoned
		/varset CharmPetID 0
		/varset AssistID 0
        /varset JustZoned 200
        /varset CampOnDeathTimer 10m
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset RememberCamp 1
        /varset LastZone ${Zone.ID}
        | Shut down combat and mez in GH, GL, PoK, PoT, and Abysmal
        /if (${Select[${Zone.ID},345,344,202,203,279]}) {
            /varset DMZ 1
        } else /varset DMZ 0
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset ReturnToCamp 0
        /if (${RememberCamp} && ${CampZone}==${Zone.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=100) {
            /varset ReturnToCamp 1
            /varset RememberCamp 0
        }
        /call CombatReset zoned
        /call WinTitle
		/if (${MainAssistID} != ${Spawn[${MainAssist}].ID} && ${Spawn[${MainAssist}].ID}) /varset MainAssistID ${Spawn[${MainAssist}].ID}
    /return
| ----------------------------------------------------------------------------
| SUB: Event Joined 20s switch to prevent heals from firing off
| ----------------------------------------------------------------------------
    Sub Event_Joined(string Jmessage,string Joinee)
         /echo ${Joinee} has joined the party.
         /varset JoinedParty 200
     /return
| ----------------------------------------------------------------------------
| SUB: Event Too Close
| ----------------------------------------------------------------------------
    Sub Event_TooClose
        /if (${MyTargetID} && ${AutoFireOn} && ${CombatStart} && ${UseMQ2Melee}) {
	    /echo TURNING AUTOFIRE OFF WE ARE TOO CLOSE
            /varset AutoFireOn 0
            /killthis
            /timed 300 /varset AutoFireOn 1
        }
        /if (${Pulling} && ${PullWithAlt.Equal[Melee]}) {
           /echo Mob Too Close for ${PullWith}... Switching to Melee.
           /varset ToClose 1
        }
        /doevents flush TooClose
    /return
| ----------------------------------------------------------------------------
| SUB: Event Banestrike - by Petesampras
| ----------------------------------------------------------------------------
   Sub Event_Banestrike
    /if (${Target.ID} && !${Banestrike.Find[|${Target.Race}|]}) /varset Banestrike ${Banestrike}${Target.Race}|
   /return
| ----------------------------------------------------------------------------
| SUB: Event Camping - end macro
| ----------------------------------------------------------------------------
    Sub Event_Camping        
         /if (${IAmABard} && ${Twist}) {
			/twist stop
			/stopsong
			/varset TwistStop ${Macro.CurLine}
			/if (${MuleDebug}) /echo Stopping twist \ag${Macro.CurLine}
		}
        /end
    /return
| ----------------------------------------------------------------------------
| SUB: Event Too Far
| ----------------------------------------------------------------------------
    Sub Event_TooFar
        /if (${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius} && ${MeleeOn} && ${CombatStart} ) {
            /if (${Me.FeetWet}) {
				/if (${Navigation.Active}) {
					/echo Stopping nav \agLine#:${Macro.CurLine}
					/nav stop
				}
                /squelch /stick 50% uw ${StickHow} id ${MyTargetID}
            } else {
                /squelch /stick 50% ${StickHow} id ${MyTargetID}
            }
        }
	/declare ZDist float local 0
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /call ZAxisCheck ${ZDist} 4.1
        /if (${Select[${Role},pullertank,pullerpettank,puller]} && ${Pulling}) {
            /varset PullTooFar 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Change Var Int resets various interger settings from ini file
| ----------------------------------------------------------------------------
    Sub Bind_ChangeVarInt(ISection, IName, IVar)
        DEBUGN Bind_ChangeVarInt ${ISection} ${IName} ${IVar} \agLine#:${Macro.CurLine}"
        /echo Changing ${IName} to ${IVar}
        /varset ${IName} ${IVar}
        /ini ${IniFileName} "${ISection}" "${IName}" "${IVar}"
        /if (${IName.Find[mezon]} && !${Defined[MezTimer1]}) /call CreateTimersMez
        /if (${IName.Find[dpson]} && !${Defined[DPSTimer1]}) /call CreateTimersDPS
        /if (${IName.Find[buffson]} && !${Defined[Buffs1Timer0]}) {
            /call CreateTimersBuffs
            /echo Buffs on creating timers
        }
        /if (${IName.Equal[ChaseAssist]} && ${ReturnToCamp}) /varset ReturnToCamp 0
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==0 && (${Stick.Active} || ${AdvPath.State})) {
			/squelch /stick off
			/afollow off
		}
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==1 && (!${Stick.Active} && !${AdvPath.State})) /varset RebuffOn 300
		/if ((${IName.Equal[ChaseAssist]} || ${IName.Equal[ReturnToCamp]}) && ${Spawn[${MainAssist}].ID}) /varset CampZone ${Zone.ID}
		/if (${Spawn[=${IVar}].ID}) {
			/echo setting ChaseName to ${IVar}
			/varset ChaseName ${IVar}
		}
        /if (${IName.Equal[MaxRadius]}) /varcalc CampRadiusExceed ${MaxRadius}+200
    /return
| ----------------------------------------------------------------------------
| SUB: Event Task Update - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_TaskUpdate(Line,name)
       /call BroadCast t "Task updated...(${name})"
    /return
| ----------------------------------------------------------------------------
| SUB: Event Gain Something - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_GainSomething(string Line,string text)
        /if (!${EQBCOn} && !${IRCOn}) /return
        /if (${Line.Find["ABILITY POINT!"]}) {
            /call BroadCast w "${Me.Name} gained an AA, now has ${Me.AAPoints} unspent"
        } else /if (${Line.Find[LEVEL]}) {
            /call BroadCast w "${Me.Name} gained a level, now is Level ${Me.Level}"
            /if (${GMailEvents.Find[level]}) /call GmailSend "${Me.Name} gained a level, I am Level ${Me.Level}"
           | Recalculate pull when level gained
            /if (${PullLevel.Find[auto]}) {
               /varcalc PullMin ${Me.Level}-5
               /varcalc PullMax ${Me.Level}+2       
            } 
        } 
		/if (${TheWinTitle.NotEqual[NULL]}) {
        	/SetWinTitle ${TheWinTitle}
		}
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Mule Edit - Edit ini file in MQ2NotePad
| ----------------------------------------------------------------------------
    Sub Bind_MuleE
        /if (!${Bool[${Plugin[MQ2Notepad]}]}) {
            /echo This function requires MQ2Notepad to be loaded..
            /echo 1. Please copy MQUI_NotepadWindow.xml to your Everquest/UIFiles/default or custom ui folder
            /echo 2. then /Plugin MQ2notepad
        }
        /if (${Bool[${Plugin[MQ2Notepad]}]}) {
            /docommand /notepad Muleassist_${Me}.ini
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Mule Check - scan ini file for errors based on nostress MuleNamechecker.mac
| ----------------------------------------------------------------------------
    Sub Bind_MuleCheck
        /call ScanIni
    /return
| ----------------------------------------------------------------------------
| SUB: Event Invised Mainly to turn off bard twisting while invis.
| ----------------------------------------------------------------------------
    Sub Event_Invised
        /if (${IAmABard} && ${Twist}) {
           /if  (!${Me.Gem[${Twist.Current}].HasSPA[12]}) {
				/twist stop
				/varset TwistStop ${Macro.CurLine}
				/stopsong
				/if (${MuleDebug}) /echo Stopping twist at \ag${Macro.CurLine}
				}
        }
    /return

| ----------------------------------------------------------------------------
| SUB: Event SomeoneSays
| ----------------------------------------------------------------------------
    Sub Event_SomeoneSays(SSMessage,SSName,SSText)
	/if (${Spawn[=${SSName}].Type.NotEqual[Pet]} && ${Spawn[=${SSName}].Type.NotEqual[NPC]}) {
		/if (${MuleDebug}) /echo [Event_SomeoneSays] ${SSName} said: ${SSText}
        	/if (${GMailEvents.Find[say]}) {
			/call GmailSend "${SSName} said: ${SSText}"
		}
		/doevents flush SomeoneSays
	}
    /return
 ----------------------------------------------------------------------------
| SUB: Event SomeoneTells
| ----------------------------------------------------------------------------
    Sub Event_SomeoneTells(STMessage,STName,STText)
	/if (!${Spawn[=${STName}].ID} || (${Spawn[=${STName}].Type.NotEqual[Pet]} && ${Spawn[=${STName}].Type.NotEqual[NPC]})) {
		/if (!${STName.Find[s pet]}) {
			|/echo [Event_SomeoneTells] ${STName} told me: ${STText}
        		/if (${GMailEvents.Find[tell]}) {
				/call GmailSend "${STName} told me: ${STText}"
			}
			|/doevents flush SomeoneTells
			|/call Event_Chat "Tell" "${STName}" "${STText}"
		}
	}
    /return
| ----------------------------------------------------------------------------
| SUB: Event ImDead
| ----------------------------------------------------------------------------
    Sub Event_ImDead
        /if (${IAmDead}) /return
        /echo I have died and the Angels wept.
		|/beep
        /if (${GMailEvents.Find[dead]}) /call GmailSend "I have died, passed on, departed my mortal coil."
        /varset IAmDead 1
        /call CombatReset ImDead
        /doevents flush ImDead
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM On
| ----------------------------------------------------------------------------
   Sub Event_GoMOn
   /if (${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
		/doevents flush GoMOn
		/return
   }
   /if (!${CombatStart} || ${GoMTimer} || !${GoMOn}) /return
            | Release timer after trying to cast for 10 secs
	    	/varset GoMTimer 3s
            /declare i int local 0
            /declare GoMCast string local
            /declare GoMTarget string  local
            /for i 1 to ${GoM.Size}
                /if (!${ConditionsOn} || !${GoMCOn} || ${If[${GoMCond[${i}]},1,0]}) {
                    /varset GoMCast ${GoM[${i}].Arg[1,|]}
                    /varset GoMTarget ${GoM[${i}].Arg[2,|]}
                    /if (${GoMCast.Equal[null]} || ${GoMCast.Find[spell]} || ${GoMSpellTimer${i}}) /goto :NextGOM
                    /echo Gift of Mana detected! Trying to cast ${GoMCast}
                    /doevents flush GoMOn
                    /if (${GoMTarget.Equal[Mob]} || (${GoMTarget.Equal[NULL]} && ${MyTargetID})) /varset GoMTarget ${MyTargetID} 
                    /if (${GoMTarget.Equal[Me]} && ${Me.ID}) /varset GoMTarget ${Me.ID}
                    /if (${GoMTarget.Equal[MA]} && ${Spawn[=${MainAssist}].ID}) /varset GoMTarget ${Spawn[=${MainAssist}].ID} 
                    /varset GoMActive 1
                    /if (${GoMTarget.Equal[${MyTargetID}]} && (${Target.Type.Equal[Corpse]} || !${Spawn[id ${MyTargetID}].ID})) {
                        DEBUGN Event_GoMOn [GoM] skipping because mob is dead or a corpse."
                        /echo [GoM] being skipped, because target (${GoMTarget}) is a corpse.
                        /varset GoMTimer 0
                        |delayremove/delay 10                        
                        /doevents GoMOff
                        /return
                    }
                    | Wait for global cooldown if active
                    /delay 60 ${Me.SpellInCooldown}==FALSE
                    /if (${Me.SpellReady[${GoMCast}]}) {
                        /call CastWhat "${GoMCast}" ${GoMTarget} GoM
                    } else {
                        /echo "${GoMCast}" is not ready!
                        /delay 1
                    }
                    DEBUGN Return: ${Macro.Return} \agLine#:${Macro.CurLine}"
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Gift of Mana Casting >> ${GoMCast} << 
                        /varset GoMTimer 0
                        /varset GoMSpellTimer${i} (${Spell[${GoMCast}].Duration.TotalSeconds}*${DurationMod})*10
                        /doevents flush GoMOn
                        |delayremove/delay 5
                        /doevents GoMOff
                        /return
                    }
                    :NextGOM
                }
            /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM Off
| ----------------------------------------------------------------------------
    Sub Event_GoMOff
        /varset GoMActive 0
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo guild meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_GUEQBC(Message,GUName,GUText)
        /if (${GUName.Equal[${Me.CleanName}]}) /return
        /if (${Select[${EQBCOn},2,4]} || ${Select[${DanNetOn},2,4]}) /call BroadCast p "${GUName} tells Guild: ${GUText}"
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo fellowship meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_FSEQBC(Message,FSName,FSText)
        /if (${FSName.Equal[${Me.CleanName}]}) /return
        /if (${Select[${EQBCOn},3,4]} || ${Select[${DanNetOn},3,4]}) /call BroadCast p "${FSName} tells Fellowship: ${FSText}"
    /return
| ----------------------------------------------------------------------------
| SUB: Event EQBCIRC - Pick up commands from MQ2IRC or MQ2EQBC(todo)
| ----------------------------------------------------------------------------
   Sub Event_EQBCIRC(EQBCSay,EQBCSender,EQBCCommand)
    /call Event_Chat "EQBC" "${EQBCSender}" "${EQBCCommand}"
   /return
   
| ----------------------------------------------------------------------------
| SUB: AFK Tools from AHTools by Anonymous Hero
| ----------------------------------------------------------------------------
    Sub AFKTools
    /declare holding bool local
    /if (${CampZone}!=${Zone.ID} || (${HealsOn} && ${AggroTargetID}) ) /return
    /if (${Select[${AFKToolsOn},1,2]}) {
        :CZLockDown
            /if (${Posse.Strangers}>=1) {
                /if (!${holding}) {
                    /echo [AHTools] Macro on hold due to player activity in camp radius.
                    /call BroadCast r "**PCS DETECTED IN CAMP RADIUS**"
                    /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                    /varset holding 1
                }
                /delay 1s
        /call CheckForCombat 1 AFKTools
        /doevents
        /goto :CZLockDown
        } else { /varset holding 0 }
    }
    /if (${Select[${AFKToolsOn},1,3]}) {
        /if (${Bool[${GMailEvents.Find[GM]}]}==TRUE && ${SpawnCount[GM]}>=1) /call GmailSend "GM in Zone, ${Zone.ShortName}" 
        :GMLockDown
        /if (${SpawnCount[GM]}>=1) {
            /if (${AFKGMAction}==1) {
                /if (!${holding}) {
                    /echo [AHTools] Macro on hold due to GM Presence
                    /call BroadCast r "** GM DETECTED **"
                    /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
					/delay 1s
                    /varset holding 1
                }
                /goto :GMLockDown
            } else {
                /varset holding 0
            }
            /if (${AFKGMAction}==2) /multiline ; /echo [AHTools] Ending Macro due to GM Presence ; /mq2log [AHTools] Ending Macro due to GM Presence ; /endmacro
            /if (${AFKGMAction}==3) /multiline ; /echo [AHTools] Unloading MQ2 due to GM Presence; /mq2log [AHTools] Unloading MQ2 due to GM Presence ; /unload
            /if (${AFKGMAction}==4) /multiline ; /echo [AHTools] Quitting out of EQ due to GM Presence ; /mq2log [AHTools] Quitting out of EQ due to GM Presence ; /quit
        }
    }
   /return
| ----------------------------------------------------------------------------
| SUB: Burn Section for new bind
| ----------------------------------------------------------------------------
    Sub Bind_Burn
        /call Event_Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Burn Section
| ----------------------------------------------------------------------------
    Sub Event_Burn
        /if (${IAmDead} || ${Me.Hovering} || ${CampZone}!=${Zone.ID} || ${BurnText.Equal[null]} || !${BurnText.Length}) {
            /doevents flush Burn
            /return
        }
        /declare i int local 0
        /declare BurnSpell string local
        /declare BurnTarget string local
        /declare BurnTargetID int local
        /declare  BurnIfSpell string local
        /call BroadCast r "BURN ACTIVATED => Autobots Transform <="
        /if (${UseTribute} && !${Me.TributeActive}) {
           /squelch /tribute personal on
           /varset TributeTimer 570s
        }
        /for i 1 to ${Burn.Size}
            /if (${Burn[${i}].Arg[2,|].Length}) {
                /varset BurnSpell ${Burn[${i}].Arg[1,|]}
                /varset BurnTarget ${Burn[${i}].Arg[2,|]}
            } else {
                /varset BurnSpell ${Burn[${i}]}
            }
            /if (${BurnSpell.Equal[null]} || ${Me.Hovering}) /goto :SkipBurnEntry
                /if (!${Burn[${i}].Arg[2,|].Length} || ${BurnTarget.Equal[Mob]}) /varset BurnTargetID ${MyTargetID}
                /if (${BurnTarget.Equal[Me]}) /varset BurnTargetID ${Me.ID}
                /if (${BurnTarget.Equal[MA]}) /varset BurnTargetID ${Spawn[=${MainAssist}].ID}
                /if (${BurnTarget.Equal[Pet]}) /varset BurnTargetID ${Me.Pet.ID}
                | /delay 10
                | Conditional Added to skip entry
                /if (${ConditionsOn} && ${BurnCOn} && ${If[${BurnCond[${i}]},0,1]}) /goto :SkipBurnEntry
                /if (${Burn[${i}].Arg[3,|].Length} && ${Burn[${i}].Arg[4,|].Length} && ${Burn[${i}].Arg[3,|].Equal[if]}) {
                    /varset BurnIfSpell ${Burn[${i}].Arg[4,|]}
                    /if (${Me.Buff[${BurnIfSpell}].ID} || ${Me.Song[${BurnIfSpell}].ID} || ${Me.ActiveDisc.Name.Find[${BurnIfSpell}]}) {
                        /echo ${BurnIfSpell} is active trying to cast ${BurnSpell}
                        /goto :CastBurn
                    } else /goto :SkipBurnEntry
                }
                /if (${Burn[${i}].Arg[3,|].Length} && ${Burn[${i}].Arg[4,|].Length} && ${Burn[${i}].Arg[3,|].Equal[notif]}) {
                    /varset BurnIfSpell ${Burn[${i}].Arg[4,|]}
                    /if (!${Me.Buff[${BurnIfSpell}].ID} && !${Me.Song[${BurnIfSpell}].ID} && !${Me.ActiveDisc.Name.Find[${BurnIfSpell}]}) {
                        /echo ${BurnIfSpell} is NOT active trying to cast ${BurnSpell}
                        /goto :CastBurn
                    } else /goto :SkipBurnEntry
                }
                :CastBurn
                /call CastWhat "${BurnSpell}" ${BurnTargetID} Burn
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting >> BURN${i}:${BurnSpell}
                    |/delay 10
                }
            :SkipBurnEntry
        /next i
        /doevents flush Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  Code from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Event_TooSteep
        /varset CampfireOn 0
        /echo Setting CampfireOn to 0. You are on a hill.
    /return


| ----------------------------------------------------------------------------
| SUB: GoBackToCamp Section - Goes back to camp
| ----------------------------------------------------------------------------
Sub Bind_GoBackToCamp
	/if (!${Navigation.Active}) {
		/echo [bind] Going back to camp...
               	/nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
	} else {
		/echo well... it looks like Navigation.Active is ${Navigation.Active} so we shouldnt start another
	}
/return
| ----------------------------------------------------------------------------
| SUB: Custom Function
| ----------------------------------------------------------------------------
Sub CustomFunc(string thefuncname)
	/echo CustomFunc ${thefuncname} called.
	/varset CallCustomFunc 0
	| Rocket is a helper function that jumps characters up on platforms in one of the TBL trials using Rocketeer Boots.
	| Platforms are 1-5 clockwise with 1 being the platform closest to the entrance and 5 the middle platform.
	|    4o
	|3o  5o  1o ===== X ===QuestGiver===
	|    2o
	| Usage: /bcga //customcall Rocket # where # is 1-5
	/if (${CustomFuncName.Equal[Rocket]}) {
		/if (${Me.ItemReady[Rocketeer Boots]}) {
			/varset ChaseAssist 0
			/varset ReturnToCamp 0
 			/if (${Me.Mount.ID}) /dismount
			/stopcast
			/squelch /stick off
			/squelch /moveto off
		   /if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.Playing}) {
				/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
				/play off
 			}
			/if (${Bool[${Plugin[mq2navigation]}]}==TRUE || ${Bool[${Plugin[mq2nav]}]}==TRUE) {
				/if (${Navigation.Active}) {
					/echo Stopping nav \agLine#:${Macro.CurLine}
					/nav stop
				}
			}
			/if (${CustomFuncParam.Equal[1]}) {
				/nav locyxz 610 322 -75
				/delay 1s ${Navigation.Active}
				/delay 5s !${Navigation.Active}
				/echo we arrived at jump spot
				/face fast heading 210
				/look 128
				/delay 1s
				/useitem rocketeer
				/delay 5 ${Me.Casting.ID}
				/delay 7 !${Me.Casting.ID}
				/keypress forward hold
				/delay 1s
				/keypress forward
				/look 0
			}
			/if (${CustomFuncParam.Equal[2]}) {
				/nav locyxz 535 323 -75
				/delay 1s ${Navigation.Active}
				/delay 5s !${Navigation.Active}
				/echo we arrived at jump spot
				/face fast heading 100
				/look 128
				/delay 1s
				/useitem rocketeer
				/delay 5 ${Me.Casting.ID}
				/delay 7 !${Me.Casting.ID}
				/keypress forward hold
				/delay 1s
				/keypress forward
				/look 0
			}
			/if (${CustomFuncParam.Equal[3]}) {
				/nav locyxz 590 400 -75
				/delay 1s ${Navigation.Active}
				/delay 5s !${Navigation.Active}
				/echo we arrived at jump spot
				/face fast heading 55
				/look 128
				/delay 1s
				/useitem rocketeer
				/delay 5 ${Me.Casting.ID}
				/delay 7 !${Me.Casting.ID}
				/keypress forward hold
				/delay 5
				/keypress forward
				/look 0
			}
			/if (${CustomFuncParam.Equal[4]}) {
				/nav locyxz 600 258 -75
				/delay 1s ${Navigation.Active}
				/delay 5s !${Navigation.Active}
				/echo we arrived at jump spot
				/face fast heading 35
				/look 128
				/delay 1s
				/useitem rocketeer
				/delay 5 ${Me.Casting.ID}
				/delay 7 !${Me.Casting.ID}
				/keypress forward hold
				/delay 1s
				/keypress forward
				/look 0
			}
			/if (${CustomFuncParam.Equal[5]}) {
				/nav locyxz 528 339 -75
				/delay 1s ${Navigation.Active}
				/delay 5s !${Navigation.Active}
				/echo we arrived at jump spot
				/face fast heading 25
				/look 128
				/delay 1s
				/useitem rocketeer
				/delay 5 ${Me.Casting.ID}
				/delay 7 !${Me.Casting.ID}
				/keypress forward hold
				/delay 1s
				/keypress forward
				/look 0
			}
		}
	}
	/varset CustomFuncParam
	/varset CustomFuncName
/return
| ----------------------------------------------------------------------------
| This is a first attempt at getting up on the platforms in one of the TBL trials
| It's work in progress, I would not expect it to work perfectly yet, if ever.
| ----------------------------------------------------------------------------
Sub Bind_CustomCall(string custfuncname, string custparam)
	/varset CustomFuncName ${custfuncname}
	/varset CustomFuncParam ${custparam}
	/varset CallCustomFunc 1
/return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  OriginalCode from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Bind_Campfire
    /if (${Select[${Zone.ID},33506]}) /return
        /windowstate FellowshipWnd open
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
        /if (${Me.Fellowship.CampfireZone.ID}!=${Zone.ID}) {
            /nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
            /delay 5s ${Window[ConfirmationDialogBox].Open}
            /if (${Window[ConfirmationDialogBox].Open}) {
                /nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
            }
            /delay 5s !${Me.Fellowship.CampfireZone.ID}
        }
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
        /delay 1s        
        /nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect 1
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
        /delay 5s ${Me.Fellowship.CampfireZone.ID}
        /windowstate FellowshipWnd close
        /if (${Me.Fellowship.CampfireZone.ID}) {
		/echo Campfire Dropped
		/varset OldCampfireX ${Me.Fellowship.CampfireX}
		/varset OldCampfireY ${Me.Fellowship.CampfireY}
		/varset OldCampfireZ ${Me.Fellowship.CampfireZ}
	}
    /return
| ----------------------------------------------------------------------------
| SUB: Sort Array DPS 		DPSCond 	1|1		 <
| ----------------------------------------------------------------------------
    Sub SortArray(ArrayName, CArrayName, HiLo, SortHow)
        /declare i                  int     local
        /declare j                  int     local
        /declare k                  int     local
        /declare l                  int     local
        /declare m                  int     local
        /declare TempSortedName     string  local ${HiLo}
        /declare TempPos            int     local 0
        /declare NewArrayPos        int     local 0
        /declare NewArraySize       int     local 0
        /declare TempArray[${${ArrayName}.Size}] string     local 0
        /declare TArray2[${${ArrayName}.Size}]   string     local 0
        /declare CArray[${${ArrayName}.Size}]    string     local TRUE
        /declare MArrayCount int    local 1
        /declare WArrayCount int    local 1
        /declare TempSwapHold       string  local
        /declare Swapped            int     local 1
        /if (${Select[${CArrayName},NULL,GoMCond,HealsCond,DPSCond,BurnCond,GHCond,SHCond,MashCond,WeaveCond,AggroCond,BandolierCond]}==0) {
            /echo ${CArrayName} is an invalid Condition. Supported Conditions for DPS, GOM, Burn, Heals, Mash, Weave, Bandolier and Aggro. 
            /beep
        }
        | Assign Array to temp array
        /for i 1 to ${${ArrayName}.Size}
            DEBUGN ${i} ${${ArrayName}[${i}]} \agLine#:${Macro.CurLine}"
            /varset TempArray[${i}] ${Parse[2,${${ArrayName}[${i}]}]}
			|/echo ${Parse[2,${${ArrayName}[${i}]}]} ||| ${TempArray[${i}]}
            /if (${CArrayName.NotEqual[null]}) {
                /vardata CArray[${i}] ${CArrayName}[${i}]
            }
        /next i
        /if (${ArrayName.Equal[dps]}) {
            /for i 1 to ${TempArray.Size}
                /if (${TempArray[${i}].Find[|weave]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset WeaveArray[${WArrayCount}] ${Parse[2,${TempArray[${i}]}]}
                    /vardata WeaveCond[${WArrayCount}] CArray[${i}]
                    DEBUGN ${WeaveArray[${WArrayCount}]}"
                    /if (${WArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc WArrayCount ${WArrayCount}+1
                } else /if (${TempArray[${i}].Find[|mash]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset MashArray[${MArrayCount}] ${TempArray[${i}].Arg[1,|]}
                    /vardata MashCond[${MArrayCount}] CArray[${i}]
					|Lemons: MashTimer cause we can't check ability distances and don't want to spam. ${${MashThis.Replace[ ,]}Timer}
					/declare ${TempArray[${i}].Arg[1,|].Replace[ ,]}Timer timer outer 2s
                    DEBUGN ${MashArray[${MArrayCount}]}"
                    /if (${MArrayCount}) /varset TempArray[${i}] NULL
                    /varcalc MArrayCount ${MArrayCount}+1
                }
            /next i
        }
        | Move Array to Temp Array leaving out useless entries.
        /for m 1 to ${${ArrayName}.Size}
            /if (${TempArray[${m}].Length} && !${TempArray[${m}].Find[|0]} && ${TempArray[${m}].NotEqual[null]} || ((${ArrayName.Equal[DPS]} && ${TempArray[${i}].Find[|mash]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) || (${ArrayName.Equal[DPS]} && ${TempArray[${i}].Find[|weave]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}))) {
                /varcalc NewArrayPos ${NewArrayPos}+1
                /varset TArray2[${NewArrayPos}] ${Parse[2,${TempArray[${m}]}]}
                /varcalc NewArraySize ${NewArraySize}+1
                /if (${CArrayName.NotEqual[null]} && ${m}!=${NewArrayPos}) {
                     /vardata CArray[${NewArrayPos}] CArray[${m}]
                     /varset CArray[${m}] null
                }
            } else {
                /if (${CArrayName.NotEqual[null]}) /varset CArray[${m}] null
            }
        /next m
        |Sort the Array if needed
        /if (!${Select[${ArrayName},Buffs,Burn,Aggro]} && ${NewArraySize}>1) {
            /varset m ${NewArraySize}
            /while (${Swapped} && ${m}>1) {
                /varset Swapped 0
                /for k 2 to ${m}
                    /varcalc j ${k}-1
                    /if (${TArray2[${j}].Arg[2,|]} ${SortHow} ${TArray2[${k}].Arg[2,|]}) {
                        /varset TempSwapHold ${Parse[2,${TArray2[${j}]}]}
                        /varset TArray2[${j}] ${Parse[2,${TArray2[${k}]}]}
                        /varset TArray2[${k}] ${Parse[2,${TempSwapHold}]}
                        /varset Swapped 1
                        /if (${CArrayName.NotEqual[null]}) {
                            /vardata TempSwapHold CArray[${j}]
                            /vardata CArray[${j}] CArray[${k}]
                            /vardata CArray[${k}] TempSwapHold
                        }
                    }
                /next k
                /varcalc m ${m}-1
            }
        }
        | Bail if array is empty and turn off switch
        /if (!${NewArraySize}) {
            /if (${Defined[${ArrayName}On]}) {
				|Lemons: If you had all Weave or all Mash entries, it was turnig off DPS.
				/if (${ArrayName.Equal[DPS]} && !${Defined[MashArray]} && !${Defined[WeaveArray]}) {
					/varset ${ArrayName}On 0
					/echo ERROR: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
					/beep
					/delay 20
				}
            }
			/if (${ArrayName.Equal[dps]}) /call CreateTimersDPS
			/echo No NewArraySize for ${ArrayName}
            /return
        }
        /deletevar ${ArrayName}
        /declare ${ArrayName}[${NewArraySize}] string outer
        /for l 1 to ${NewArraySize}
            /varset ${ArrayName}[${l}] ${Parse[2,${TArray2[${l}]}]}
            DEBUGN ${${ArrayName}[${l}]} \agLine#:${Macro.CurLine}"
        /next l
        /if (${CArrayName.NotEqual[null]}) {
            /deletevar ${CArrayName}
            /declare ${CArrayName}[${NewArraySize}] string outer
            /for l 1 to ${NewArraySize}
                /vardata ${CArrayName}[${l}] CArray[${l}]
            /next l
        }
        /if (${ArrayName.Equal[buffs]}) /call CreateTimersBuffs
        /if (${ArrayName.Equal[dps]}) /call CreateTimersDPS
        DEBUGN ${${ArrayName}.Size} \agLine#:${Macro.CurLine}"
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers DPS
| ----------------------------------------------------------------------------
    Sub CreateTimersDPS    
        | Declare timers for DPS duration spells and Attack buffs
        /declare i int local 0
        /varset DebuffCount 0
        /for i 1 to ${DPS.Size}
			|Lemons: This should allow people to have empty slots in their entries without triggering #warning. 
            /if (${Int[${DPS[${i}].Arg[2,|]}]}<101 || (!${Int[${DPS[${i}]}]} && ${Int[${DPS[${Math.Calc[${i}+1]}]}]})) { 
                /declare DPSTimer${i}       timer         outer 5
                /declare ABTimer${i}        timer         outer 0
                /declare FDTimer${i}        timer         outer 0
				DEBUGDPS CreatTimersDPS Created DPSTimer${i} for ${Int[${DPS[${i}].Arg[2,|]}]}<101"
            } else {
                /declare DBOTimer${i}       timer         outer 0
                /declare DBOList${i}        string        outer 
                /varcalc DebuffCount ${DebuffCount}+1
				DEBUGDPS CreatTimersDPS Created DBOTimer${i} for ${Int[${DPS[${i}].Arg[2,|]}]}<101 and DebuffCount is now ${DebuffCount}"
            }
			DEBUGDPS DPSCounter is now ${DPSCounter}"
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: Assign single heals - seperate single heals from group heals
| ---------------------------------------------------------------------------
Sub FindSingleHeals
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
    DEBUGN Enter FindSingleHeals \agLine#:${Macro.CurLine}"
    /declare i int local 0
    /declare j int local 0
    /declare SHCount int local 0
    /declare HealHighPoint int  local 0
    /declare HealHighestPoint int  local 0
    /declare HealHighestPointMA int  local 0
    /declare HealPointTag string  local 0
    /declare HealSpell string  local
    /for i 1 to ${Heals.Size}
        /varset HealSpell ${Heals[${i}].Arg[1,|]}
        /varset HealHighPoint ${Heals[${i}].Arg[2,|]}
        /varset HealPointTag ${Heals[${i}].Arg[3,|]}
        DEBUGN ${i} ${HealSpell} ${Spell[${HealSpell}].TargetType} ${Select[${Spell[${HealSpell}].TargetType},SingleHeal,Self]} \agLine#:${Macro.CurLine}"
        /if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        /if (${Select[${Me.Class.Name},Druid,Shaman]} && (${HealSpell.Find[Intervention]} || ${HealSpell.Find[Survival]})) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        /if (${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${Heals[${i}].Arg[3,|].Find[tap]} || ${Heals[${i}].Arg[3,|].Find[pet]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && ${Select[${Heals[${i}].Arg[3,|]},MA,ME,pet]}) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        /if (${Spell[${HealSpell}].TargetType.Equal[Free Target]}) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        :NextSH
        /if (${HealHighPoint} > ${SingleHealPoint}) {
			/varset SingleHealPoint ${HealHighPoint}
		}
        DEBUGN ${SingleHealPoint} \agLine#:${Macro.CurLine}"
    /next i
    /if (${SHCount}) /call SortArray SingleHeal SHCond 100|100 >    
    /for j 1 to ${SingleHeal.Size}
         DEBUGN ${j} ${SingleHeal[${j}]} ${Spell[${SingleHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration} \agLine#:${Macro.CurLine}"
         
    /next j 
    DEBUGN Leave FindSingleHeals ${SingleHeal.Size} \agLine#:${Macro.CurLine}"
/return    
| ----------------------------------------------------------------------------
| SUB: Assign Group heals
| ---------------------------------------------------------------------------
Sub FindGroupHeals
	/if (${BuffMode}) {
		/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
		/return
	}
	/if (${ZombieMode}) {
		/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
		/return
	}	
    /if (!${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) /return
    DEBUGN Enter FindGroupHeals \agLine#:${Macro.CurLine}"
    /declare i int local 0
    /declare j int local
    /declare GHCount int 0
    /declare HealSpell string  local
    /for i 1 to ${Heals.Size}
        /varset HealSpell ${Heals[${i}].Arg[1,|]}    
        DEBUGN ${HealSpell} \agLine#:${Macro.CurLine}"
        /if (!${HealSpell.Length} || ${HealSpell.Equal[null]} || ${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]}) /goto :NextGH
        /if (${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) /goto :NextGH
        /if (${Me.Class.Name.Equal[Shaman]} && ${Spell[${HealSpell}].Name.Find[Intervention]} || ${Me.Class.Name.Equal[Druid]} && ${Spell[${HealSpell}].Name.Find[Survival]}) /goto :NextGH
        /if (${Spell[${HealSpell}].TargetType.Find[group v]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && !${Select[${Heals[${i}].Arg[3,|]},MA,ME]}) {
            /varcalc GHCount ${GHCount}+1
            /varset GroupHeal[${GHCount}] ${Heals[${i}]}
            /vardata GHCond[${GHCount}] HealsCond[${i}]
            /goto :NextGH
        }
        :NextGH
    /next i
    DEBUGN ${GHCount} \agLine#:${Macro.CurLine}"
    /if (${GHCount}) {
        /call SortArray GroupHeal GHCond 100|100 >    
        /for j 1 to ${GroupHeal.Size}
            DEBUGN ${j} ${GroupHeal[${j}]} ${Spell[${GroupHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${GroupHeal[${j}].Arg[1,|]}].Duration} \agLine#:${Macro.CurLine}"
        /next j 
    }
    DEBUGN Leave FindGroupHeals \agLine#:${Macro.CurLine}"
/return    
| ----------------------------------------------------------------------------
| SUB: Create Timers Heals
| ----------------------------------------------------------------------------
    Sub CreateTimersHeals    
        | Declare timers for Heal duration spells
        /declare j int local
        /declare k int local
        /declare q int local
        /for j 1 to ${GroupHeal.Size}
            | Group Heal duration timers
            /declare SpellGH${j}    timer   outer   0
        /next j
        /for j 1 to ${SingleHeal.Size}
            /for k 0 to 13
                | Self and MA duration heal timers for  out of group including Pets.
                /declare Spell${j}GM${k}     timer   outer   0
                DEBUGN Group heal Timers Spell${j}GM${k} ${Spell${j}GM${k}}"
            /next k
        /next j
       | Declare timers for Pet heals
        /for q 1 to ${SingleHeal.Size}
            /declare PetHealTimer${q} timer outer 0
        /next q
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Rez
| ----------------------------------------------------------------------------        
    Sub CreateTimersRez    
        | Declare timers for Rez duration spells
        /declare m int local
        /for m 1 to 5
            /declare BattleRezTimer${m} timer outer 0
        /next m
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Mez
| ----------------------------------------------------------------------------    
    Sub CreateTimersMez
        | Declare timers for mezzing
        /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
            /declare l int local
            /for l 1 to 30
                /declare MezTimer${l} timer outer 0
                /declare MMTimer${l} timer outer 0
            /next l
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Creat Timers Buffs
| ----------------------------------------------------------------------------
    Sub CreateTimersBuffs
        | Declare timers for Buff duration spells
        /declare o int local
        /declare p int local
        | Create buff timer for all buff in array
        /for o 1 to ${Buffs.Size}
           | Create timers for everyone in group plus 2 extra for MA buffs
            /for p 0 to 7
                /declare Buff${o}GM${p}     timer   outer   0
                DEBUGN Buff Timers:Buff${o}GM${p} ${Buff${o}GM${p}}"
            /next p
        /next o
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers GoM
| ----------------------------------------------------------------------------        
    Sub CreateTimersGoM    
        | Declare timers for Rez duration spells
        /declare i int local 0
        /for i 1 to 5
            /declare GoMSpellTimer${i} timer outer 0
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: ZCheck /call ZAxisCheck current ,Z to check, difference
| ----------------------------------------------------------------------------
    Sub ZAxisCheck(float Zcur, float Zdiff)
        | Move down if Z distance more than Zcheck due to levitation
        DEBUGN ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Enter."
        /if (${Zcur}>=${Zdiff}) {
            /keypress CMD_MOVE_DOWN hold
            /delay 10 ${Math.Distance[${CampZLoc}:${Me.Z}]}<=${Zdiff}
            /keypress CMD_MOVE_DOWN
        }
        DEBUGN ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Exit."
    /return
| ----------------------------------------------------------------------------
| SUB: Event_PTaunt 
| ----------------------------------------------------------------------------
    Sub Event_PTaunt
        /varset PetTauntOn 1
    /return
| ----------------------------------------------------------------------------
| SUB: Event_BagsFull added by gSe7eN
| ----------------------------------------------------------------------------
    Sub Event_BagsFull
        /call BroadCast r "I have something on my cursor and no where to put it! HELP! DO SOMETHING!!!"
    	/delay 1s
		/beep
		/doevents flush BagsFull
	/return
| ----------------------------------------------------------------------------
| SUB: Event_WornOff - secondary check to rebuff
| ----------------------------------------------------------------------------
    Sub Event_WornOff(string Line, string wospell, string wotarget)
        |/echo \atEvent_WornOff Triggered: Line="${Line}" wospell=${wospell} wotarget=${wotarget} \agLine#:${Macro.CurLine}

        /if (!${RebuffOn}) /return
        /if (${wotarget.Equal[${Me}]}) /return
        |/if (${Me.Class.Name.Find[bard]}) /return
        /if (${wospell.Find[promised]}) /return
		/if (${Spawn[=${wotarget}].Type.Equal[NPC]}) /return
		/if (${Spell[${wospell}].SpellType.Equal[Detrimental]}) /return

       | /echo \atEvent_WornOff Triggered: ${wospell} ${wotarget} \agLine#:${Macro.CurLine}
        /declare i int local 0
        /declare j int local
        /declare WOSpellTT string local 0
        /declare WOTries int local 0
		/declare DPSStart    int      local ${Math.Calc[${DebuffCount}+1]}
		|15.2.6 Removed the check because it's nearly impossible to know if a spell cast from an item wore off. Will need to test how this goes.
		|/if (${Me.Book[${wospell}]} || ${Me.AltAbilityReady[${wospell}]}) {
			/if (${Spawn[=${wotarget}].ID}) {
				/if (${Spawn[=${wotarget}].Distance3D} < 200) {
					/echo ${wospell} wore off I need to recache spells so I will target ${wotarget} now real quick... \agLine#:${Macro.CurLine}
					/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
					/target id ${Spawn[=${wotarget}].ID}
					/delay 1s ${Target.ID}==${Spawn[=${wotarget}].ID}
					/delay 1s ${Target.CachedBuffCount}!=-1 
					|/delay 1s ${Target.BuffsPopulated}
				}
			}
		|}
        /if (${AggroTargetID} && ${Defined[DPSTargetID]}) {
			|Lemons: Capture combat buffs wearing off to reset their timer (limited hit DS)
			/if (${Me.Book[${wospell}]} && ${DPSTargetID}) {
				/for i ${DPSStart} to ${DPS.Size}
					/if (${Ini[${IniFileName},DPS,DPS${i}].NotEqual[NULL]} && ${Ini[${IniFileName},DPS,DPSOn]} && ${Defined[DPSTimer${i}${DPSTargetID}]}) {
						/if (${DPSTimer${i}${DPSTargetID}} && ${DPS[${i}].Arg[1,|].Equal[${wospell}]}) {
							/varset DPSTimer${i}${DPSTargetID} 0
							/echo Reseting DPSTimer${i}${DPSTargetID} for ${DPS[${i}]} cause it wore off from the trigger ${wospell}
							/break
						}
					}
				/next i
			}
			/varset CachedBuffTimer 0
			/return
		}
        /if (${Me.Book[${wospell}]}) {
            /varset WOSpellTT ${Spell[${Me.Book[${Me.Book[${wospell}]}].ID}].TargetType}
        } else {
            /varset WOSpellTT ${Spell[${wospell}].TargetType}
        }
        /for i 1 to ${Buffs.Size}
            /for j 1 to ${Group}
                /if (${Group.Member[${j}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                    /varset Buff${i}GM${j} 0
                    /echo ${wotarget} needs ${wospell} because it wore off.
                    :MakeSureCO
                    /if (${WOTries}>5) /goto :SkipWO
                    /if (${Select[${WOSpellTT},single,group]} && ${Me.Buff[${wospell}].ID})  {
                        |/if (${Select[${EverQuest.Server},fippy,vulak,ragefire,lockjaw]}==0) /removebuff ${wospell}
                        | reset spell timer on caster
                        /varset Buff${i}GM0 0
                        /varcalc WOTries ${WOTries}+1
                        /if (${Me.Buff[${wospell}].ID}) {
                            /goto :MakeSureCO
                        }
                    }
                }
            /next j
            | If MA out of group listen for buffs wearing off
            /if (!${Spawn[=${MainAssist} ${MainAssistType} group].ID} && ${Spawn[=${MainAssist}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                /varset Buff${i}GM7 0
                /echo ${wotarget} needs ${wospell} because it wore off.
            }
        /next i
        :SkipWO
        /varset ReadBuffsTimer 0
		/varset CachedBuffTimer 0
        /if (${IniNextTimer}) /varset IniNextTimer 0
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Merc state 4 = no gold membership
| ----------------------------------------------------------------------------
    Sub WriteBuffsMerc  
        /if (!${Spawn[mercenary ${Group.Member[1].ID}].ID}) /return
        /if (${WriteBuffsMercTimer}) /return
        /if (!${Redguides}) /return
        /if (${AggroTargetID}) /return
        /declare i int local 0
        /declare k int local 0
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Buffs
        | Write all current buffs to KissAssist_Buffs.ini file
		/if (${MuleDebug}) /echo Targeting a mob 14j
        /target id ${Spawn[mercenary ${MyMerc}].ID}
        /delay 2s ${Target.ID}==${Spawn[mercenary ${MyMerc}].ID}
		/delay 2s ${Target.CachedBuffCount}!=-1
        /for i 1 to 42
            /if (${Target.Buff[${i}].Name.Length}) {
                /varset BuffList ${Target.Buff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Buffs "${Writebufflist}"
        /varset WriteBuffsMercTimer 30s
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Pet
| ----------------------------------------------------------------------------
    Sub WriteBuffsPet
        /if (!${Me.Pet.ID}) /return
        /if (${AggroTargetID}) /return        
        /if (!${Select[${Role},pettank,pullerpettank]} && ${Spawn[=${MainAssist} ${MainAssistType}].ID}!=${Me.Pet.ID}) /return
        /if (${WriteBuffsPetTimer}) /return
        /if (!${Redguides}) /return
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs
        | Write all current buffs to KissAssist_Buffs.ini file
		/if (${MuleDebug}) /echo Targeting a mob 15w
        /target id ${Me.Pet.ID}
        /delay 2s ${Target.ID}==${Me.Pet.ID}
        /for i 1 to 50
            /if (${Me.PetBuff[${i}].Name.Length}) {
                /varset BuffList ${Me.PetBuff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs "${Writebufflist}"
        | Write all blocked buffs to KissAssist_Buffs.ini file
        /for k 0 to 40
            /varset Blockedbuff ${Me.BlockedPetBuff[${k}].Name}
            /if (${Blockedbuff.Length}) {
                 /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Blockedbuffs "${Blockedbufflist}"
        /varset WriteBuffsPetTimer 30s
    /return
| ----------------------------------------------------------------------------
| SUB: Clean Buffs File
| ----------------------------------------------------------------------------
    Sub CleanBuffsFile
        /if (${CleanBuffsTimer}) /return
        /declare i int local 0
        /declare SectionList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare SectionListCount int local ${SectionList.Count[|]}
        /if (${SectionListCount}==0) /return
        /varcalc SectionListCount ${SectionListCount}-1
        /declare SectionName string local
        /for i 1 to ${SectionListCount}
            /varset SectionName ${SectionList.Arg[${i},|]}
            /if (${Ini["KissAssist_Buffs.ini",${SectionName},Day].NotEqual[${Time.Day}]}) {
                /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
                /continue
            }
            /if (${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]}!=0) /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
        /next i
        /varset CleanBuffsTimer 10m
    /return
| ----------------------------------------------------------------------------
| SUB: AE check - cast area effect spells depending on set number of mobs
| ----------------------------------------------------------------------------
    Sub AECheck
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /if (!${AEOn}) /return
        /if (${Target.Type.Equal[corpse]}) /return
        /if (!${AggroTargetID}) /return
        DEBUGCOMBAT AECheck Enter \agLine#:${Macro.CurLine}"
        /declare i int local 0
        /declare j int local
        /declare k int local
        /declare l int local
        /declare AESpell string local
        /declare AEMobCount int local
        /declare AETarget string local
        /declare AETargetID int local
        /declare ArrayCount int local 0
        /declare AEIfSpell string local
        /declare AENotIfSpell string local
        /declare MobCountTemp int local
        /declare CheckSpawnID
        /call MobRadar ${AERadius} AECheck
        | Adjust mobcount by subtracting mobs not on xtarget
        DEBUGCOMBAT AECheck Mobcount:${MobCount} \agLine#:${Macro.CurLine}"
        /varset MobCountTemp ${MobCount}
        /for j 1 to ${MobCount}
            /varset CheckSpawnID ${NearestSpawn[${j},npc targetable los radius ${AERadius} zradius 50 noalert 3].ID}
            /for i 1 to ${XSlotTotal}
                /if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].ID}) {
                    /if (${CheckSpawnID}==${Me.XTarget[${i}].ID}) {
                        /varcalc ArrayCount ${ArrayCount}+1
                    }
                }
            /next i
            /if (${ArrayCount}==0) {
               /varcalc MobCountTemp ${MobCountTemp}-1 
              DEBUGCOMBAT AECheck MobCountTemp:${MobCountTemp} after xtarget spawn check \agLine#:${Macro.CurLine}"
            }
            /varset ArrayCount 0
        /next j 
        /if (${MobCountTemp}<=0) /return
        /for k 1 to ${AE.Size}
            /varset AESpell ${AE[${k}].Arg[1,|]}
            /varset AEMobCount ${AE[${k}].Arg[2,|]}
            /varset AETarget ${AE[${k}].Arg[3,|]}
            /varset AEIfSpell
            /varset AENotIfSpell
            | Check if AEspell is ready to use if not skip it
            /if (${AESpell.NotEqual[burn]} && !${Me.SpellReady[${Spell[${AESpell}].RankName}]} && !${Me.AltAbilityReady[${AESpell}]} && !${Me.CombatAbilityReady[${Spell[${AESpell}].RankName}]} && !${Me.AbilityReady[${AESpell}]}) /goto :NextAE
            | Check if AEspell if an item is ready to use. if not skip it
            /if (${FindItem[=${AESpell}].ID} && !${Me.ItemReady[=${AESpell}]}) /goto :NextAE
    /if (${AEMobCount}<=${MobCountTemp}) {
        /if (${AETarget.Equal[null]} || ${AETarget.Equal[Mob]} || ${AETarget.Equal[Single]}) /varset AETargetID ${MyTargetID}
        /if (${AETarget.Equal[Me]}) /varset AETargetID ${Me.ID}
        /if (${AETarget.Equal[MA]}) /varset AETargetID ${Spawn[=${MainAssist}].ID}
        /if (${AETarget.Equal[Pet]}) /varset AETargetID ${Me.Pet.ID}
        /if (${AESpell.Equal[burn]} && !${BurnActive}) {
            /echo AE-> ${MobCountTemp} Mobs: Activating BURN
            /varset BurnActive 1
            /call Event_Burn
            /return
        }
		/if (${Spell[${AESpell}].Beneficial}==FALSE) {
			/if (${Spawn[npc id ${AETargetID}].ID} && ${SpawnCount[npc xtarhater loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} ${Spawn[id ${AETargetID}].Z} radius ${Spell[${AESpell}].AERange}]} < ${SpawnCount[npc loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} ${Spawn[id ${AETargetID}].Z} radius ${Spell[${AESpell}].AERange}]}) {
				/if (${AETarget.NotEqual[Single]}) {
					/echo AE-> Casting ${Spell[${AESpell}].Name} now would aggro more mobs than we have on xtarget (${SpawnCount[npc loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} radius ${Spell[${AESpell}].AERange}]})
				}
				/goto :NextAE
			}
		}
        /if (${AE[${k}].Arg[3,|].Length} && ${AE[${k}].Arg[4,|].Length} && ${AE[${k}].Arg[3,|].Equal[if]}) {
            /varset AEIfSpell ${AE[${k}].Arg[4,|]}
            /if (${AE[${k}].Arg[5,|].Equal[mob]}) {
            /varset AETargetID ${MyTargetID}
            /if (${Int[${Target.Buff[${AEIfSpell}].ID}]}>0)
            /echo AE-> ${MobCountTemp} Mobs: ${AEIfSpell} is active on Target trying to cast ${AESpell}
            /goto :CastAE
            } else { 
                /if (${Me.Buff[${Spell[${AEIfSpell}].RankName}].ID} || ${Me.Song[${Spell[${AEIfSpell}].RankName}].ID} || ${Me.ActiveDisc.Name.Find[${AEIfSpell}]}) {
                    /echo AE-> ${MobCountTemp} Mobs: ${AEIfSpell} is active trying to cast ${AESpell}
                    /goto :CastAE
                } else {
                    /goto :NextAE
                }
            }
        }
        /if (${AE[${k}].Arg[3,|].Length} && ${AE[${k}].Arg[4,|].Length} && ${AE[${k}].Arg[3,|].Equal[notif]}) {
             /varset AENotIfSpell ${AE[${k}].Arg[4,|]}
             /if (${AE[${k}].Arg[5,|].Equal[mob]}) {
                 /varset AETargetID ${MyTargetID}
              /if (${Int[${Target.Buff[${AENotIfSpell}].ID}]}==0)
              /echo AE-> ${MobCountTemp} Mobs: ${AENotIfSpell} is Not active on Target trying to cast ${AESpell}
              /goto :CastAE
            } else { 
            /if (!${Me.Buff[${Spell[${AENotIfSpell}].RankName}].ID} && !${Me.Song[${Spell[${AENotIfSpell}].RankName}].ID} && !${Me.ActiveDisc.Name.Find[${AENotIfSpell}]}) {
                /echo AE-> ${MobCountTemp} Mobs: ${AENotIfSpell} is NOT active trying to cast ${AESpell}
                    /goto :CastAE
                } else {
                    /goto :NextAE
                }
            }
        }
        :CastAE
        /if (${MobCountTemp}==1 && ${AETarget.Equal[Single]}) {
            /call CastWhat "${AESpell}" ${AETargetID} AoE
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo AE-> ${AESpell} on Single target  >> ${Spawn[${AETargetID}].CleanName} <<
            }
            /goto :NextAE
        } else /if (${MobCountTemp}>=2 && ${AETarget.Equal[Single]}) {
            /goto :NextAE
        } else {
            /call CastWhat "${AESpell}" ${AETargetID} AoE
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo AE-> ${MobCountTemp} Mobs: Casting AE ${AESpell}
            }
        } 
    }
            :NextAE
        /next k
        DEBUGCOMBAT AECheck Leave \agLine#:${Macro.CurLine}"
    /return
| ----------------------------------------------------------------------------
| SUB: WriteDebuffs
| ----------------------------------------------------------------------------
    Sub WriteDebuffs
    DEBUGHEALS WriteDebuffs Enter \agLine#:${Macro.CurLine}"
        /declare DebuffList string local 
        /declare IAmDuffed int local ${Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Corrupted.ID}]}]}
        /if (${IAmDuffed} && !${NeedCuring}) {
            /varset NeedCuring 1
            /varset DebuffList ${IAmDuffed}|${Int[${Me.Poisoned.ID}]}|${Int[${Me.Diseased.ID}]}|${Int[${Me.Cursed.ID}]}|${Int[${Me.Corrupted.ID}]}
            /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
			DEBUGHEALS WriteDebuffs Writing debuffs to ini file \agLine#:${Macro.CurLine}"

        }
        /if (!${IAmDuffed} && ${NeedCuring}) {
            /varset NeedCuring 0
            /varset DebuffList 
            /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
           	DEBUGHEALS WriteDebuffs Clearing debuffs from ini file \agLine#:${Macro.CurLine}"
        }
        DEBUGHEALS WriteDebuffs Leave \agLine#:${Macro.CurLine}"
    /return
| ----------------------------------------------------------------------------
| SUB: CheckCures
| ----------------------------------------------------------------------------
    Sub CheckCures
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}
		/if (${ZombieMode}) {
			/if (${MuleDebug}) /echo ZombieMode is on\agLine#:${Macro.CurLine}
			/return
		}		
        /if (!${CuresOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        DEBUGHEALS CheckCures Enter  \agLine#:${Macro.CurLine}"
        /declare i int local 0
        /declare j int local
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniDebuffCount string local 0
        /declare IniDebuffList string local
        /declare CuretoCast string local 
        /declare CTID int local
        /for i 1 to ${Cures.Size}
            /if (!${Cures[${i}].Length}) /goto :skipi
            /for j 1 to ${IniIDCount}
                /varset CuretoCast
                /varset IniDebuffCount ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${j},|]},"Debuffs"]} 
                /varset CTID ${Spawn[${IniIDList.Arg[${j},|]}].ID}
				DEBUGHEALS CheckCures CuretoCast ${Cures[${i}]}  \agLine#:${Macro.CurLine}"
				DEBUGHEALS CheckCures ${IniDebuffCount.Arg[1,|]} && ${Spawn[${IniIDList.Arg[${j},|]}].ID} && ${Spawn[${IniIDList.Arg[${j},|]}].Distance}<100  \agLine#:${Macro.CurLine}"
				/if (${If[${CuresCond[${j}]},0,1]}) {
					DEBUGHEALS CheckCures Condition is FALSE"
					/continue
				}
                /if (${IniDebuffCount.Arg[1,|]} && ${Spawn[${IniIDList.Arg[${j},|]}].ID} && ${Spawn[${IniIDList.Arg[${j},|]}].Distance}<100) {
                    /if (${IniDebuffCount.Arg[1,|]} && ${Cures[${i}].Arg[2,|].Length}==0) {
                        /varset CuretoCast ${Cures[${i}]}
						DEBUGHEALS CheckCures CuretoCast ${Cures[${i}]}  \agLine#:${Macro.CurLine}"
                    } else /if (${IniDebuffCount.Arg[2,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[poison]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
						DEBUGHEALS CheckCures CuretoCast ${Cures[${i}].Arg[1,|]}  \agLine#:${Macro.CurLine}"
                    } else /if (${IniDebuffCount.Arg[3,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[disease]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
						DEBUGHEALS CheckCures CuretoCast ${Cures[${i}].Arg[1,|]}  \agLine#:${Macro.CurLine}"
                    } else /if (${IniDebuffCount.Arg[4,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[curse]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
						DEBUGHEALS CheckCures CuretoCast ${Cures[${i}].Arg[1,|]}  \agLine#:${Macro.CurLine}"						
                    } else /if (${IniDebuffCount.Arg[5,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[corruption]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
						DEBUGHEALS CheckCures CuretoCast ${Cures[${i}].Arg[1,|]}  \agLine#:${Macro.CurLine}"
                    }  
                    | Check cures for group component since they don't seem to work on out of group toons
					|Lemons: I wonder if this is still true? 3/5/21
                    /if (${Spell[${CuretoCast}].TargetType.Find[group v]} && !${Spawn[id ${IniIDList.Arg[${j},|]} group].ID}) {
                        /if (!${Defined[CureTimer${CTID}${i}]}) {
                            /declare CureTimer${CTID}${i} timer outer 30s
                            DEBUGHEALS CheckCures /echo declare CureTimer${CTID}${i} \agLine#:${Macro.CurLine}"
                        } else /if (!${CureTimer${CTID}${i}}) {
                            /varset CureTimer${CTID}${i} 30s
                            DEBUGHEALS CheckCures /echo varset CureTimer${CTID}${i} \agLine#:${Macro.CurLine}"
                        }  
                        /goto :skipj
                    }
                    /if (${Spawn[${IniIDList.Arg[${j},|]}].ID} && ${Spawn[${IniIDList.Arg[${j},|]}].Type.NotEqual[Corpse]}) {
                        /call CastWhat "${CuretoCast}" ${IniIDList.Arg[${j},|]} Cure
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast o "CURING: >> ${Spawn[${IniIDList.Arg[${j},|]}].CleanName} << with ${CuretoCast}"
                        |/delay 10
                    }
                }
	    :skipj
            /next j
	:skipi
        /next i
        DEBUGHEALS CheckCures Leave \agLine#:${Macro.CurLine}"
    /return
| ----------------------------------------------------------------------------
| SUB: WaitSubs - bunch of crap to call while medding standing around etc
| ----------------------------------------------------------------------------
    Sub WaitSubs(string sentFromWS)
        /if (${sentFromWS.NotEqual[DoWeMed]} && !${Me.Mount.ID} && !${Me.Sitting} && ((${Me.MaxMana} > 0 && ${Me.PctMana} < 90) || (${Me.MaxEndurance} > 0 && ${Me.PctEndurance} < 90) || (${Me.PctHPs} < 90)) && (!${Navigation.Active} && ${Stick.Status.Equal[OFF]} && !${AdvPath.State})) {
			 /call SitIfNotBard WaitSubs
		}
        /if (${HealsOn}) /call CheckHealth
        /call WriteDebuffs
        /if (${CuresOn}) /call CheckCures
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) /call DoMezStuff
        }
        /call WriteBuffs
        /if (${AutoRezOn}) /call RezCheck
        /call CanIDoStuff
        /call CastMana
        /if (${PetOn}) /call DoPetStuff
        /if (${BuffsOn}) /call CheckBuffs
        /if (${MercOn}) /call MercsDoWhat
    /return
| ----------------------------------------------------------------------------
| SUB: CheckBroadCast - Checks for EQBC or DanNet and respective connectivity
| ----------------------------------------------------------------------------
    Sub CheckBroadCast()
        /if (${EQBCOn}) {
            /if (${Macro.IsTLO[EQBC]}) {
                /if (${EQBC.Connected}) {
                    /return TRUE 
                } else {
                    /echo You are NOT connected to an EQBC Server. Please check your connection.
                }
            } else {
                /echo EQBC is Required, but the plugin is NOT Loaded.
            }
        } else /if (${DanNetOn}) {
            /if (${Macro.IsTLO[DanNet]}) {
                /if (${DanNet.PeerCount[all]}) {
                    /return TRUE
                } else {
                    /echo DanNet is Loaded but no Peers are connected.
                }
            } else {
                /echo DanNet is Required, but the plugin is NOT Loaded.
            }
        }
    /return FALSE
| ----------------------------------------------------------------------------
| SUB: BroadCast - Handles echos and messages in mq2irc and mq2eqbc
| ----------------------------------------------------------------------------
    Sub BroadCast(msgcolor, message)
        /call CheckBroadCast
        /if (!${Macro.Return}) {
            /echo ${message}
            /return
        }
        /if (${msgcolor.Equal[null]}) /varset msgcolor w
        /if (${EQBCOn}) {
            /if (TRUE) /${BroadCastSay} [+${msgcolor}+] [${Time}] ${message} [+x+]
        } else /if (${DanNetOn}) {
            /if (TRUE) /${BroadCastSay} \a${msgcolor} [${Time}] ${message} \aw
        } else {
            /echo ${message}
        }
        /if (${Bool[${Plugin[MQ2IRC]}]} && ${IRCOn}) {
            /i say ${message}
        }
    /return
| ----------------------------------------------------------------------------
| SUB: BCTell - Handles BCT and DnT to Character
| ----------------------------------------------------------------------------
    Sub BCTell(charName, message)
        /call CheckBroadCast
        /if (!${Macro.Return}) {
            /return
        }
        /if (${EQBCOn}) {
            /bct ${charName} [${Time}] ${message} [+x+]
        } else /if (${DanNetOn}) {
            /dgt ${charName} [${Time}] ${message} \aw
        }
    /return
| ----------------------------------------------------------------------------
| SUB: BCTExec - Handles BCT and Dex to Character
| ----------------------------------------------------------------------------
    Sub BCTExec(charName, message)
        /call CheckBroadCast
        /if (!${Macro.Return}) {
			/echo No return BCTExec
            /return
        }
        /if (${EQBCOn}) {
			/if (${charName.Equal[all]}) {
				/bca /${message}
				} else {
				/bct ${charName} /${message}
				}
        } else /if (${DanNetOn}) {
			/if (${charName.Equal[all]}) {
				/dgexecute /${message}
				} else {
				/dex ${charName} ${message}
				}
        }
    /return
| ----------------------------------------------------------------------------
| SUB: BCGExec - Handles BCG and DGGE (execute command on eq group)
| ----------------------------------------------------------------------------
    Sub BCGExec(message)
        /call CheckBroadCast
        /if (!${Macro.Return}) {
            /return
        }
		/echo message is ${message}
        /if (${EQBCOn}) {
            /bcg /${message}
        } else /if (${DanNetOn}) {
            /dgge ${message}
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire ${Window[FellowshipWnd].Child[FP_CampPage].Child[FP_CampsiteViewer].Text}
| ----------------------------------------------------------------------------
    Sub Campfire
        /if (!${CampfireOn}) /return
        /if (${CampfireTimer}) /return
        /if (${Me.Fellowship.CampfireZone.ID} && (${Me.Fellowship.CampfireZone.ID}==${Zone.ID} || ${Me.Fellowship.CampfireZone.Name.Find[guild hall]})) /return
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) /return
        /if (${AggroTargetID}) /return
        /if (${CombatStart}) /return
        /declare FellowCount int local 0
        /declare i int local 0
        /declare j int local
        /for i 1 to ${SpawnCount[pc radius 50]}
            /for j 1 to ${Me.Fellowship.Members}
                /if (${NearestSpawn[${i},PC radius 50].CleanName.Equal[${Me.Fellowship.Member[${j}]}]}) /varcalc FellowCount ${FellowCount}+1
            /next j
        /next i
        /if (${FellowCount}>=3) {
			/if (${OldCampfireX}!=0) {
				/if (${Math.Distance[${OldCampfireY},${OldCampfireX}]} < 200) {
				/echo we should drop campfire where old one was dropped.
				/nav locyxz ${OldCampfireY} ${OldCampfireX} ${OldCampfireZ}
				/delay 1s ${Navigation.Active}==TRUE
				/delay 5s ${Navigation.Active}==FALSE
			} else {
				/echo we are too far away from old campfire loc to drop in same location
				/echo dropping here...
			}
	    }
            /call Bind_Campfire
        } else {
            /echo Not enough fellowship members trying again in 5 minutes
            /varset CampfireTimer 5m
        }
        /doevents TooSteep
    /return
| ----------------------------------------------------------------------------
| SUB: NamedWatch
| ----------------------------------------------------------------------------
    Sub NamedWatch
    /if (!${BurnAllNamed}) {
		/return
    }
    /if (${Spawn[${MyTargetID}].Named}) {
        /popup *** Mob:(${Target.CleanName}) is a NAMED!
        /echo *** Mob:(${Target.CleanName}) is a NAMED!
        /call Event_Burn
        /varset NamedCheck 1 
        /if (${Bool[${GMailEvents.Find[named]}]}==TRUE) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
    } else /if (${Ini[Map_Labels,RareMobs,${Spawn[${MyTargetID}].CleanName}].Length}) {
		/popup *** Mob:(${Target.CleanName}) is a NAMED!
        /echo *** Mob:(${Target.CleanName}) is a NAMED!
        /call Event_Burn
        /varset NamedCheck 1 
        /if (${Bool[${GMailEvents.Find[named]}]}==TRUE) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
	} else {
        /declare i int local 0
        /for i 1 to 25        
            /if (${MobsToBurn.Find[null]}) /return
            /if (${MobsToBurn.Arg[${i},,].Length} && !${MobsToBurn.Find[null]} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${MyTargetID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Target.CleanName}]}) {
                /call Event_Burn
                /popup *** Mob:(${Target.CleanName}) is a NAMED!
                /echo *** Mob:(${Target.CleanName}) is a NAMED!    
                /if (${Bool[${GMailEvents.Find[named]}]}==TRUE) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                /varset NamedCheck 1 
            }
        /next i
    }
    /return
| ----------------------------------------------------------------------------
| SUB: Scan ini file for errors in spelling or missing items
| ----------------------------------------------------------------------------
    Sub ScanIni
    /declare i int local 1
    /declare j int local 1 
    /declare Section1 string local Buffs
    /declare Section2 string local DPS
    /declare Section3 string local Burn
    /declare Section4 string local Heals
    /declare Section5 string local AE
    /declare Section6 string local Cures
    /declare Section7 string local Pet
    /declare Section8 string local PetBuffs
    /declare Section9 string local GoM
    /declare CountEnrties int local 0
    /declare CountErrors int local 0
    /declare iniKey string local

    /for j 1 to 9
        |/echo ---------------->> Scanning ${Section${j}} <<----------------
        /varset CountEnrties 0
        /varset CountErrors 0
        /for i 1 to 40            
            /varset iniKey ${Ini[${IniFileName},${Section${j}},${Section${j}}${i}]}
            /if (${Section${j}.Equal[Pet]} && ${i}==1) /varset iniKey ${Ini[${IniFileName},${Section${j}},PetSpell]}
            /if (${Section${j}.Equal[Pet]} && ${i}==2) /varset iniKey ${Ini[${IniFileName},${Section${j}},PetShrinkSpell]}
            /if (${Section${j}.Equal[PetBuffs]}) /varset iniKey ${Ini[${IniFileName},Pet,Petbuffs${i}]}
            /if (${Section${j}.Equal[GoM]}) /varset iniKey ${Ini[${IniFileName},GoM,Gom${i}]}                                    
            /if (${iniKey.NotEqual[null]}) {
                DEBUGN ScanIni: ${Section${j}}${i}=${iniKey}  \agLine#:${Macro.CurLine}"
                | find out if there is a Rank and fix spell name.
                /call Spell_Rk_Check "${iniKey}"
                /varset iniKey ${Macro.Return}
                DEBUGN ScanIni: ${iniKey} after return  \agLine#:${Macro.CurLine}"
                /if (${iniKey.Find[|]}) /varset iniKey ${iniKey.Arg[1,|]}
                /if (${Section${j}.Equal[GoM]} && ${iniKey.Find[Gift Of Mana]}) /goto :SkipInientry
                /if (${Section${j}.Equal[AE]} && ${iniKey.Find[Burn]}) /goto :SkipInientry
				/if (${iniKey.Find[YourPetSpell]}) /goto :SkipInientry
                /if (!${Me.Book[${iniKey}]} && !${Me.CombatAbility[${iniKey}]} && !${Me.AltAbility[${iniKey}]} && !${FindItem[=${iniKey}].ID} && ${iniKey.NotEqual[banestrike]} && !${iniKey.Find[Summoned:]} && !${iniKey.Find[tiny companion]} && !${iniKey.Find[item:]} && !${iniKey.Find[command:]} && !${Me.Ability[${iniKey}]}) {
                    /if (${AltAbility[${iniKey}]}) {
						/echo ...ERROR: ${Section${j}}${i}=${iniKey} IS a AA but you have not bought it.
                    } else {
						/echo ...ERROR: ${Section${j}}${i}=${iniKey} unable to find as a Spell, AA, Item or Combat Ability
					}
					/varcalc CountErrors ${CountErrors}+1
                }
                /varcalc CountEnrties ${CountEnrties}+1
            }
            :SkipInientry
            /if (!${CountEnrties} && ${i}==20) {
                |/echo -- Nothing defined in this section
            }
            /if (!${CountErrors} && ${CountEnrties} && ${i}==20) {
                |/echo -- No Spelling Errors or Missing Items Detected
            }       
        /next i
    /next j
    /return
| -------------------------------------------------------------------------------------
|All Binds after this
| -------------------------------------------------------------------------------------	
| -------------------------------------------------------------------------------------
| SUB: CharmThis Command
| -------------------------------------------------------------------------------------
Sub Bind_CharmThis(string TarID, string Turing, sentFrom)
	/declare i int local 0
	/if ((${TarID.Equal[NULL]} || ${TarID.Equal[0]} || ${TarID.Length} == 0) && ${sentFrom.Equal[event]}) {
		/echo Probably some other chanter charmed a pet. Not gonna change anything.
		/return
	}
	/if (${TarID.Equal[Clear]}) {
		/for i 1 to ${Group.Members}
			/if (${Group.Member[${i}].Type.Equal[PC]}) {
			/call BCTExec ${Group.Member[${i}]} "/varset CharmPetID 0"
			}
		/varset CharmPetID 0
		/echo Reset the CharmPetID to ${CharmPetID}
	}
	/if ((${TarID.Equal[NULL]} || ${TarID.Equal[0]} || ${TarID.Length} == 0) && ${Spawn[${Target.ID}].Type.NotEqual[NPC]} && ${Spawn[${Target.ID}].Type.NotEqual[NPC]} && ${Spawn[${Target.ID}].Type.NotEqual[PET]}) {
		/echo No valid ID. Not setting CharmPetID. Keeping it as ${CharmPetID}.
		/return
	}
	
	/if ((${TarID.Equal[NULL]} || ${TarID.Equal[0]} || ${TarID.Length} == 0) && (${Spawn[${Target.ID}].Type.Equal[NPC]} || ${Spawn[${Target.ID}].Type.Equal[PET]})) /varset TarID ${Target.ID}
	/if (${Me.Pet.ID} == ${CharmPetID} && ${CharmPetID} && (${Me.Class.Name.Equal[Enchanter]} || ${Me.Class.Name.Equal[Druid]})) {
		/echo I've already got a CharmPetID of ${CharmPetID} which is my pet ${Me.Pet.ID}. It's either a charmed mob or a crappy Enc/Dru pet, but I'm keeping it.
		/return
		}
	/echo Attempting to set everyone's CharmPetID to ${TarID} which is ${Spawn[${TarID}].CleanName}
	/if (!${Turing.Equal[Box]}) {
		/for i 1 to ${Group.Members}
			/if (${Group.Member[${i}].Type.Equal[PC]}) {
			/call BCTExec ${Group.Member[${i}]} "/charmthis ${TarID} Box"
			}
		/next i
	}
	/varset CharmPetID ${TarID}
	/echo CharmPetID is set to ${CharmPetID}
/return
| -------------------------------------------------------------------------------------
| SUB: Make connect toons go into a semi circle. 
| -------------------------------------------------------------------------------------
Sub Bind_DoHalfCircle(string radius, raiderMoon)
	/echo [${Time} - StackSize = ${Macro.StackSize}] halfmoon bind called radius is ${radius}
	/declare GrpCount int local 0
	/call PlayersInGroup
	/varset GrpCount ${Macro.Return}
	/if (!${GrpCount}) {
		/echo no members in the group to order around, returning
		/return
	}
	/declare i int local 0
	/declare XOff float local 0
	/declare YOff float local 0
	/declare XMove float local 0
	/declare YMove float local 0
	/declare BaseRadians local
	/declare Multiplier local 90
	/if (${raiderMoon.Length}) /goto :raiderMoon
	/if (${GrpCount}==2) {
		/varset Multiplier 318
	} else /if (${GrpCount}==3) {
		/varset Multiplier 270
	} else /if (${GrpCount}==4) {
		/varset Multiplier 245
	} else /if (${GrpCount}==5) {
		/varset Multiplier 196
	}
	/declare MyHeading float local ${Math.Calc[${Me.Heading.Degrees} - ${Multiplier}]}
	/declare BaseRadian float local ${Math.Calc[180 / ${GrpCount}]}
	/echo I have ${GrpCount} players in my Group and my radian is ${BaseRadian}
	/for i 1 to ${Group.Members}
		/if (${Group.Member[${i}].Type.Equal[PC]}) {
			/varcalc XMove ${Math.Cos[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc YMove ${Math.Sin[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc XOff ${Me.X} + ( ${Int[${radius}]} * ${XMove} )
			/varcalc YOff ${Me.Y} + ( ${Int[${radius}]} * ${YMove} )
			/call BCTExec ${Group.Member[${i}]} "/sheepmove ${Me.ID} ${YOff} ${XOff}"
		}
	/next i
	/echo Done with Pattern: HalfMoon
	/return
	
	:raiderMoon
	/varset GrpCount ${Math.Calc[${Raid.Members}-1]}
	/varset Multiplier ${Math.Calc[.8 * ${GrpCount}]}
	/declare MyHeading float local ${Math.Calc[${Me.Heading.Degrees} - ${Multiplier}]}
	/declare BaseRadian float local ${Math.Calc[180 / ${GrpCount}]}
	/echo I have ${GrpCount} players in my Group and my radian is ${BaseRadian}
	/for i 1 to ${Raid.Members}
		/if (${Raid.Member[${i}].Type.Equal[PC]}) {
			/varcalc XMove ${Math.Cos[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc YMove ${Math.Sin[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc XOff ${Me.X} + ( ${Int[${radius}]} * ${XMove} )
			/varcalc YOff ${Me.Y} + ( ${Int[${radius}]} * ${YMove} )
			/call BCTExec ${Raid.Member[${i}]} "/sheepmove ${Me.ID} ${YOff} ${XOff}"
		}
	/next i
	/echo Done with Pattern: HalfMoon Raid
/return
| -------------------------------------------------------------------------------------
| SUB: Make connect toons go into a circle. 
| -------------------------------------------------------------------------------------
Sub Bind_DoFullCircle(string radius, raiderCircle)
	/echo [${Time} - StackSize = ${Macro.StackSize}] fullmoon bind called radius is ${radius}
	/declare GrpCount int local 0
	/call PlayersInGroup
	/varset GrpCount ${Macro.Return}
	/if (!${GrpCount}) {
		/echo no members in the group to order around, returning
		/return
	}
	/declare i int local 0
	/declare XOff float local 0
	/declare YOff float local 0
	/declare XMove float local 0
	/declare YMove float local 0
	/declare BaseRadians local
	/declare Multiplier local 90
	/if (${raiderCircle.Length}) /goto :raiderCircle
	/if (${GrpCount}==2) {
		/varset Multiplier 318
	} else /if (${GrpCount}==3) {
		/varset Multiplier 270
	} else /if (${GrpCount}==4) {
		/varset Multiplier 245
	} else /if (${GrpCount}==5) {
		/varset Multiplier 196
	}
	|/varset Multiplier 72
	/declare MyHeading float local ${Math.Calc[${Me.Heading.Degrees} - ${Multiplier}]}
	/declare BaseRadian float local ${Math.Calc[360 / ${GrpCount}]}
	/echo I have ${GrpCount} players in my Group and my radian is ${BaseRadian}
	/for i 1 to ${Group.Members}
		/if (${Group.Member[${i}].Type.Equal[PC]}) {
			/varcalc XMove ${Math.Cos[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc YMove ${Math.Sin[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc XOff ${Me.X} + ( ${Int[${radius}]} * ${XMove} )
			/varcalc YOff ${Me.Y} + ( ${Int[${radius}]} * ${YMove} )
			|/call BCTExec ${Group.Member[${i}]} "/sheepmove ${Me.ID} ${YOff} ${XOff}"
			/call BCTExec ${Group.Member[${i}]} "/nav locyxz ${YOff} ${XOff} ${Me.Z}"
		}
	/next i
	/echo Done with Pattern: FullMoon
	/return
	
	:raiderCircle
	/varset GrpCount ${Math.Calc[${Raid.Members}-1]}
	/varset Multiplier ${Math.Calc[.8 * ${GrpCount}]}
	/declare MyHeading float local ${Math.Calc[${Me.Heading.Degrees} - ${Multiplier}]}
	/declare BaseRadian float local ${Math.Calc[180 / ${GrpCount}]}
	/echo I have ${GrpCount} players in my Group and my radian is ${BaseRadian}
	/for i 1 to ${Raid.Members}
		/if (${Raid.Member[${i}].Type.Equal[PC]}) {
			/varcalc XMove ${Math.Cos[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc YMove ${Math.Sin[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc XOff ${Me.X} + ( ${Int[${radius}]} * ${XMove} )
			/varcalc YOff ${Me.Y} + ( ${Int[${radius}]} * ${YMove} )
			/call BCTExec ${Raid.Member[${i}]} "/sheepmove ${Me.ID} ${YOff} ${XOff}"
		}
	/next i
	/echo Done with Pattern: HalfMoon Raid
/return


| -------------------------------------------------------------------------------------
| SUB: Manual move to loc
| -------------------------------------------------------------------------------------
Sub Bind_SheepMove(int shepherdID, int l_YLoc, int l_XLoc)
	/echo shepherdID=${shepherdID} l_YLoc=${l_YLoc} l_XLoc=${l_XLoc}
	/if (!${shepherdID}) {
		/echo cant invoke sheepmove, not enough arguments supplied
		/return
	}
	/declare oldRTC int local 0
	/declare oldChase int local 0
	/if (${Bool[${Plugin[mq2moveutils]}]}==TRUE) {
		/varset oldRTC ${ReturnToCamp}
		/varset oldChase ${ChaseAssist}
		/if (${Bool[${Plugin[mq2advpath]}]}==TRUE && ${AdvPath.Playing}) {
			/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
			/play off
 		}
		/if (${Bool[${Plugin[mq2navigation]}]}==TRUE || ${Bool[${Plugin[mq2nav]}]}==TRUE) {
        	/if (${Navigation.Active}) {
				/echo Stopping nav \agLine#:${Macro.CurLine}
				/nav stop
			}
        }
		/call Bind_ToggleVariable ReturnToCamp off
		/call Bind_ToggleVariable ChaseAssist off
        /if (${MoveTo.Moving}) /moveto off
		/if (${Stick.Active}) /squelch /stick off
		/moveto mdist 3
		DEBUGMOVE Moveto target between 10-100"
		/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
		/moveto loc ${l_YLoc} ${l_XLoc}
		/delay 3s ${MoveTo.Moving}
		/echo woohooo, im a sheep moving and waiting up to 30s for me to stop!
		/delay 30s !${MoveTo.Moving}
		/delay 1s
		DEBUGMOVE Moveto target between 10-100"
		/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
		/moveto mdist 5
		/echo I have arrived at ${Me.X} ${Me.Y}
		/face id ${shepherdID}
		/if (${oldChase}) /call Bind_ToggleVariable ChaseAssist on
		/if (${oldRTC}) /call Bind_ToggleVariable ReturnToCamp on
	} else {
		/echo SheepMove failed because you don't have mq2moveutils loaded.
	}
/return

| -------------------------------------------------------------------------------------
| SUB: Bind AddMezImmune
| -------------------------------------------------------------------------------------
    Sub Bind_AddMezImmune(MTImmune)
		DEBUGMEZ Enter Bind AddMezImmune with ${MTImmune}"
        /if (!${MTImmune.Length} || ${MTImmune.Find[null]} || ${Spawn[${MTImmune}].ID}==${Me.ID}) {
            /echo No name sent in. Going to add my current target to MezImmune list...
			/if (!${Target.ID}) {
				/echo No NPCs detected. Nothing added to list.
				/return
			}
			/varset MTImmune ${Target.ID}
        }
        | Assign temp var MezImmune list
        /declare MezImmuneAdd string local ${MezImmune}
        | If MezImmune default text with the word null in it assign var spawn clean name
        /if (${MezImmuneAdd.Find[null]} && ${MezImmune.Find[null]}) {
            /varset MezImmuneAdd ${Spawn[${MTImmune}].CleanName}
        } else {
            /varset MezImmuneAdd ${MezImmune},${Spawn[${MTImmune}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${MezImmuneAdd.Right[-10].Find[corpse]}) /varset MezImmuneAdd ${MezImmuneAdd.Right[-8]}
        /if (${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /echo >> ${Spawn[${MTImmune}].CleanName} << already on Mez Immune List.
            /return
        }
        /if (${Spawn[${MTImmune}].CleanName.Equal[null]}) {
            /echo No Mob with ${MTImmune} in Name detected.
            /return
        }
        /if (!${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MezImmune" "${MezImmuneAdd}"
            /echo MezImmune -> ${Spawn[${MTImmune}].CleanName} <- Adding to Mez Immune  list.
        }
        | Reassign MezImmune var the new list
        /varset MezImmune ${MezImmuneAdd}
		DEBUGMEZ Exit Bind AddMezImmune added ${MezImmuneAdd}"
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind AddToIgnore
| -------------------------------------------------------------------------------------
    Sub Bind_AddToIgnore(MTIgnore)
        | Take the targeted mob as a parameter for mob to ignore.
        /if (!${MTIgnore.Length}) /varset MTIgnore ${Target.ID}
        /if (${MTIgnore.Equal[null]} || !${Spawn[${MTIgnore}].Type.Equal[NPC]} || ${Spawn[${MTIgnore}].CleanName.Equal[null]}) {
            /echo No NPCs named (${MTIgnore}) detected. Nothing added to list.
            /return
        }
        | Assign temp var   list
        /declare IgnoreAdd string local ${MobsToIgnore}
        | If MobsToIgnore default text with the word null in it assign var spawn clean name
        /if (${IgnoreAdd.Find[null]}) {
            /varset IgnoreAdd ${Spawn[${MTIgnore}].CleanName}
        } else {
            /varset IgnoreAdd ${IgnoreAdd},${Spawn[${MTIgnore}].CleanName}
        }  
        | Remove's corpse if closest match is a mob corpse
        /if (${IgnoreAdd.Right[-10].Find[corpse]}) /varset IgnoreAdd ${IgnoreAdd.Right[-8]}
        /if (${MobsToIgnore.Find[${Spawn[${MTIgnore}].CleanName}]}) {
            /echo >> ${Spawn[${MTIgnore}].CleanName} << already on Ignore List.
            /return
        }
        /ini "${InfoFileName}" "${ZoneName}" "MobsToIgnore" "${IgnoreAdd}"
		/echo AddToIgnore -> ${Spawn[${MTIgnore}].CleanName} <- Adding to Ignore list.
        | Reassign MobsToIgnore var the new list
        /varset MobsToIgnore ${IgnoreAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddToPull
| -------------------------------------------------------------------------------------
    Sub Bind_AddToPull(MTPull)
        /if (!${MTPull.Length} || ${MTPull.Find[null]} || ${Spawn[${MTPull}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MobsToPull list
        /declare PullAdd string local ${MobsToPull}
        | If MobsToPull default text with the word null in it assign var spawn clean name
        /if (${PullAdd.Find[all]}) {
            /varset PullAdd ${Spawn[${MTPull}].CleanName}
        } else {
            /varset PullAdd ${PullAdd},${Spawn[${MTPull}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${PullAdd.Right[-10].Find[corpse]}) /varset PullAdd ${PullAdd.Right[-8]}
        /if (${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /echo >> ${Spawn[${MTPull}].CleanName} << already on Pull List.
            /return
        }
        /if (${Spawn[${MTPull}].CleanName.Equal[null]}) {
            /echo ERROR: No Mob with ${MTPull} in Name detected.
            /return
        }
        /if (!${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MobsToPull" "${PullAdd}"
            /echo AddToPull-> ${Spawn[${MTPull}].CleanName} <- Adding to Pull list.
        }
        | Reassign MobsToPull var the new list
        /varset MobsToPull ${PullAdd}
    /return
| ----------------------------------------------------------------------------
| SUB: Add a friend to mq2posse list
| ----------------------------------------------------------------------------
    Sub Bind_AddAFriend
        /declare AFriend string local ${Target.CleanName}
        /if (!${Target.ID} || ${Spawn[${Target.ID}].Type.NotEqual[pc]} || ${Target.ID}==${Me.ID}) {
            /echo --ADDFRIEND: Target a PC to add your Posse list.
            /return
        }
        /docommand /posse add ${AFriend}
        /docommand /posse save
        /docommand /posse load
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind_ToggleVariable  Check whenever the player is changing any variable via /echo
| -------------------------------------------------------------------------------------
Sub Bind_ToggleVariable(string Command, string Command2, string Command3)
	/echo ${Time} ${Command} ${Command2} ${Command3}
    /declare i int local 0
    /declare OnOff local
    | Toggle Variables & Set Variables
    /if (${Command2.Length}) {
        /if (${Select[${Command2},0,off]}) {
            /varset ${Command} 0
            /varset OnOff Off
        } else /if (${Select[${Command2},1,on]}) {
            /varset ${Command} 1
            /varset OnOff On
        } 
    } else /if (${${Command}}) {
        /varset ${Command} 0
        /varset OnOff Off
		/if (${Command.Equal[MeleeOn]}) /assist off
        /if (!${ChaseAssist} && ${Stick.Active})  /squelch /stick off
		|Lemons: Need to stop if using AdvPath to follow
		/if (!${ChaseAssist} && ${AdvPath.Following}) /afollow off
    } else {
        /varset ${Command} 1
        /varset OnOff On
		/if (${Command.Equal[MeleeOn]}) /assist on
    }
	/if (${Command.Find[Debug]}) {
        /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
            /echo You are using a Custom UI. Please switch to Default UI before Posting.
        }
    }
    /echo >> Setting: (${Command}) to (${If[${Select[${OnOff},on,1]}>0,On,Off]})
    /if (((${Command2.Length} && ${Spawn[=${Command2}].ID}) || (${Command3.Length} && ${Spawn[=${Command3}].ID})) && ${Command.Equal[ChaseAssist]})  {
		/echo setting ChaseName to ${Command2}
		/varset ReturnToCamp 0
		/varset ChaseAssist 1
		/if (${Select[${Command2},MA,Mainassist]}) {
			/varset ChaseName ${MainAssist}
		} else /if (${Spawn[=${Command2}].ID}) {
			/varset ChaseName ${Command2}
		} else {
			/varset ChaseName ${Command3}
		}
	}
	/if (${Command.Equal[ChaseAssist]} && ${OnOff.Equal[on]} ) {
        /if (${ReturnToCamp}) /varset ReturnToCamp 0
        |Lemons: Need to stop if using AdvPath to follow
		/if (${AdvPath.Following}) /afollow off
    } else /if (${Command.Equal[ReturnToCamp]} && ${OnOff.Equal[on]}) {
        /varset CampXLoc ${Me.X}
        /varset CampYLoc ${Me.Y}
        /varset CampZLoc ${Me.FloorZ}
        /varset LookForward ${Me.Heading.DegreesCCW}
        | Turn off ChaseAssit if on
        /if (${ChaseAssist}) {
            /varset ChaseAssist 0
            /if (${Stick.Active}) /squelch /stick off
            |Lemons: Need to stop if using AdvPath to follow
			/if (${AdvPath.Following}) /afollow off
            /echo >> ChaseAssist Off
        }
        /echo >> New camp set ${CampYLoc}, ${CampXLoc}
    } else /if (${Command.Equal[conditions]}) {
        /if (${Command2.Equal[all]}) {
            /if (${Select[${Command3},1,on]}) {
                /varset ConditionsOn 2
                /varset GoMCOn 1
                /varset DPSCOn 1
                /varset HealsCOn 1
                /varset BurnCOn 1
                /varset BuffsCOn 1
            } else {
                /varset ConditionsOn 2
                /varset GoMCOn 0
                /varset DPSCOn 0
                /varset HealsCOn 0
                /varset BurnCOn 0
                /varset BuffsCOn 0
            }
            /echo >> Setting: (${Command}) ${Command2} to (${If[${Select[${Command3},on,1]}>0,On,Off]})
        } else /if (${Select[${Command2},on,off,1,0]}>0) {
            /if (${Select[${Command2},1,on]}) {
                /varset ConditionsOn 2
            } else {
                /varset ConditionsOn 2
            }
            |/echo >> Setting: (ConditionsOn) to (${If[${ConditionsOn},On,Off]})
        } else {
            /if (${Select[${Command3},1,on]}) {
                /varset OnOff 1
            } else {
                /varset OnOff 0
            }
            /if (${Command2.Equal[gom]}) {
                /varset GoMCOn ${OnOff}
            } else /if (${Command2.Equal[dps]}) {
                /varset DPSCOn ${OnOff}
            } else /if (${Command2.Equal[heals]}) {
                /varset HealsCOn ${OnOff}
            } else /if (${Command2.Equal[burn]}) {
                /varset BurnCOn ${OnOff}
            } else /if (${Command2.Equal[buffs]}) {
                /varset BuffsCOn ${OnOff}
            } 
            /echo >> Setting: (${Command}) ${Command2} to (${OnOff})
        }
	}
/return	
| ----------------------------------------------------------------------------
| SUB: Pull Once
| ----------------------------------------------------------------------------
Sub Bind_Pull
	/echo [${Time}] Time for a onetime pull!
	/varset PullOnce 1
/return
| ----------------------------------------------------------------------------
| SUB: Manual hide command
| ----------------------------------------------------------------------------
Sub Bind_MuleHide(int id)
	/if (${Me.Skill[Hide]}) {
		/echo MuleHide bind called. \agLine#:${Macro.CurLine}
		/varset DoMuleHideID ${id}
	} else {
		/if (${Group}) {
			/call BCTell ${Group.Leader.Name} "I do not have the Hide skill."
		}
		/echo I do not have the Hide skill.
	}
/return
| ----------------------------------------------------------------------------
| SUB: IniWrite - quick ini entry for spells,  aas, discs, items
| ----------------------------------------------------------------------------
    Sub Bind_IniWrite(IWSection, IWE1, IWE2, IWE3, IWE4, IWE5, IWE6)
    DEBUGN Bind_IniWrite: Enter ${iwMessage} \agLine#:${Macro.CurLine}"
    /declare keyNum int local 0
    /declare IWPercent int local 100
    /declare IWSlot int local 1
    /declare IWType string local ${IWE1}
    /declare IWTypeSingle string local
    /declare IWArray int local ${${IWSection}.Size}
    /declare IWEmptySlot string local 0
    /declare IWEntry string local
    /declare i int local 0
    /declare j int local
    /declare k int local
    | Determine if single type 
    /if (${Select[${IWType},aa,disc,item,spell,clear]}) {
        | Set Item
        /if (${IWType.Equal[item]}) {
            /if (!${Cursor.ID}) {
                /echo ..SET${IWSection}: You need to put the item on your cursor.
                /return
            }
            /varset IWTypeSingle ${Cursor.Name}
            /echo ${IWTypeSingle}
        }
        | Set Spell
        /if (${IWType.Equal[spell]}) {
            /if (!${Me.Gem[${IWE2}].Name.Length}) {
                /echo ..SET${IWSection}: You need to mem a spell
                /return
            }
            /varset IWTypeSingle ${Me.Gem[${IWE2}].Name}
         }
        | Set AA
        /if (${IWType.Equal[aa]}) {
            /if (!${Me.AltAbility[${IWE2}]}) {
                /echo ..SET${IWSection}: You don't have that AA
                /return
            }
            /varset IWTypeSingle ${Me.AltAbility[${IWE2}].Name}
        }
        | Set Disc/Combat Ability
        /if (${IWType.Equal[disc]}) {
            /if (!${Select[${IWE2},1,2,3,4,5,6,7,8]}) {
                /echo ..SET${IWSection}: Disc # must be a Combat Abilty Button 1-8 
                /return
            }
            /if (!${Me.CombatAbility[${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}]}) {
                /echo ..SET${IWSection}: You don't have that Disc or Combat Ability button ${IWE2} is empty.
                /return
            }
            /varset IWTypeSingle ${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}
        }
        | Final Catchall for error control
        /if (!${IWTypeSingle.Length}) {
            /echo ..SET${IWSection}: ${IWType} parameter is blank. Please provide a ${IWType}
            /return
        }
        | Find empty slot & check if entry exists
        /echo ..SET${IWSection}: Looking of for spot to write ${IWTypeSingle}
        /for k 1 to ${IWArray}
            /varset IWEntry ${Ini[${IniFileName},${IWSection},${IWSection}${k}]}
            /if (${IWSection.Equal[DPS]}) /varset IWPercent 90
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            DEBUGN ${${IWSection}[${k}].Length} \agLine#:${Macro.CurLine}"
            /if (${IWEntry.Find[${IWTypeSingle}]}) {
                /echo ..SET${IWSection}: Duplicate entry ${IWSection}${k}=${IWTypeSingle} skipping.
                /return
            }
            /if (${IWEntry.Equal[null]} && ${IWEmptySlot}==0) {
                /varset IWEmptySlot ${k}
            }
            /if (${k}==${IWArray} && !${IWEmptySlot}) /varset IWEmptySlot ${k}
        /next k
        /if (${IWEmptySlot}==${IWArray}) {
            /echo ..SET${IWSection}: No empty slots in ${IWSection} to write
            /return
        }
        /if (${Select[${IWSection},DPS,Heals]}) {
            /ini ${IniFileName} "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}|${IWPercent}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}|${IWPercent}
        } else {
            /ini ${IniFileName} "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}
        }
        /return
    }    
    /echo ..SET${IWSection}: This command will write over current ${IWSection} settings 
    /for i 1 to ${IWArray}
        /varset keyNum ${i}
        /if (${Me.Gem[${IWE${i}}].Name.Length} && ${i}<7) {
            /if (${IWSection.Equal[DPS]}) /varcalc IWPercent ${IWPercent}-5
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            /if (${Select[${IWSection},DPS,Heals]}) {
                /ini ${IniFileName} "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}|${IWPercent}"
                /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}|${IWPercent}
            }
            /if (${Select[${IWSection},Buffs]}) {
                /ini ${IniFileName} "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}"
                /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}
            }
            /varcalc IWSlot ${IWSlot}+1
            /delay 1
        }
    /next i
    /return

	Sub Bind_MassPull(string pull_spell, int num_mobs, int min_level, int max_level, int max_dist)
		|/echo Bind_MassPull called: "${pull_spell}" ${num_mobs} ${min_level} ${max_level} ${max_dist} \agLine#:${Macro.CurLine}
		/varset DoMassPullString "${pull_spell}" ${num_mobs} ${min_level} ${max_level} ${max_dist}
	/return
	Sub DoMassPull(string pull_spell, int num_mobs, int min_level, int max_level, int max_dist)
		/varset DoMassPullString NULL
		/declare i int local 1
		/declare mobcount int local
		/declare curmob spawn local
		/varset mobcount ${SpawnCount[range ${min_level} ${max_level} radius ${max_dist} targetable npc]}
		/if (${mobcount}==0) /return
		/echo ${mobcount} mobs here we can pull
		/for i 1 to ${num_mobs}
			/if (${NearestSpawn[${i},range ${min_level} ${max_level} radius ${max_dist} targetable npc].ID}) {
				/vardata curmob NearestSpawn[${i},range ${min_level} ${max_level} radius ${max_dist} targetable npc]
				/echo [${i}] ${curmob} ${curmob.Level} ${curmob.Distance3D}ft away \agLine#:${Macro.CurLine}
				/nav spawn id ${curmob.ID} | dist=40
				/delay 5 ${Navigation.Active}==TRUE
				/delay 40s ${Navigation.Active}==FALSE
				/delay 5 ${Me.Moving}
				/delay 5
				/target id ${curmob.ID}
				/delay 1s ${Target.ID}==${curmob.ID}
				/call CastWhat "${pull_spell}" ${Target.ID} "Pull"
				/delay 1s ${Me.XTarget[${curmob.CleanName}].ID}
			}
		/next i
		:waitforpulledmobs
		/if (${MuleDebug}) /echo  nav \agLine#:${Macro.CurLine}
		/nav locxy ${CampXLoc} ${CampYLoc}
		/delay 5 ${Navigation.Active}==TRUE
		/for i 1 to ${Me.XTarget}
			/if (${Me.XTarget[${i}].Type.Equal[NPC]}) {
				/if (${Me.XTarget[${i}].Distance3D} > 180) {
					/tar id ${Me.XTarget[${i}].ID}
					/delay 1s ${Target.ID}==${Me.XTarget[${i}].ID}
					/delay 1s ${Target.BuffsPopulated}==TRUE
					/delay 1s ${Target.CachedBuffCount}!=-1
					/if (!${Target.Rooted.ID}) {
						/echo ${Me.XTarget[${i}]} is lagging behind, waiting for it to catch up \agLine#:${Macro.CurLine}
						/nav stop
						/delay 5s ${Me.XTarget[${i}].Distance3D} < 100
						/goto :waitforpulledmobs
					}
				}
			}
		/next i
		/if (${Navigation.Active}) {
			/if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) {
				/delay 1s
				/goto :waitforpulledmobs
			}
		}
		/echo back at camp after masspull \agLine#:${Macro.CurLine}
	/return
|-----------------------------------------------------------------------------
| SUB: Campfire back to camp
| ----------------------------------------------------------------------------
    Sub CampfireBack
		/if (${BuffMode}) {
			/if (${MuleDebug}) /echo BuffMode is on\agLine#:${Macro.CurLine}
			/return
		}	
        /if (!${ClickBacktoCamp}) /return
        /if (${CampfireClickTimer}) /return
        /if (${Me.Hovering}) /return
        /varset CampfireClickTimer 1m
        | Am I Dead?
        /if (${Me.Buff[Revival Sickness].ID} && ${CampZone} != ${Zone.ID}) /varset IAmDead 1
        /if (${IAmDead}) {
            | Does Campfire Exist?
            /if (!${Me.Fellowship.CampfireZone.ID}) {
                /echo There is no campfire up.
                /return
            }
            | Am I & the campfire in the same zone?
            /if (${Me.Fellowship.CampfireZone.ID}==${Zone.ID}) {
                /echo I'm back in the same zone as my campfire. 
                /varset IAmDead 0
                /return
            }
            /if (${FindItem[Fellowship Registration Insignia].TimerReady} == 0) {
                /echo Time to get back to work. Clicking Fellowship Insignia in 30 seconds.
                | Delay for rest state to kick in
                /delay 30s
                /squelch /nomodkey /itemnotify "Fellowship Registration Insignia" rightmouseup
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Debug All
| ----------------------------------------------------------------------------
    Sub Bind_DebugAll
        /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
            /echo You are using a Custom UI. Please switch to Default UI before Posting.
        }
        /if (!${DebugAllOn}) {
            /varset DebugAllOn 1
            /echo \atDEBUG ALL On
        } else {
            /varset DebugAllOn 0
            /echo \atDEBUG ALL Off
        }
        /varset Debug ${DebugAllOn}
        /varset DebugBuffs ${DebugAllOn}
        /varset DebugCombat ${DebugAllOn}
        /varset DebugHeal ${DebugAllOn}
        /varset DebugMez ${DebugAllOn}
        /varset DebugMove ${DebugAllOn}
        /varset DebugPet  ${DebugAllOn}
        /varset DebugPull ${DebugAllOn}
    /return

|-----------------------------------------------------------------------------
| SUB: Bind scribestuff. Mostly stolen from scribe.mac cause I'm lazy
| ----------------------------------------------------------------------------
    Sub Bind_ScribeStuff
		/call Broadcast o "Going to check my inventory for things to scribe"
		/if (!${Me.HaveExpansion[Call of the Forsaken]} && !${Select[${MacroQuest.Server},rizlona]}) {
			|Probably on an Emu on ROF2 or less
			/if (!${Select[${Me.Class.ShortName},WAR,BER,MNK,ROG]}) /call ScribeSpellsEmu			
			/if (!${Select[${Me.Class.ShortName},CLR,DRU,SHM,ENC,WIZ,MAG,NEC]}) /call ScribeTomesEmu
			/if (${Window[InventoryWindow].Open}) /keypress inventory
			/return
		}
		/if (!${Select[${Me.Class.ShortName},CLR,DRU,SHM,ENC,WIZ,MAG,NEC]}) /call ScribeTomes
		/if (!${Select[${Me.Class.ShortName},WAR,BER,MNK,ROG]}) /call ScribeSpells
		/if (${Window[InventoryWindow].Open}) /keypress inventory
	/return
|---------------------------------	
	Sub ScribeSpellsEmu
|---------------------------------	
		/declare i int local
		/declare z int local
		/declare Bag int local
		/declare Slot int local
		/declare tOut timer local 25s
		/declare lagClick timer local 2s
		/declare EmptySpellSlot int local
		/declare pageNumber int local 0
		|/echo ScribeSpellEmu
		/if (${Cursor.ID}) /autoinv
		|** Opening your inventory for access bag slots **|
		/if (!${Window[InventoryWindow].Open}) {
			/windowstate InventoryWindow open
		}
		/if (!${Window[SpellBookWnd].Open} && ${Me.MaxMana}) {
			/windowstate SpellBookWnd open
			/delay 10s ${Window[SpellBookWnd].Open}
			/delay 1s
			/for i 1 to 44
				/invoke ${Window[SpellBookWnd].Child[SBW_PageDown_Button].LeftMouseUp}
			/next i
		}		
		|** Open all bags **|
		/keypress OPEN_INV_BAGS
		:emuSSlot
		|Find the next open slot in your spellbook
		/for i 1 to 720
			/if (${Me.Book[${i}].Name.Length}) {
				|/echo (${Math.Calc[${i} % 16]} == 1 && ${i} > 16)
				/if (${Math.Calc[${i} % 16]} == 1 && ${i} > 16) {
					/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
					/varcalc pageNumber ${pageNumber}+1
					/echo Pgup1
					}
				/continue
			}
			/if (${Math.Calc[${i} % 16]} == 1 && ${i} > 16) {
				/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
				/varcalc pageNumber ${pageNumber}+1
				/echo Pgup1
			}
			/varset EmptySpellSlot ${If[${i} <= 16,${Math.Calc[${i}-1]},${If[${Math.Calc[${i} % 16]} == 0,15,${Math.Calc[${i} % 16-1].Int}]}]}
			/echo Empty slot is ${EmptySpellSlot} on ${i}e
			/break
		/next i	
		|** Check Top Level Inventory Slot for bag/no bag **|
		/for Bag 1 to 10
			:emuFullPageBag
			/echo Empty Slot is ${EmptySpellSlot} bag ${Bag}
			/if (${EmptySpellSlot} == 16) {
				/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
				/varcalc pageNumber ${pageNumber}+1
				/echo Pgup3
				/varset EmptySpellSlot 0
				/delay 1s !${Me.Book[${EmptySpellSlot}].Name.Length}						
			}
			/if (${Me.Book[${Math.Calc[(${EmptySpellSlot}+1)+(${pageNumber}*16)]}].Name.Length}) {
				/for i 1 to 720
					/if (${Me.Book[${i}].Name.Length}) {
						/continue
					}
					/varset EmptySpellSlot ${If[${i} <= 16,${Math.Calc[${i}-1]},${If[${Math.Calc[${i} % 16]} == 0,15,${Math.Calc[${i} % 16-1].Int}]}]}
					/echo Empty slot is ${EmptySpellSlot} on ${i}f
					/break
				/next i	
				/if (${EmptySpellSlot} == 16) /goto :emuFullPageBag
			}
			|** If it's a bag do this **|
			/if (${InvSlot[pack${Bag}].Item.Container}) {
				/if (!${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
				/delay 1s ${Window[Pack${Bag}].Open}
				/delay 5
				/for Slot 1 to ${InvSlot[pack${Bag}].Item.Container}
					:emuFullPageSlot
					/for z 1 to 16
						/if (!${Me.Book[${Math.Calc[${z}+(${pageNumber}*16)]}].Name.Length}) {
							/varset EmptySpellSlot ${Math.Calc[${z}-1]}
							/echo EmptySpellSlot set to ${EmptySpellSlot} in page check1
							/break
						}
						/if (${z} ==  16) {
							/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
							/varcalc pageNumber ${pageNumber}+1
							/echo Pgup4
							/varset EmptySpellSlot 0
							/delay 1s !${Me.Book[${EmptySpellSlot}].Name.Length}
						}
					/next z
					/if (${EmptySpellSlot} == 16) {
						/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
						/varcalc pageNumber ${pageNumber}+1
						/echo Pgup4
						/varset EmptySpellSlot 0
						/delay 1s !${Me.Book[${EmptySpellSlot}].Name.Length}						
					}
					/if (${Me.Book[${Math.Calc[(${EmptySpellSlot}+1)+(${pageNumber}*16)]}].Name.Length}) {
					/for i 1 to 720
						/if (${Me.Book[${i}].Name.Length}) {
							/continue
						}
						/varset EmptySpellSlot ${If[${i} <= 16,${Math.Calc[${i}-1]},${If[${Math.Calc[${i} % 16]} == 0,15,${Math.Calc[${i} % 16-1].Int}]}]}
						/echo Empty slot is ${EmptySpellSlot} on ${i}s
						/break
					/next i	
					}
					/if (${EmptySpellSlot} == 16) /goto :emuFullPageSlot
					/if (${InvSlot[pack${Bag}].Item.Item[${Slot}].Type.Equal[Scroll]} && ${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Level} <= ${Me.Level} && !${Me.Book[${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Name}]}) {
						/call Broadcast g "Emu Scribing: ${InvSlot[pack${Bag}].Item.Item[${Slot}]}"
						/echo EmptySpellSlot is ${EmptySpellSlot} 1
						/nomodkey /ctrlkey /itemnotify in pack${Bag} ${Slot} leftmouseup
						/delay 1s ${Cursor.ID}
						/varset tOut ${tOut.OriginalValue}
						/if (${Cursor.ID}) {
							/invoke ${Window[SpellBookWnd].Child[SBW_Spell${EmptySpellSlot}].LeftMouseUp}
							/delay 2						
							:WaitFinished
							/if (${Window[ConfirmationDialogBox].Open} && ${Window[ConfirmationDialogBox].Child[CD_TextOutput].Text.Find[${Cursor.Spell.Name} will replace]}) /notify ConfirmationDialogBox Yes_Button leftmouseup
							/if (!${lagClick}) {
								/if (${EmptySpellSlot} == 16) {
									/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
									/varcalc pageNumber ${pageNumber}+1
									/echo Pguplag1
									/varset EmptySpellSlot 0
									/delay 1s !${Me.Book[${EmptySpellSlot}].Name.Length}						
								}
								/if (${Me.Book[${Math.Calc[(${EmptySpellSlot}+1)+(${pageNumber}*16)]}].Name.Length}) {
									/for i 1 to 720
										/if (${Me.Book[${i}].Name.Length}) {
											/continue
										}
										/varset EmptySpellSlot ${If[${i} <= 16,${Math.Calc[${i}-1]},${If[${Math.Calc[${i} % 16]} == 0,15,${Math.Calc[${i} % 16-1].Int}]}]}
										/echo Empty slot is ${EmptySpellSlot} on ${i} x
										/break
									/next i	
								}
								/invoke ${Window[SpellBookWnd].Child[SBW_Spell${EmptySpellSlot}].LeftMouseUp}
								/varset lagClick ${lagClick.OriginalValue}
							}
							/if (!${tOut}) {
								/autoinv
							}
							/delay 2
							/doevents FullInventory
							/doevents NotGold
							/doevents WrongDiety
							/if (${Cursor.ID}) /goto :WaitFinished
							/varcalc EmptySpellSlot ${EmptySpellSlot}+1
						}
					}
				/next Slot
				|** Close the bag I just checked **|
				/if (${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
			} else {
				|** If it's not a bag, do this **|
				| Debug message /echo TopLevel Inv Slot ~ IsAScroll: ${InvSlot[pack${Bag}].Item.Type.Equal[Scroll]} && Item Spell level: ${InvSlot[pack${Bag}].Item.Spell.Level} <= My Level: ${Me.Level} && Scribed Already: !${Me.Book[${InvSlot[pack${Bag}].Item.Spell.Name}]}
				/if (${InvSlot[pack${Bag}].Item.Type.Equal[Scroll]} && ${InvSlot[pack${Bag}].Item.Spell.Level} <= ${Me.Level} && !${Me.Book[${InvSlot[pack${Bag}].Item.Spell.Name}]}) {
					/call Broadcast g "Emu2 Scribing: ${InvSlot[Pack${Bag}].Item.Name}"
					/echo EmptySpellSlot is ${EmptySpellSlot}2
					/nomodkey /ctrlkey /itemnotify "${FindItem[${InvSlot[Pack${Bag}].Item.Name}].Name}" leftmouseup
					/delay 1s ${Cursor.ID}
					/varset tOut ${tOut.OriginalValue}
					/if (${Cursor.ID}) {
						/delay 2
						/invoke ${Window[SpellBookWnd].Child[SBW_Spell${EmptySpellSlot}].LeftMouseUp}
						:WaitFinished
						/if (${Window[ConfirmationDialogBox].Open} && ${Window[ConfirmationDialogBox].Child[CD_TextOutput].Text.Find[${Cursor.Spell.Name} will replace]}) /notify ConfirmationDialogBox Yes_Button leftmouseup
						/if (!${tOut}) /autoinv
						/if (!${lagClick}) {
							/if (${EmptySpellSlot} == 16) {
									/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
									/varcalc pageNumber ${pageNumber}+1
									/echo Pguplag2
									/varset EmptySpellSlot 0
									/delay 1s !${Me.Book[${EmptySpellSlot}].Name.Length}						
								}
							/if (${Me.Book[${Math.Calc[(${EmptySpellSlot}+1)+(${pageNumber}*16)]}].Name.Length}) {
									/for i 1 to 720
										/if (${Me.Book[${i}].Name.Length}) {
											/continue
										}
										/varset EmptySpellSlot ${If[${i} <= 16,${Math.Calc[${i}-1]},${If[${Math.Calc[${i} % 16]} == 0,15,${Math.Calc[${i} % 16-1].Int}]}]}
										/echo Empty slot is ${EmptySpellSlot} on ${i}
										/break
									/next i	
								}
							/invoke ${Window[SpellBookWnd].Child[SBW_Spell${EmptySpellSlot}].LeftMouseUp}
							/varset lagClick ${lagClick.OriginalValue}
						}
						/delay 2
						/doevents FullInventory
						/doevents NotGold
						/doevents WrongDiety
						/if (${Cursor.ID}) /goto :WaitFinished
						/varcalc EmptySpellSlot ${EmptySpellSlot}+1
						/if (${EmptySpellSlot} == 16) {
							/invoke ${Window[SpellBookWnd].Child[SBW_PageUp_Button].LeftMouseUp}
							/varcalc pageNumber ${pageNumber}+1
							/echo Pgup5
							/varset EmptySpellSlot 0
							/delay 1s !${Me.Book[${Math.Calc[(${EmptySpellSlot}+1)+(${pageNumber}*16)]}].Name.Length}						
						}
					}
				}
			}
		/next Bag
		/if (${Window[SpellBookWnd].Open}) /squelch /windowstate SpellBookWnd close
	/return
| ----------------------------------------------------------------------------
	Sub ScribeTomesEmu
| ----------------------------------------------------------------------------	
		/declare Bag int local
		/declare Slot int local
		/declare HasVoA int local 1
		|/echo ScribeTomeEmu
		/if (${Cursor.ID}) /autoinv
		/keypress OPEN_INV_BAGS
		/delay 5
		/for Bag 1 to 10
			/if (${InvSlot[pack${Bag}].Item.Container}) {
				/if (!${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
				/delay 1s ${Window[Pack${Bag}].Open}
				/for Slot 1 to ${InvSlot[pack${Bag}].Item.Container}
					/if ((${InvSlot[pack${Bag}].Item.Item[${Slot}].Name.Find[Tome]} || ${InvSlot[pack${Bag}].Item.Item[${Slot}].Type.Equal[Scroll]}) && ${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Level} <= ${Me.Level} && !${Me.Book[${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Name}]}) {
						/if (${Me.CombatAbility[${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell}]}) /continue
						/call Broadcast g "Emu Scribing: ${InvSlot[pack${Bag}].Item.Item[${Slot}].Name}"
						/if (${HasVoA}) {
							/nomodkey /ctrlkey /itemnotify in pack${Bag} ${Slot} rightmouseup
							/delay 1s !${InvSlot[pack${Bag}].Item.Item[${Slot}].ID}
						} else {
							/nomodkey /ctrlkey /itemnotify in pack${Bag} ${Slot} leftmouseup
							/delay 1s ${Cursor.ID}
							/nomodkey /ctrlkey /itemnotify ${InvSlot[pack1]} leftmouseup
							/delay 1s !${Cursor.ID}
							/nomodkey /ctrlkey /itemnotify ${InvSlot[pack1]} rightmouseup
							/delay 1s !${InvSlot[pack1].ID}
						}
					}
				/next Slot

		} else {
			/if ((${InvSlot[pack${Bag}].Item.Type.Equal[Tome]} || ${InvSlot[pack${Bag}].Item.Type.Equal[Scroll]}) && ${InvSlot[pack${Bag}].Item.Spell.Level} <= ${Me.Level} && !${Me.Book[${InvSlot[pack${Bag}].Item.Spell.Name}]}) {
					/if (${Me.CombatAbility[${InvSlot[Pack${Bag}].Item.Spell}]}) /continue
					/call Broadcast g "Emu2 Scribing: ${InvSlot[Pack${Bag}].Item.Name}"
					/nomodkey /ctrlkey /itemnotify pack${Bag} rightmouseup
					/delay 1s !${InvSlot[pack${Bag}].Item.ID}
					/if (${Cursor.ID}) {
						:WaitFinished
						/if (${Window[ConfirmationDialogBox].Open} && ${Window[ConfirmationDialogBox].Child[CD_TextOutput].Text.Find[${Cursor.Spell.Name} will replace]}) /notify ConfirmationDialogBox Yes_Button leftmouseup
						/delay 2
						/doevents FullInventory
						/doevents NotGold
						/doevents WrongDiety
						/if (${Cursor.ID}) /goto :WaitFinished
					}
				}
		}
			/if (${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
		/next Bag
		/if (${Cursor.ID}) /autoinv
	/return	
|---------------------------------	
	Sub ScribeSpells
|---------------------------------	
		/declare Bag int local
		/declare Slot int local
		/declare tOut timer local 25s
		/if (${Cursor.ID}) /autoinv
		|** Opening your inventory for access bag slots **|
		/if (!${Window[InventoryWindow].Open}) {
			/windowstate InventoryWindow open
		}
		|** Open all bags **|
		/keypress OPEN_INV_BAGS

		
		|** Check Top Level Inventory Slot for bag/no bag **|
		/for Bag 1 to 10
			|** If it's a bag do this **|
			/if (${InvSlot[pack${Bag}].Item.Container}) {
				/if (!${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
				/delay 1s ${Window[Pack${Bag}].Open}
				/delay 5

				/for Slot 1 to ${InvSlot[pack${Bag}].Item.Container}
					/if (${InvSlot[pack${Bag}].Item.Item[${Slot}].Type.Equal[Scroll]} && ${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Level} <= ${Me.Level} && !${Me.Book[${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Name}]}) {
						/call Broadcast g "Scribing: ${InvSlot[pack${Bag}].Item.Item[${Slot}]}"
						/nomodkey /ctrlkey /itemnotify in pack${Bag} ${Slot} rightmouseup
						/delay 1s ${Cursor.ID}
						/varset tOut ${tOut.OriginalValue}
						/if (${Cursor.ID}) {
							:WaitFinished
							/if (${Window[ConfirmationDialogBox].Open} && ${Window[ConfirmationDialogBox].Child[CD_TextOutput].Text.Find[${Cursor.Spell.Name} will replace]}) /notify ConfirmationDialogBox Yes_Button leftmouseup
							/if (!${tOut}) /autoinv
							/delay 2
							/doevents FullInventory
							/doevents NotGold
							/doevents WrongDiety
							/if (${Cursor.ID}) /goto :WaitFinished
						}
					}
				/next Slot
				|** Close the bag I just checked **|
				/if (${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
			} else {
				|** If it's not a bag, do this **|
				| Debug message /echo TopLevel Inv Slot ~ IsAScroll: ${InvSlot[pack${Bag}].Item.Type.Equal[Scroll]} && Item Spell level: ${InvSlot[pack${Bag}].Item.Spell.Level} <= My Level: ${Me.Level} && Scribed Already: !${Me.Book[${InvSlot[pack${Bag}].Item.Spell.Name}]}
				/if (${InvSlot[pack${Bag}].Item.Type.Equal[Scroll]} && ${InvSlot[pack${Bag}].Item.Spell.Level} <= ${Me.Level} && !${Me.Book[${InvSlot[pack${Bag}].Item.Spell.Name}]}) {
					/call Broadcast g "Scribing: ${InvSlot[Pack${Bag}].Item.Name}"
					/nomodkey /ctrlkey /itemnotify pack${Bag} rightmouseup
					/delay 1s ${Cursor.ID}
					/varset tOut ${tOut.OriginalValue}
					/if (${Cursor.ID}) {
							:WaitFinished
							/if (${Window[ConfirmationDialogBox].Open} && ${Window[ConfirmationDialogBox].Child[CD_TextOutput].Text.Find[${Cursor.Spell.Name} will replace]}) /notify ConfirmationDialogBox Yes_Button leftmouseup
							/if (!${tOut}) /autoinv
							/delay 2
							/doevents FullInventory
							/doevents NotGold
							/doevents WrongDiety
							/if (${Cursor.ID}) /goto :WaitFinished
						}
				}
			}
		/next Bag
		/if (${Window[SpellBookWnd].Open}) /squelch /windowstate SpellBookWnd close
	/return
| ----------------------------------------------------------------------------
	Sub ScribeTomes
| ----------------------------------------------------------------------------	
		/declare Bag int local
		/declare Slot int local
		/declare HasVoA int local 0
		/varset HasVoA 1
		
		/if (${Cursor.ID}) /autoinv

		/keypress OPEN_INV_BAGS
		/delay 5
		/for Bag 1 to 10
			/if (${InvSlot[pack${Bag}].Item.Container}) {
				/if (!${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
				/delay 1s ${Window[Pack${Bag}].Open}
				/for Slot 1 to ${InvSlot[pack${Bag}].Item.Container}
					/if (${InvSlot[pack${Bag}].Item.Item[${Slot}].Name.Find[Tome]} && ${InvSlot[pack${Bag}].Item.Item[${Slot}].Type.Equal[Scroll]} && ${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Level} <= ${Me.Level} && !${Me.Book[${InvSlot[pack${Bag}].Item.Item[${Slot}].Spell.Name}]}) {
						/call Broadcast g "Scribing: ${InvSlot[pack${Bag}].Item.Item[${Slot}].Name}"
						/if (${HasVoA}) {
							/nomodkey /ctrlkey /itemnotify in pack${Bag} ${Slot} rightmouseup
							/delay 1s !${InvSlot[pack${Bag}].Item.Item[${Slot}].ID}
						} else {
							/nomodkey /ctrlkey /itemnotify in pack${Bag} ${Slot} leftmouseup
							/delay 1s ${Cursor.ID}
							/nomodkey /ctrlkey /itemnotify ${InvSlot[pack1]} leftmouseup
							/delay 1s !${Cursor.ID}
							/nomodkey /ctrlkey /itemnotify ${InvSlot[pack1]} rightmouseup
							/delay 1s !${InvSlot[pack1].ID}
						}
					}
				/next Slot

			}
			/if (${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
		/next Bag
		/if (${Cursor.ID}) /autoinv
	/return
|-----------------------------------------------------------------------------
| SUB: Bind bardinvis - Will look for a song on your bard that has invis, swap in the instrument type  if you've got a bandolier set, and /twist hold it. Sending in "Off" or "Stop" will turn it off. 
| ----------------------------------------------------------------------------
    Sub Bind_BardInvis(Off)
		/if (${Me.Class.ShortName.NotEqual[BRD]}) /return
		/declare i int local
		/declare InvisSong int local
		/if (${Select[${Off},Off,Stop,Drop]}) /goto :Stop
		/if (${Me.Gem[${Twist.Current}].HasSPA[12]}) /return
		:DoInvis
		/call Broadcast o "I'm a bard and I'm told to invis!"
		/if (!${BandolierSize}) {
			/call Broadcast o "You have no Bandolier sets in your ini. I won't try to swap in the correct instrument. Hope you have it..."
			}
		/for i 1 to ${Me.NumGems}
			/if (${MuleDebug}) /echo LemonsDebug: Gem#${i} checking if it's an invis song: ${Me.Gem[${i}].HasSPA[12]} && ${Me.CurrentMana} > ${Me.Gem[${i}].Mana}
			/if (${Me.Gem[${i}].HasSPA[12]} && ${Me.CurrentMana} >= ${Me.Gem[${i}].Mana}) {
				/varset InvisSong ${i}
				/echo InvisSong set to ${i} which is ${Me.Gem[${i}]}
				/break
			}
		/next i
		|Lemons: Now check if we have the instrument needed for the song. Only checking bandolier slots primary and offhand
		/if (${BandolierSize}) {
			/for i 1 to ${Bandolier.Size}
				/if (${FindItem[${Me.Bandolier[${i}].Item[1].ID}].Type.Find[${Me.Gem[${InvisSong}].Skill.Left[-1]}]} || ${FindItem[${Me.Bandolier[${i}].Item[2].ID}].Type.Find[${Me.Gem[${InvisSong}].Skill.Left[-1]}]}) {
					/echo Found a ${Me.Gem[${InvisSong}].Skill} in bandolier set #${i} ${Me.Bandolier[${i}]}
					/bandolier activate ${Me.Bandolier[${i}]}
					/break
				}
			/next i
		}
		
		|Lemons: Now to twist the song we found since we have the instrument (or not)
		/if (${MuleDebug}) /echo Trying to twist ${InvisSong}
		/twist hold ${InvisSong}
		/delay 5s ${Me.Gem[${Twist.Current}].HasSPA[12]}
		/echo ${Me.Gem[${Twist.Current}].HasSPA[12]} 
		/varset TwistingInvis 1
		/return
		
		:Stop
		/if (${Me.Gem[${Twist.Current}].HasSPA[12]}) {
			/twist off
			/varset TwistStop ${Macro.CurLine}
			/call Broadcast o "Dropping Bard Invis. Hold on to your butts"
			/varset Twisting 0
			/varset TwistingInvis 0
			/if (${MuleDebug}) /echo Stopping twist \ag${Macro.CurLine}
		}
	/return
|-----------------------------------------------------------------------------
| SUB: Bind Foreground /showwindow will put the toon you send in or target to the foreground
| ----------------------------------------------------------------------------
    Sub Bind_Foreground(ForeName)
	/echo Calling foreground for ${ForeName}
	/if (${ForeName.Length}) {
		/echo bct on ${ForeName}
		/call BCTExec ${ForeName} "/foreground"
	} else {
		/if (${Target.ID}) {
			/echo bct on ${Target.CleanName}
			/call BCTExec ${Target.CleanName} "/foreground"
		}
	}
		
	/return
|-----------------------------------------------------------------------------
| SUB: Bind GiveItem gives the specified item to the specified character. Not very robust right now
| ----------------------------------------------------------------------------	
Sub Bind_GiveItem(ItemName, Givee, giveQuantity)	
	/declare groupFlag bool local FALSE
	/declare i int local
	/declare j int local
	/declare numGivees int local 1
	/if (${ItemName.Equal[help]}) {
		/echo \aw GiveItem Help
		/echo \aw You need to use \am" " \aw if the item name or person has multiple words
		/echo \aw /giveitem \ay"ItemName" \ar"PersonToGiveTo" \agQuantity
		/echo \aw /giveitem Cookie Lemons 1000 -- Gives 1000 cokies to Lemons...hint hint
		/echo \aw /giveitem "Bag of Lemons" group 1 -- Gives 1 bag of lemons to each member of your group
		/echo \aw /giveitem \ayplatinum \arperson \aqquantity
		/echo \aw /giveitem platinum group 1000
		/echo \aw /giveitem \ay<Person>
		/echo \aw Doing just /giveitem while holding an item will attempt to give that item to a person you have target or if you put their name in the command
		/return
	}
	/echo ${ItemName.Length} ${Macro.CurLine}
	/if (!${ItemName.Length}) {
		/varset ItemName ${Target.CleanName}
	}
	/echo (${Spawn[${ItemName}].ID} && (${Spawn[${ItemName}].Type.Equal[PC]} || ${Spawn[${ItemName}].Type.Equal[NPC]}) && !${FindItem[${ItemName}].ID}) ${Macro.CurLine}
	/if (${Spawn[${ItemName}].ID} && (${Spawn[${ItemName}].Type.Equal[PC]} || ${Spawn[${ItemName}].Type.Equal[NPC]}) && !${FindItem[${ItemName}].ID}) {
		/echo They want me to give what's on my cursor to ${Givee} or Target ${Target}
		/varset ItemName ${Cursor.Name}
		/if (!${Givee.Length}) /varset Givee ${Target.CleanName}
	}
	/echo (!${Givee.Length} || ${Int[${Givee}]} || ${Givee.Equal[all]}) ${Givee} ${Macro.CurLine}
	/if (!${Givee.Length} || ${Int[${Givee}]} || ${Givee.Equal[all]}) {
		/if (${Int[${Givee}]}) /varset giveQuantity ${Givee}
		/if (${Givee.Equal[all]}) /varset giveQuantity ${FindItemCount[${ItemName}]}
		/varset Givee ${Target.Name}
	}
	/echo (${Givee.Equal[group]}) ${Macro.CurLine}
	/if (${Givee.Equal[group]}) {
		/if (!${Group}) {
			/echo You're not in a group
			/return
		}
		/varset groupFlag TRUE
		/varset numGivees ${Group}
		/echo Going to give ${giveQuantity} ${ItemName} to each member of my group ${groupFlag}
	} else {
		/echo \aw Going to give ${giveQuantity} ${ItemName} to ${Givee}
	}
	/echo (((!${Spawn[=${Givee}].ID} || ${Spawn[=${Givee}].Distance} > 100) && !${groupFlag}) || (!${FindItem[${ItemName}].ID} && (${ItemName.NotEqual[platinum]} && ${ItemName.NotEqual[plat]}))) ${Macro.CurLine}
	/if (((!${Spawn[=${Givee}].ID} || ${Spawn[=${Givee}].Distance} > 100) && !${groupFlag}) || (!${FindItem[${ItemName}].ID} && (${ItemName.NotEqual[platinum]} && ${ItemName.NotEqual[plat]}))) {
		/echo Can't give items.  (((!${Spawn[=${Givee}].ID} || ${Spawn[=${Givee}].Distance} > 100) && !${groupFlag}) || (!${FindItem[${ItemName}].ID} && (${ItemName.NotEqual[platinum]} && ${ItemName.NotEqual[plat]})))
		/return
	}
	/echo (${FindItemCount[${ItemName}]} < ${Int[${giveQuantity}]} && (${ItemName.NotEqual[platinum]} && ${ItemName.NotEqual[plat]})) ${Macro.CurLine}
	/if (${FindItemCount[${ItemName}]} < ${Int[${giveQuantity}]} && (${ItemName.NotEqual[platinum]} && ${ItemName.NotEqual[plat]})) {
		/echo Don't have enough ${ItemName} ${FindItemCount[${ItemName}]} < ${giveQuantity}
		/return
	}
	/echo (${FindItem[=${ItemName}].NoDrop} && (${Spawn[=${Givee}].Type.Equal[pc]} || ${groupFlag})) ${Macro.CurLine}
	/if (${FindItem[=${ItemName}].NoDrop} && (${Spawn[=${Givee}].Type.Equal[pc]} || ${groupFlag})) {
		/echo Can't trade no drop items to PCs
		/return
	}
	/keypress OPEN_INV_BAGS
	/for i 1 to ${numGivees}
		/if (${groupFlag}) /varset Givee ${Group.Member[${i}]}
		/echo Giving ${giveQuantity} ${ItemName} to ${Givee} ${Group.Member[${i}]} (if group)
		:giveMove
		/nav id ${Spawn[=${Givee}].ID}
		/delay 2
		/delay 10s ${Spawn[=${Givee}].Distance} < 15
		/if (${Spawn[=${Givee}].Distance} >= 15) /goto :giveMove
		/tar id ${Spawn[=${Givee}].ID}
		/delay 1s ${Target.ID} == ${Spawn[=${Givee}].ID}
		
		:givePickup
		/if (!${Window[InventoryWindow].Open}) {
			/windowstate InventoryWindow open
			/delay 2s ${Window[InventoryWindow].Open}
		}
		/if (${giveQuantity.Equal[all]}) {
			|Whole stack
			/nomodkey /itemnotify "${FindItem[${ItemName}].Name}" leftmouseup
			/delay 1s ${Cursor.ID} == ${FindItem[${ItemName}].ID}
			/if (${Cursor.ID} != ${FindItem[${ItemName}].ID}) /goto :givePickup
		} else /if (${ItemName.Equal[platinum]} || ${ItemName.Equal[plat]}) {
			|They want plat...don't we all
			/if (${Me.Platinum} < ${giveQuantity}) {
				/echo I don't have enough plat
				/return
			}
			/notify InventoryWindow IW_Money0 leftmouseup 
			/delay 1s ${Window[QuantityWnd]}
			/notify QuantityWnd QTYW_slider newvalue ${giveQuantity}
			/delay 2
			/notify QuantityWnd QTYW_Accept_Button leftmouseup
			/delay 1s ${Me.CursorPlatinum}
			/if (!${Me.CursorPlatinum}) /goto :givePickup
		} else /if (!${giveQuantity}) {
			|We want just one item
			/nomodkey /ctrlkey /itemnotify "${FindItem[${ItemName}].Name}" leftmouseup
			/delay 1s ${Cursor.ID} == ${FindItem[${ItemName}].ID}
			/if (${Cursor.ID} != ${FindItem[${ItemName}].ID}) /goto :givePickup
		} else /if (${giveQuantity} > 1 && !${FindItem[${ItemName}].Stackable}) {
			/if (${giveQuantity} > 8) {
				/echo I can't trade more than 8 unstackable items
				/return
			}
			|Unstackable and multiple
			/for j 1 to ${giveQuantity}
				:giveLargePickup
				/nomodkey /ctrlkey /itemnotify "${FindItem[${ItemName}].Name}" leftmouseup
				/delay 1s ${Cursor.ID} == ${FindItem[${ItemName}].ID}
				/if (${Cursor.ID} != ${FindItem[${ItemName}].ID}) /goto :giveLargePickup
				
				:giveLargeGive
				/if (${Target.ID} != ${Spawn[=${Givee}].ID}) /tar id ${Spawn[=${Givee}].ID}
				/click left target
				/delay 1s ${Window[TradeWnd].Child[TRDW_TradeSlot${Math.Calc[${j}-1]}].Tooltip.Length}
				
				:giveLargeFinish
				/if (!${Window[TradeWnd].Child[TRDW_TradeSlot${Math.Calc[${j}-1]}].Tooltip.Length}) {
					/goto :giveLargeGive
				}
			/next j 
			/notify TradeWnd TRDW_Trade_Button leftmouseup
			/delay 5
			/goto :giveClick
		} else /if (${FindItem[${ItemName}].ItemSlot2} >= 0) {
			|In a pack and we need the slider
			/nomodkey /itemnotify in pack${Math.Calc[${Me.Inventory[${FindItem[${ItemName}].ItemSlot}].ItemSlot}-22].Int} ${Math.Calc[${FindItem[${ItemName}].ItemSlot2}+1]} leftmouseup		
			/delay 1s ${Window[QuantityWnd]}
			/notify QuantityWnd QTYW_slider newvalue ${giveQuantity}
			/delay 2
			/notify QuantityWnd QTYW_Accept_Button leftmouseup
			/delay 1s ${Cursor.ID} == ${FindItem[${ItemName}].ID}
			/if (${Cursor.ID} != ${FindItem[${ItemName}].ID}) /goto :givePickup
		} else /if (${FindItem[${ItemName}].ItemSlot2} == -1) {
			|Top level slot and we need the slider
			/nomodkey /itemnotify in pack${Math.Calc[${Me.Inventory[${FindItem[${ItemName}].ItemSlot}].ItemSlot}-22].Int} ${Math.Calc[${FindItem[${ItemName}].ItemSlot2}+1]} leftmouseup
			/delay 1s ${Window[QuantityWnd]}
			/notify QuantityWnd QTYW_slider newvalue ${giveQuantity}
			/delay 2
			/notify QuantityWnd QTYW_Accept_Button leftmouseup
			/delay 1s ${Cursor.ID} == ${FindItem[${ItemName}].ID}
			/if (${Cursor.ID} != ${FindItem[${ItemName}].ID}) /goto :givePickup
		}
		
		:giveGive
		/if (${Target.ID} != ${Spawn[=${Givee}].ID}) /tar id ${Spawn[=${Givee}].ID}
		/click left target
		/delay 1s ${Window[TradeWnd].Child[TRDW_TradeSlot0].Tooltip.Length}
		
		:giveFinish
		/if (!${Window[TradeWnd].Child[TRDW_TradeSlot0].Tooltip.Length} && !${Window[TradeWnd].Child[TRDW_MyMoney0]}) {
			/goto :giveGive
		}
		:giveClick
		/notify TradeWnd TRDW_Trade_Button leftmouseup
		/doevents
		/delay 2s !${Window[TradeWnd].Open}
		/if (${Cursor.ID}) /goto :giveGive
		/if (${Window[TradeWnd].Open}) /goto :giveClick
	/next i
		/keypress CLOSE_INV_BAGS
/return	
|-----------------------------------------------------------------------------
| SUB: Bind GroupCheck spews toon info to EQBC or Dannet
| ----------------------------------------------------------------------------	
Sub Bind_GroupCheck()
	/declare i int local
	/call Broadcast g "[+r+]${Me.CleanName} [+g+]is in [+o+]${Zone}. [+y+]${Spawn[${MainAssist}].Distance} [+g+]away from MA. ${Me.FreeInventory} bag slots. Level [+u+]${Me.Level}"
	/if (!${Group}) /call Broadcast r "I'm not in a group!"
	/for i 1 to ${Group}
		/if ((!${Group.Member[${i}].ID} || ${Group.Member[${i}].Type.Equal[Corpse]}) && ${Group} >= ${i} && ${Spawn[${MainAssist}].ID}) /call Broadcast r "${Group.Member[${i}].Name} isn't in zone with me"
		/if (!${Group}) /return
	/next i
/return
|-----------------------------------------------------------------------------
| SUB: Bind Raidinvites - Invites Member1 for each group in your MQ2AutoGroup.ini file
| ----------------------------------------------------------------------------	
Sub Bind_RaidInvites()	
	/declare i int local
	/declare n int local
	/for i 2 to ${Math.Calc[${Ini[..\MQ2AutoGroup.ini].Count[|]}-1]}
		/echo Inviting ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member1]}
		/raidinvite ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member1]}
	/delay 2
	/next i
/return	
|-----------------------------------------------------------------------------
| SUB: Bind GroupInvites - If you are listed as Member1 in the MQ2AutoGroup then you will attempt to invite each person
| ----------------------------------------------------------------------------	
Sub Bind_GroupInvites()	
	/declare i int local
	/declare n int local
	/for i 2 to ${Math.Calc[${Ini[..\MQ2AutoGroup.ini].Count[|]}-1]}
		/echo ${i} ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member1].Equal[${Me.CleanName}]}
		/if (${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member1].Equal[${Me.CleanName}]}) {
			/if (!${Group.Member[${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member2]}].ID}) /invite ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member2]}
			/if (!${Group.Member[${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member3]}].ID}) /invite ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member3]}
			/if (!${Group.Member[${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member4]}].ID}) /invite ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member4]}
			/if (!${Group.Member[${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member5]}].ID}) /invite ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member5]}
			/if (!${Group.Member[${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member6]}].ID}) /invite ${Ini[..\MQ2AutoGroup.ini,${Ini[..\MQ2AutoGroup.ini].Arg[${i},|]},Member6]}
		}
	/next i
/return	
|-----------------------------------------------------------------------------
| SUB: Bind DoEvac Command call evac and take off camphere. SPA 88 is Combat Portal (evacuate)
| ----------------------------------------------------------------------------
    Sub Bind_DoEvac()
		/if (${Me.Class.ShortName.NotEqual[Wiz]} && ${Me.Class.ShortName.NotEqual[Dru]}) /return
		/declare EvacSpell int local
		:DoEvac
		/call Broadcast r "Get to the choppa!! (evacing). Turning off camp"
		 |-- Druid AA or Spell group evac casting.
		 /if (${Select[${Me.Class.ShortName},DRU]}) {
			 |- Drop Divine Barrier if it is up so we can exodus group!
			 /removebuff Divine Barrier
			 /if (${Me.AltAbilityReady[Exodus]}) {
				 /call BCTExec all "/camphere off"
				 /call CastWhat "Exodus" ${Me.ID} GroupEscape
			 } else /if (${Me.Book[Succor]}) {
				 /call BCTExec all "/camphere off"
				 /call CastWhat "Succor" ${Me.ID} GroupEscape
			 } else /if (${Me.Book[Lesser Succor]}) {
				 /call BCTExec all "/camphere off"
				 /call CastWhat "Lesser Succor" ${Me.ID} GroupEscape
			 }
		 }
		 |-- Wizard AA or Spell group evac casting.
		 /if (${Select[${Me.Class.ShortName},WIZ]}) {
			 /if (${Me.AltAbilityReady[Exodus]}) {
				 /call BCTExec all "/camphere off"
				 /call CastWhat "Exodus" ${Me.ID} GroupEscape
			 } else /if (${Me.Book[Evacuate]}) {
				 /call BCTExec all "/camphere off"
				 /call CastWhat "Evacuate" ${Me.ID} GroupEscape
			 } else /if (${Me.Book[Lesser Evacuate]}) {
				 /call BCTExec all "/camphere off"
				 /call CastWhat "Lesser Evacuate" ${Me.ID} GroupEscape
			 }
		 }
		|Lemons: Turn off camphere and evac us
		/return
	/return	
|-----------------------------------------------------------------------------
| SUB: Bind WriteDebug
| ----------------------------------------------------------------------------
    Sub Bind_WriteDebug(Setting,int captureTime)	
	/call Bind_LemonDebug writedebug
	/if (${Setting.Equal[stop]}) {
		/varset WriteDebugTimer 1
		/varset WriteDebug 
		/return
	}
	/if (${Setting.Equal[clear]}) {
		/varset WriteDebugTimer 1
		/varset WriteDebug 
		/call Bind_ClearDebug all
		/return
	}
	/if (${captureTime}) {
		/echo Setting WriteDebug ${Setting} for ${captureTime} seconds
		/varset WriteDebugTimer ${captureTime}s
	} else {
		/echo Setting WriteDebug ${Setting} for 60 seconds
		/varset WriteDebugTimer 1m
	}
	/if (${Setting.Equal[all]}) {
		/varset WriteDebug all
		DEBUGN /echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer} Cap:${captureTime}"
		/varset Debug 1
        /varset DebugBuffs 1
        /varset DebugCombat 1
        /varset DebugHeal 1
        /varset DebugMez 1
        /varset DebugMove 1
        /varset DebugPet  1
        /varset DebugPull 1
		/varset DebugDPS 1
		|/varset DebugChainP 1
		/varset DebugCast 1
		|/varset DebugN 1
		/varset DebugRK 1
		/varset DebugTargetChoice 1
	}
	/if (${Setting.Equal[N]}) {
		/varset WriteDebug ${WriteDebug}N
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
	}
	/if (${Setting.Find[buff]}) {
		/varset WriteDebug ${WriteDebug}buff
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugBuffs 1
	}
	/if (${Setting.Find[dps]}) {
		/varset WriteDebug ${WriteDebug}dps
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugDPS 1
	}
	/if (${Setting.Find[cast]}) {
		/varset WriteDebug ${WriteDebug}cast
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugCast 1
	}
	/if (${Setting.Find[combat]}) {
		/varset WriteDebug ${WriteDebug}combat
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugCombat 1
	}
	/if (${Setting.Find[heal]}) {
		/varset WriteDebug ${WriteDebug}heal
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugHeal 1
	}
	/if (${Setting.Find[move]}) {
		/varset WriteDebug ${WriteDebug}move
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugMove 1
	}
	/if (${Setting.Find[mez]}) {
		/varset WriteDebug ${WriteDebug}mez
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugMez 1
	}
	/if (${Setting.Find[pet]}) {
		/varset WriteDebug ${WriteDebug}pet
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugPet 1
	}
	/if (${Setting.Find[pull]}) {
		/varset WriteDebug ${WriteDebug}pull
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugPull 1
	}
	/if (${Setting.Find[chain]}) {
		/varset WriteDebug ${WriteDebug}chain
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		|/varset DebugChainP 1
	} 
	/if (${Setting.Find[target]}) {
		/varset WriteDebug ${WriteDebug}targetchoice
		/echo S: ${Setting} WD: ${WriteDebug} T: ${WriteDebugTimer}
		/varset DebugTargetChoice 1
	} 
	/echo WriteDebug: ${WriteDebug}, Ini:${WriteDebugINI} 
	/return
|-----------------------------------------------------------------------------
| SUB: Bind ClearDebug
| ----------------------------------------------------------------------------
    Sub Bind_ClearDebug(clearWhat)
		/declare i int local
		/if (${clearWhat.Equal[all]}) {
			/for i ${Ini[MuleAssistDebug_${Me.CleanName}.ini].Count[|]} downto 0
				/ini "MuleAssistDebug_${Me.CleanName}.ini" "${Ini[MuleAssistDebug_${Me.CleanName}.ini].Arg[${i},|]}" NULL
			/next i
		} else {
			/ini "MuleAssistDebug_${Me.CleanName}.ini" "${clearWhat}" NULL
		}
		
/return	
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd1
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd1
        /varset PetActiveState  0
        /varset PetSuspendState 1
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateAdd1 triggered. \agLine#:${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#:${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd2
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd2
        /varset PetActiveState  1
        /varset PetSuspendState 1
        /varset PetTotCount     2
        /if (${DebugPet}) /echo PetSusStateAdd2 triggered. \agLine#:${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#:${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateSub
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateSub
        /varset PetActiveState  1    
        /varset PetSuspendState 0
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateSub triggered. \agLine#:${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#:${Macro.CurLine}
    /return   
|-----------------------------------------------------------------------------  
| SUB: Back Off and stop melee  
| ----------------------------------------------------------------------------      
    Sub Bind_BackOff(Setting)
		/if (${DPSPaused} || ${Setting.Equal[off]}) {  
            /if (${DPSPaused} && ${UseMQ2Melee}) /squelch /melee on
            /varset DPSPaused 0  
            /echo \arResetting. No Longer Backing off.  
        } else {  
            /varset DPSPaused 1h  
            /varset CombatStart 0  
            /if (${UseMQ2Melee}) /squelch /melee off
            /if (${Me.Combat}) {  
                /squelch /attack off  
                /if (${Stick.Active})  /stick off 
            }  
            /call CombatReset BackOff
            /varset DPSPaused 1h 
            /echo Backing off - All Combat has been reset.
        }  
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {  
            /call DoWeMove Bind_BackOff
        }
        /doevents flush BackOff  
		/if (${Setting.Equal[temp]}) {
			/varset DPSPaused 3s
		}
    /return 
| -------------------------------------------------------------------------------------
| SUB: Event PetToysPlease 
| -------------------------------------------------------------------------------------    
    Sub Event_PetToysPlease(Message,string MTPet)
        /if (!${MTPet.Length}) /return
        /if (${MTPet.Find[null]}) /return
        /if (${Spawn[${MTPet}].Type.NotEqual[Pet]} && ${MTPet.NotEqual[group]}) /return
        /declare PTPPetID int local
        /declare GMemID int local
        /declare GMemShortName string local
        /declare GMemPetName string local
        /declare i int local 0
        DEBUGPET PetToysPlease: Enter \agLine#:${Macro.CurLine}"
        | If group command give all pets in group toys
        /if (${MTPet.Find[GROUP]}) {
            /echo I am giving pet toys to every Pet in Group except mine.
            | Start at 1 my pet doesn't need toys
            /for i 1 to ${Group}
            /varset GMemID ${Group.Member[${i}].ID};
            /varset PTPPetID ${Group.Member[${i}].Pet.ID}
            /varset GMemShortName ${Group.Member[${i}].Class.ShortName} 
            /varset GMemPetName ${Group.Member[${i}].Pet.CleanName}
            DEBUGPET PetToysPlease: ${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]} \agLine#:${Macro.CurLine}"
            /if (${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}) {
                /if (${PetToysOn}) /call pettoys ${GMemPetName}
            }
            /next i
        } else {
            | Individual Pet.
            /if (${PetToysOn}) {
                /echo Giving pet toys to (${MTPet}).
                /call pettoys ${MTPet}
            }
        }
       DEBUGPET PetToysPlease: Leave"
    /return
| -------------------------------------------------------------------------------------
| SUB: Add stuff to alert list  
| -------------------------------------------------------------------------------------      
    Sub AlertAddToList(int whatlist, MvarList)
        DEBUGN AlertAddToList List:${whatlist} Mlist: ${MvarList}"
        /declare k int local
        | Clear ignore mobs alert from list before assigning from ini list
         /squelch /alert clear ${whatlist}
        /if (${MvarList.Length} && !${MvarList.Find[null]}) {
            /for k 1 to 25
                /if (${MvarList.Arg[${k},,].Length} && !${MvarList.Find[null]} && ${Debug}) /echo \atDEBUG ADD ${MvarList.Arg[${k},,]} to ${MvarList}
                /if (${MvarList.Arg[${k},,].Length}) {
                    /squelch /alert add ${whatlist} "=${MvarList.Arg[${k},,]}"
                    DEBUGN AlertAddToList Add ${MvarList.Arg[${k},,]} to Alert List ${whatlist}"
                }
            /next k
        }
        DEBUGN AlertAddToList Leave"
    /return

|--------------------------------------------------------------------------------------
| SUB: CastDisc
|--------------------------------------------------------------------------------------
	Sub CastDisc(string WhatDisc,int WhatID)
        /declare WaitTimerCD timer local 
        DEBUGCAST CastDisc ${WhatDisc} Enter"
        /if (!${Spell[${WhatDisc}].Duration} || (${Spell[${WhatDisc}].Duration} && ${Spell[${WhatDisc}].TargetType.Equal[Self]} && !${Me.ActiveDisc.ID}) || ${Spell[${WhatDisc}].TargetType.NotEqual[Self]} || ${Spell[${WhatDisc}].DurationWindow}) {
            DEBUGCAST Well we passed the CastDisc checks...${Me.Invis[4]}"
			/varset WaitTimerCD 3s
			/if (${Spell[${WhatDisc}].RecastTime.TotalSeconds} < 3) {
				/varset WaitTimerCD ${Spell[${WhatDisc}].RecastTime.TotalSeconds}s
			}
            /while (${Me.CombatAbilityReady[${WhatDisc}]} && ${WaitTimerCD}) {
				DEBUGCAST [${Time}] going to /disc ${WhatDisc} ${Me.CombatAbilityReady[${WhatDisc}]} ${WaitTimerCD}"
				/if (${MacroQuest.Build}==4) {
					|in old clients /disc only accepts name not ID
					DEBUGCAST /disc ${WhatDisc}"
                	/disc ${WhatDisc}
				} else {
					DEBUGCAST /disc ${Me.CombatAbility[${Me.CombatAbility[${WhatDisc}]}].ID}"
					/disc ${Me.CombatAbility[${Me.CombatAbility[${WhatDisc}]}].ID}
				}
				/delay 1
				/if (${MacroQuest.Build}==4) {
					/if (${Spell[${WhatDisc}].RecastTimerID} == -1) {
						|we cant wait here for this on emu CombatAbilityReady always return true
						/break
					}
				}
				/if (${Spell[${WhatDisc}].MyCastTime}) {
					/call WaitCast "CastDisc" ${Spell[${WhatDisc}].MyCastTime}
				}
            }
			DEBUGCAST Cast Success ${Target}"
			/varset CastResult CAST_SUCCESS
        } else {
			DEBUGCAST bullshit..."
		}
		DEBUGCAST CastDisc ${Me.CombatAbilityReady[${WhatDisc}]} Leave"
    /return ${CastResult}
| -------------------------------------------------------------------------------------
| SUB: Cast Mount
| -------------------------------------------------------------------------------------      
    Sub CastMount
        /if (!${Me.CanMount}) /return
        /if (${Zone.Indoor}) /return
        /if (${Me.Mount.ID}) /return
        /if (!${MountOn}) /return
        /if (${Me.Invis}) /return
        /if (${HealsOn} && ${AggroTargetID}) /return
        /declare i int local 0
        /declare bItem int local 0
        /declare icasttime int local 0
        /for i 1 to ${Buffs.Size}
            | Cast mount
            /if (${Buffs[${i}].Arg[2,|].Equal[Mount]} && !${Buffs[${i}].Find[0]} && !${Me.Mount.ID} && !${Attacking} && ${MountOn} && !${Me.FeetWet}) {
                /if (${FindItem[${Buffs[${i}].Arg[1,|]}].ID}) {
                    /varset icasttime ${FindItem[${Buffs[${i}].Arg[1,|]}].Spell.MyCastTime}
                    DEBUGCAST It's an item btw. Spell is ${FindItem[${Buffs[${i}].Arg[1,|]}].Spell} my casttime ${FindItem[${Buffs[${i}].Arg[1,|]}].Spell.MyCastTime}" 
                }
                /if ((${If[${BuffsCond[${i}]},1,0]} && ${BuffsCOn}) || !${BuffsCOn}) {
                    |DEBUGCAST Time to get a mount up."
                    /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} CastMount
                    /if (${icasttime}==0) {
                        /varset icasttime 5
                    }
                    /call WaitCast "CastMount" ${icasttime}
                    /if (${Macro.Return.Equal[CAST_OUTDOORS]}) /varset MountOn 0
                    /call CheckCasting 80
                } else {
                    DEBUGCAST It's an item. Not casting due to buff conditions."
                }
            }
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mana
| -------------------------------------------------------------------------------------      
    Sub CastMana
        /if (${Me.Invis}) /return
        /declare i int local 0
        /for i 1 to ${Buffs.Size}    
			/if (${MezOn}) {
				/varset MezBroke 0
				/doevents MezBroke
				/if (${MezBroke}) /call DoMezStuff
			}
			/if (${HealsOn} && ${Me.CombatState.Equal[Combat]}) /call CheckHealth
			| Check and Cast mana type spells/aas/items - Canni/Paragon/Harvest - prevent toon from using before rez after zoning for 2 min
			/if (!${ConditionsOn} || ${If[${BuffsCond[${i}]},1,0]}) {
				/if (${Buffs[${i}].Arg[2,|].Equal[Mana]} && !${Me.Buff[Revival Sickness].ID} && !${JustZoned}) {
					/if (${Buffs[${i}].Arg[1,|].Equal[Dichotomic Psalm]} && (${IAmABard}|| ${Me.CurrentEndurance}<6600)) /goto SkipMe
					/if (${Me.PctMana}<=${Buffs[${i}].Arg[3,|]} && ${Me.PctHPs}>${Buffs[${i}].Arg[4,|]}) {
						/if (${Cursor.ID}) /call CheckCursor
						/call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} Buffs
						/if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Casting >> ${Buffs[${i}].Arg[1,|]} << for mana
					}
					:SkipMe
				}
				/if (${Buffs[${i}].Arg[2,|].Equal[Managroup]} && (!${Medding})) {
					DEBUGBUFF Calling RegenOther with ${Buffs[${i}].Arg[1,|]} | Mana | ${Buffs[${i}].Arg[3,|]} | ${Buffs[${i}].Arg[5,|]} from CastMana"
					/call RegenOther "${Buffs[${i}].Arg[1,|]}" Mana ${Buffs[${i}].Arg[3,|]} ${Buffs[${i}].Arg[5,|]}
				}				
			}
			
        /next i
    /return

	Sub Event_MeHidden(Line, string name)
		/doevents flush MeHidden 
		/varset HideResult 1
	/return
	Sub Event_CastFailed(Line, string Spell)
		/doevents flush CastFailed 
		/varset CastResult CAST_FIZZLED
	/return
	Sub Event_CastInterrupted(Line, string Spell)
		/doevents flush CastInterrupted 
		/varset CastResult CAST_Interrupted
	/return
	Sub Event_CastResist(Line, string Spell, string rName)
		/doevents flush CastResist 
		/varset CastResult CAST_RESIST
		/doevents CastMezImmune
	/return ${Spawn[=${rName}].ID}
	
	Sub Event_CastMezImmune(Line, string Spell)
		/doevents CastResist
		/if (${Spawn[${Macro.Return}].Type.Equal[NPC]}) {
			DEBUGMEZ Event MezImmune Found a resist, gonna add ${Macro.Return} ${Spawn[${Macro.Return}]} to mez immune"
			/addimmune ${Macro.Return}
		} else {
			DEBUGMEZ Event MezImmune No spawn with ID ${Macro.Return} ${Spawn[${Macro.Return}]} to mez immune"
			/addimmune ${Target.ID}
		}
		/varset CastResult CAST_IMMUNE
	/return
	
	Sub Event_CastDistr(Line, string Spell)
		|Lemons:Setting it to success even though it didn't land because otherwise we get stuck trying to cast it over and over. 
		/doevents flush CastDistr
		/varset CastResult CAST_SUCCESS
	/return
| -------------------------------------------------------------------------------------
| SUB: You Hit DPS Meter
| -------------------------------------------------------------------------------------      
    Sub Event_YouHit(Line, YHMob, YHDamage, string YHSpell)
        /declare l_YHSpell string local 
		/if (${Defined[YHSpell]}) {
			/varset l_YHSpell ${YHSpell}
		}
        /if (!${DPSMeter}) {
            /doevents flush YouHit 
            /return
        }
        /if (!${Defined[DPSTimeStart${MyTargetID}]}) {
            /declare DPSTimeStart${MyTargetID} int outer ${Time.SecondsSinceMidnight}
            /varset DPSTarget ${Target.ID}
        }
        /declare DPSType string local
        /declare DPSTime int local
        /varset DPSTime ${Math.Calc[${Time.SecondsSinceMidnight}-${DPSTimeStart${MyTargetID}}]}
	|/echo [${Time}] Setting DPSTime to ${DPSTime}
        /if (${l_YHSpell.Length}==0) {
            /if (${Line.Find[backstab]}) /varset DPSType Backstab        
            /if (${Line.Find[bash]}) /varset DPSType Bash
            /if (${Line.Find[bite]}) /varset DPSType Bite
            /if (${Line.Find[claw]}) /varset DPSType Claw
            /if (${Line.Find[crush]}) /varset DPSType Crush
            /if (${Line.Find[frenz]}) /varset DPSType Frenzy
            /if (${Line.Find[kick]}) /varset DPSType Kick
            /if (${Line.Find[maul]}) /varset DPSType Maul
            /if (${Line.Find[non-melee]}) /varset DPSType Non-melee
            /if (${Line.Find[pierce]}) /varset DPSType Pierce
            /if (${Line.Find[punch]}) /varset DPSType Punch
            /if (${Line.Find[slash]}) /varset DPSType Slash
            /if (${Line.Find[slam]}) /varset DPSType Slam
            /if (${Line.Find[slice]}) /varset DPSType Slice        
            /if (${Line.Find[sting]}) /varset DPSType Sting
        }
        /if (${l_YHSpell.Length}>=1) /varset DPSType Spell
        /if (${Line.Find[${Me.Pet.CleanName}]})  /varset DPSType Pet
        /if (${Line.Find[${Me}`s pet]})  /varset DPSType Pet
        /if (${Line.Find[${Me}`s warder]})  /varset DPSType Pet
 
        /varcalc DPSCounter ${DPSCounter}+1
        /if ((${Line.Find[${Me.Pet.CleanName}]} || ${Line.Find[${Me}`s pet]} ||  ${Line.Find[${Me}`s warder]}) && ${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0) /varcalc DPSPetTotal ${DPSPetTotal}+${YHDamage}
        /if (${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0 && ${DPSType.NotEqual[pet]}) /varcalc DPSTotal ${DPSTotal}+${YHDamage}
        | Return to avoid divide by 0 errors in calculations
        /if (${DPSTime}<=0 || !${DPSTarget}) /return
        /if (${DPSSpam} && ${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0) /echo Mob/ID: ${YHMob}/${DPSTarget} -  Type: ${DPSType}/${YHDamage} - Total Damage: ${DPSTotal} - Time: ${DPSTime}s - DPS: ${Math.Calc[${DPSTotal}/${DPSTime}]}
        /varset DPSLastTime ${DPSTime}
    /return
| -------------------------------------------------------------------------------------
| SUB: Comma Me Bro - CommaNation Domination
| ------------------------------------ -------------------------------------------------           
    Sub CommaMeBro(string cmbnumber)
        /declare CommaNator string local 
        | Strip out any decimal points 
        /varset cmbnumber ${cmbnumber.Arg[1,.]}
        /if (${cmbnumber.Length}<=3 ) /varset CommaNator ${cmbnumber}
        /if (${cmbnumber.Length}>3 && ${cmbnumber.Length}<=6) /varset CommaNator  ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-3]}]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>6  && ${cmbnumber.Length}<=9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-6]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-9]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-8]},3]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
    /return ${CommaNator}
| -------------------------------------------------------------------------------------
| SUB: Event_Timer 
| ------------------------------------ -------------------------------------------------           
    Sub Event_Timer(Timer, OriginalValue)
		DEBUGN Timer called ${Timer} ${OriginalValue}"
       /if (${Select[${Timer},TributeTimer,AggroOffTimer,TellTimer,WriteDebugTimer,ZombieTimer,SitToMedTimer]}==0) /return
       /if (${Timer.Equal[TributeTimer]}) {
          /if (${UseTribute} && ${Me.TributeActive}) {
             /if (!${AggroTargetID} || (${Target.ID} && !${Target.Named})) {
                /squelch /tribute personal off
             } else {
                /if (${Target.ID} && ${Target.Named}) /varset ${Timer} 580s
             }      
          }
       }
       /if (${Timer.Equal[AggroOffTimer]}) {
          /if (${Me.Feigning}) {
			/echo stand feign2
			/stand
		  }
          /if (${Me.Invis}) /makemevisible
       }
        /if (${Timer.Equal[SitToMedTimer]} && !${Me.Moving}) {
            /if (!${MeleeOn} && ${Me.Standing} && ${SitToMed} && !${Me.Mount.ID} && !${Me.Casting.ID} && (${Me.TargetOfTarget.ID}!=${Me.ID} || ${Target.ID}==${Me.ID})) {
				/call SitIfNotBard Timer
			}
			/if (${SitToMed} != ${SitToMedTimer.OriginalValue}) /varset SitToMedTimer ${Math.Calc[${Ini[${IniFileName},General,SitToMed]} * 10]}
        }
		/if (${Timer.Equal[ZombieTimer]}) {
			/call Broadcast r "Braaaaiiiinnnnssss"
			/varset ZombieTimer 60s
		}
		/if (${Timer.Equal[WriteDebugTimer]}) {
			/echo Debug Write Ini timer is up! ${WriteDebug} is what we were writing to MuleAssistDebug.ini.
			/popup Debug Write Ini timer is up! ${WriteDebug} is what we were writing to MuleAssistDebug.ini.
			/beep
			/if (${WriteDebug.Equal[all]} || ${WriteDebug.Equal[N]} && ${Debug}) {
				/varset Debug 0
				/varset DebugBuffs 0
				/varset DebugCombat 0
				/varset DebugHeal 0
				/varset DebugMez 0
				/varset DebugMove 0
				/varset DebugPet  0
				/varset DebugPull 0
				/varset DebugDPS 0
				|/varset DebugChainP 0
				/varset DebugCast
				|/varset DebugN 0
				/varset DebugRK 0
				/varset DebugTargetChoice 0
			}
			/if (${WriteDebug.Find[buff]}) {
				/varset DebugBuffs 0
			}
			/if (${WriteDebug.Find[dps]}) {
				/varset DebugDPS 0
			}
			/if (${WriteDebug.Find[cast]}) {
				/varset DebugCast 0
			}
			/if (${WriteDebug.Find[Combat]}) {
				/varset DebugCombat 0
			}
			/if (${WriteDebug.Find[heal]}) {
				/varset DebugHeal 0
			}
			/if (${WriteDebug.Find[Move]}) {
				/varset DebugMove 0
			}
			/if (${WriteDebug.Find[mez]}) {
				/varset DebugMez 0
			}
			/if (${WriteDebug.Find[pet]}) {
				/varset DebugPet 0
			}
			/if (${WriteDebug.Find[pull]}) {
				/varset DebugPull 0
			}
			/if (${WriteDebug.Find[chain]}) {
				|/varset DebugChainP 0
			}
			/if (${WriteDebug.Find[targetchoice]}) {
				/varset DebugTargetChoice 0
			}
			/varset WriteDebug 
		}
       /doevents flush Timer
    /return
| -------------------------------------------------------------------------------------
| SUB: Spell_Rk_Check
| ------------------------------------ -------------------------------------------------           
    Sub Spell_Rk_Check(Rk_Check_What)
        /declare rkCheck                string      local null
        /declare rkCheck1               string      local 
        /declare rkdCheck               string      local
        /declare rkTemp                 string      ${Rk_Check_What.Arg[1,|]}
        /declare rkdTemp                string      ${Rk_Check_What.Arg[3,|]}
        |/varset DebugRK 1
        /if (${DebugRK}) /echo \atDEBUG Spell_Rk_Checks: Enter \agLine#:${Macro.CurLine}
        /if (${Rk_Check_What.Left[1].Equal[0]} || ${Int[${Rk_Check_What.Left[1]}]}>0) /return ${Rk_Check_What}
        | Check for Rk. in spell name and Remove it.   
        /if (${rkTemp.Find[ Rk.]}) {
            /varset rkTemp ${rkTemp.Left[${Math.Calc[${rkTemp.Find[ Rk.]}-1]}]} 
        }
        /if (${Int[${Me.Book[${rkTemp}]}]}==0 && ${Int[${Me.Book[${Spell[${rkTemp}].RankName}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}==0 && ${Int[${Me.CombatAbility[${Spell[${rkTemp}].RankName}]}]}==0) /return ${Rk_Check_What}
        /if (${DebugRK}) /echo \atDEBUGSpell_Rk_Checks: 1 rkCheck: "${rkCheck}" rkTemp: "${rkTemp}" rkdCheck: "${rkdCheck}" rkdTemp: "${rkdTemp}"  \agLine#:${Macro.CurLine}
        | If this is NOT an Alt Ability then it must be a spell.
        /if (${Int[${Me.AltAbility[${rkTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
           /if (${DebugRK}) /echo 1a. well we think ${rkTemp} is an AA
           /varset rkCheck ${rkTemp}
        } else {
           /if (${DebugRK}) /echo 1b. well ${rkTemp} is not an AA. Setting rkCheck to ${Spell[${rkTemp}].RankName}
           /varset rkCheck ${Spell[${rkTemp}].RankName}
        }
        | check for null
        /if (${DebugRK}) /echo \atDEBUG Spell_Rk_Checks: 2 rkCheck: ${rkCheck} rkTemp: ${rkTemp} Rk_Check_What: ${Rk_Check_What} \agLine#:${Macro.CurLine}
        | must NOT be null so lets fix Rk_Check_What.
        /if (${rkCheck.NotEqual[${rkTemp}]}) {
            /if (${Rk_Check_What.Find[|]}>0) {
                /varset rkCheck1 ${rkCheck}${Rk_Check_What.Right[-${Math.Calc[${Rk_Check_What.Find[|]}-1]}]} 
                /varset rkCheck ${rkCheck1}
            }
        } else {
            /varset rkCheck ${Rk_Check_What}
        }
        /if (${Rk_Check_What.Arg[2,|].Equal[dual]}) {
			/if (${DebugRK}) /echo 1. we have a dual spell
           /if (${rkdTemp.Find[ Rk.]}) {
               /varset rkdTemp ${rkdTemp.Left[${Math.Calc[${rkdTemp.Find[ Rk.]}-1]}]} 
           }
           /if (${Me.AltAbility[${rkdTemp}].ID} || ${Me.AltAbility[${rkTemp}].Spell.ID}) {
               /varset rkdCheck ${Spell[${rkdTemp}].RankName}
           } else {
               /if (${Me.SpellRankCap} < 2) {
                   /varset rkdCheck ${rkdTemp}
               } else {
					/if (${DebugRK}) /echo 2. rkdTemp = ${rkdTemp}
					|/echo ok look, if the Dual Spell is a Rk. XXX we obviously need to set the spell it triggers to the same rank...
					|if they don't have same rank of the single spell, we need to force it...
					/varset rkdCheck ${Spell[${rkdTemp}].RankName}
					/if (${DebugRK}) /echo 3. rkTemp = ${rkTemp}
					/if (${DebugRK}) /echo 3a. rkdCheck = ${rkdCheck}
					/varset rkCheck ${rkCheck.Arg[1,|]}
					/if (${DebugRK}) /echo 3b. rkCheck = ${rkCheck}
					/if (${rkCheck.Find[ Rk.]}) {
						/if (${DebugRK}) /echo 4. ${rkCheck} (rkCheck) has a rank

						/if (!${rkdCheck.Find[ Rk.]}) {
							/if (${DebugRK}) /echo 5. ${rkdCheck} (rkdCheck) has NO rank
							|/if (${DebugRK}) /echo \aOur trigger spell for Dual does NOT have a rank ${rkdCheck} \agLine#:${Macro.CurLine}
							/varset rkdCheck ${rkdCheck} ${rkCheck.Right[${Math.Calc[${rkCheck.Length} - ${rkCheck.Find[ Rk.]}]}]}
							/if (${DebugRK}) /echo 5. rkdCheck = ${rkdCheck}
						}
					}
               }
           }
			/if (${DebugRK}) /echo 6. Setting rkCheck to rkCheck.Arg[1,|]}|dual|${rkdCheck}
           |/if (${DebugRK}) /echo \atDEBUG Spell_Rk_Checks: 3 rkdCheck: ${rkdCheck} rkdTemp: ${rkdTemp} Rk_Check_What: ${Rk_Check_What} \agLine#:${Macro.CurLine}
           /varset rkCheck ${rkCheck.Arg[1,|]}|dual|${rkdCheck}
		   /if (${DebugRK}) /echo 7. rkCheck is now ${rkCheck}
		   |/if (${DebugRK}) /echo \atDEBUG Spell_Rk_Checks: 3a I just set rkCheck to ${rkCheck} \agLine#:${Macro.CurLine}
		   |/mqp
        }
        /if (${DebugRK}) /echo \atDEBUG Spell_Rk_Checks: 4 Rk_Check_What: ${Rk_Check_What} rkCheck: ${rkCheck} rkTemp: ${rkTemp} \agLine#:${Macro.CurLine}
        /if (${DebugRK}) /echo \atDEBUG Spell_Rk_Checks: Exit \agLine#:${Macro.CurLine}
        |/varset DebugRK 0
    /return ${rkCheck}
| -------------------------------------------------------------------------------------
| SUB: Check cursor
| -------------------------------------------------------------------------------------           
    Sub CheckCursor
        :inventory
			/if (!${Me.FreeInventory}) /call BroadCast r "I have an item and no where to put it! I need help!"
			/if (${Me.FreeInventory}) /autoinventory
            /delay 2s !${Cursor.ID}
        /if (${Cursor.ID}) /goto :inventory
    /return      
| -------------------------------------------------------------------------------------
| SUB: Event LeftGroup
| ------------------------------------------------------------------------------------- 
    Sub Event_LeftGroup(Line,LGName)
        /if (${Bool[${GMailEvents.Find[leftgroup]}]}==TRUE) /call GmailSend "${LGName} has left the group."
        /doevents flush LeftGroup
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind IVU
| ------------------------------------------------------------------------------------- 
    Sub Bind_IVU(IVUid)
	/if (!${Me.Book[Invisibility versus Undead]}) /return
        /if (!${IVUid}) {
		/echo no id supplied in IVU, returning
		/return
	}
	/echo time to ivu on ${Spawn[${IVUid}]}
	
:checkland
	call CacheBuffs ${IVUid}
	/if (${Spawn[${IVUid}].CachedBuff[Invisibility versus Undead].ID}) {
		/echo ${Spawn[${IVUid}]} is IVUED!
	} else {
		/if (${Target.ID}!=${IVUid}) {
			/if (${Target.ID}) {
				/squelch /target clear
				/delay 1s ${Target.BuffsPopulated}==FALSE
			}
			/if (${MuleDebug}) /echo Targeting a mob 15x
			/target id ${IVUid}
			/delay 1s ${Target.ID}==${IVUid}
			/delay 1s ${Target.BuffsPopulated}==TRUE
			/delay 1s ${Target.CachedBuffCount}!=-1
		}
		/cast "Invisibility versus Undead"
		/call WaitCast ${Spell[Invisibility versus Undead].MyCastTime}
		|delayremove/delay 1
		/goto :checkland
	}
	/echo leaving Bind_IVU
/return

Sub SoW(int TheSowID)
	/echo SoW was called \agLine#:${Macro.CurLine}
	/if (!${TheSowID}) {
		/echo TheSowID was ${TheSowID} so returning \agLine#:${Macro.CurLine}
		/return
	}
:checkland
	/if (${Target.ID}!=${TheSowID}) {
		/target id ${TheSowID}
		/delay 1s ${Target.ID}==${TheSowID}
		/delay 1s ${Target.BuffsPopulated}==TRUE
		/delay 1s ${Target.CachedBuffCount}!=-1
	}
	/if (!${Spell[Spirit of Wolf].StacksTarget}) {
		/if (${Group}) {
			/call BCTell ${Group.Leader} "Spirit of wolf does NOT stack on ${Target}"
		}
	}
	/echo ok casting SoW on ${Target} \agLine#:${Macro.CurLine}
	/cast "Spirit of Wolf"
	/call WaitCast ${Spell[Spirit of Wolf].MyCastTime}
	/if (${CastResult.Equal[CAST_FIZZLED]}) {
		/if (${Spell[Spirit of Wolf].Mana} < ${Me.CurrentMana}) {
			/goto :checkland
		}
	}
	/varset SoWID 0
/return

| -------------------------------------------------------------------------------------
| SUB: Bind RootAll roots everything on XTarget
| ------------------------------------------------------------------------------------- 
    Sub Bind_RootAll(string rootspell)
		|/echo Bind_RootAll called spell is ${rootspell} \agLine#:${Macro.CurLine}
		/varset RootString ${rootspell}
		|/echo time to Root ${Me.XTarget} mobs on XTarget using ${RootString} \agLine#:${Macro.CurLine}
	/return

Sub DoRootAll(string root_spell)
	/declare radius string local 40
	/if (${root_spell.Find[:]}) {
		/varset radius ${root_spell.Mid[${Math.Calc[${root_spell.Find[:]}+1]},400]}
		/varset root_spell ${root_spell.Left[${Math.Calc[${root_spell.Find[:]}-1]}]}
		|/echo root_spell has a : in it. root_spell is now ${root_spell} and radius is ${radius} \agLine#:${Macro.CurLine}
		|/mqp on
	}
	/echo DoRootAll called spell is ${root_spell} radius is ${radius} \agLine#:${Macro.CurLine}
	/varset RootString NULL
	/declare i int local 0
	/for i 1 to ${Me.XTarget}
		/if (${Me.XTarget[${i}].ID}) {
			/if (${Me.XTarget[${i}].Distance} < ${radius}) {
				/if (${Me.XTarget[${i}].Type.Equal[NPC]}) {
					/if (${Target.ID}!=${Me.XTarget[${i}].ID}) {
						/target id ${Me.XTarget[${i}].ID}
						/delay 1s ${Target.ID}==${Me.XTarget[${i}].ID}
						/delay 2s ${Target.BuffsPopulated}==TRUE
						/delay 1s ${Target.CachedBuffCount}!=-1
					}
					/if (!${Target.Rooted.ID}) {
						/echo DoRootAll Called ${root_spell} \agLine#:${Macro.CurLine}
						/call CastWhat "${root_spell}" ${Target.ID} "DPS"
					}
				}
			}
		}
	/next i
/return

| -------------------------------------------------------------------------------------
| SUB: Bind SOW casts sow on SpawnID
| ------------------------------------------------------------------------------------- 
    Sub Bind_SOW(int ASoWID)
		/if (!${Me.Book[Spirit of Wolf]}) {
			/echo I don't have SoW \agLine#:${Macro.CurLine}
			/return
		}
		/if (!${ASoWID}) {
			/echo no ID supplied in SOW, returning \agLine#:${Macro.CurLine}
			/return
		}
		/varset SoWID ${ASoWID}
		/echo time to SoW ${Spawn[${SoWID}]} \agLine#:${Macro.CurLine}
	/return


| -------------------------------------------------------------------------------------
| SUB: Bind ZoneInfo
| ------------------------------------------------------------------------------------- 
    Sub Bind_ZoneInfo
        /declare LineInfo string local
        /echo -------------------------------------------------------------------------
        /echo MezImmune: ${Ini[${InfoFileName},${ZoneName},MezImmune]}
        /echo MobsToPull: ${Ini[${InfoFileName},${ZoneName},MobsTopull]}
        /echo MobsToIgnore: ${Ini[${InfoFileName},${ZoneName},MobsToIgnore]}
        /echo MobsToBurn: ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
        /echo -------------------------------------------------------------------------
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind WriteMySpell
| ------------------------------------------------------------------------------------- 
    Sub Bind_WriteMySpells
        /declare i int local 0
            /for i 1 to 13
            /echo Gem ${i}: ${Me.Gem[${i}].Name}
            /ini ${IniFileName} "MySpells" "Gem${i}" "${Me.Gem[${i}].Name}"
        /next i
    /return  
| -------------------------------------------------------------------------------------
| SUB: Bind MemMySpells
| ------------------------------------------------------------------------------------- 
   Sub Bind_MemMySpells(Message)
        /declare temppCharName          string      local
        /declare pCharName              string      local ${Message}
        /declare tempIniFileName        string      local
        /declare pKV                    string      local
        /declare i                      int         local
        /declare ii                     int         local
        /declare pGem                   string      local       
        /declare tempSpellName          string      local 
        /echo ${pCharName} from ${Message}  to !${pCharName.Length} || ${pCharName.Equal[null]}
        DEBUGN MemMySpells: Enter"
        /if (!${pCharName.Length} || ${pCharName.Equal[null]}) {
           /varset temppCharName ${Me.CleanName}
		  | /echo tempname set to ${Me.CleanName}
        } else {
           /varset temppCharName ${pCharName}
		 |  /echo tempname set to ${pCharName}
        }
		|/echo ${Ini[MuleAssist_${EverQuest.Server}_${temppCharName}.ini,General,MuleAssistVer].Length} ${temppCharName}
		/if (${temppCharName.Find[.ini]}) {
			/varset tempIniFileName ${temppCharName}
			/echo Set ini file name to ${tempIniFileName} cause it had ini in it
		} else /if (${Ini[MuleAssist_${EverQuest.Server}_${temppCharName}.ini,General,MuleAssistVer].Length}) {
            /varset tempIniFileName "MuleAssist_${EverQuest.Server}_${temppCharName}.ini"
            /echo 1 Server Name ini file detected using ${tempIniFileName}
        } else /if (${Ini["Muleassist_${EverQuest.Server}_${Me}_${Me.Level}.ini,General,MuleAssistVer"].Length}) {
            /varset tempIniFileName "Muleassist_${EverQuest.Server}_${Me}_${Me.Level}.ini"
            /echo 2 Server Name ini file detected using ${tempIniFileName}
        } else {
	    /echo 3 Server Name ini file detected using ${tempIniFileName}
            /varset tempIniFileName MuleAssist_${temppCharName}.ini
        }
        /varset pKV ${Ini[${tempIniFileName},General,MuleAssistVer]}
        /if (${Int[${pKV}]}==0) {
           /echo Invalid INI file: ${tempIniFileName} for memorizing spells. Returning.
           /return
        }
        /varset pKV ${Ini[${tempIniFileName},"MySpells",Gem1]}
        /if (${Int[${pKV.Length}]}==0) {
           /echo No Spells found in INI file: ${tempIniFileName}. Use /writespells and try again. Returning.
           /return
        }
        /for i 1 to 13
            /varset pGem ${Ini[${tempIniFileName},"MySpells",Gem${i}]}
            /if (${pGem.Length} && ${pGem.NotEqual[null]}) {
                /if (${pGem.Find[ Rk.]}) {
                   /varset tempSpellName ${pGem.Left[${Math.Calc[${pGem.Find[ Rk.]}-1]}]} 
                } else {
                   /varset tempSpellName ${pGem} 
                }
                /varset pGem ${Spell[${tempSpellName}].RankName}
                /if (${Me.Book[${pGem}]}) {
                    /if (${Int[${Me.Gem[${pGem}]}]}>0 && ${Int[${Me.Gem[${pGem}]}]}!=${i}) {
                        /varcalc ii ${Int[${Me.Gem[${pGem}]}]}-1
                        /notify CastSpellWnd CSPW_Spell${ii} rightmouseup
                        /delay 20 ${Int[${Me.Gem[${pGem}]}]}==0
                    }
                    /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${pGem}]}) {
                        /if (${MuleDebug}) /echo Meming ${pGem} in slot ${i} in Bind_MemMySpells
                        /memspell ${i} "${pGem}"
                        /delay 90 ${Me.Gem[${i}].Name.Equal[${pGem}]}
                    }
                } else {
                    /echo Could Not find the spell ${pGem} in your spell book.
                }
            }
        /next i   
    DEBUGN MemMySpells: Exit"
    /return

| -------------------------------------------------------------------------------------
| SUB: MemSpell
| ------------------------------------------------------------------------------------- 
   Sub MemSpell(pGem, int i, int ForceIt, string sentFrom3)
   DEBUGCAST Memspell: ${pGem} ${i} ${ForceIt} ${sentFrom3}"
	/declare memtimer timer local 0
	/if (${Int[${pGem.Length}]}==0 || ${pGem.Equal[null]} || ${i}==0) /return
	/if (${Int[${Me.Gem[${pGem}]}]}>0 && !${ForceIt}) /return
	/if (${ForceIt}) {
		DEBUGCAST Memspell: Force it"
		/if (${Int[${Me.Gem[${pGem}]}]}>0 && ${i}!=${ForceIt}) {
			/notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${ForceIt}-1]}]} rightmouseup
			/varset memtimer 20
			/while (${memtimer} > 0) {
				/if (${Int[${Me.Gem[${i}].ID}]}==0) {
					/break
				}
				/call GetHostilesOnXTarget
				/if (${Macro.Return} > 0) /return
				|delayremove/delay 1
			}
		}
	}
	/if (${Me.Book[${pGem}]}) {
		DEBUGCAST Memspell: We have the spell"
		/if (${Int[${Me.Gem[${i}].ID}]}>0) {
			DEBUGCAST Memspell: Open the window"
			/notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${i}-1]}]} rightmouseup
			/varset memtimer 20
			/while (${memtimer} > 0) {
				/if (${Int[${Me.Gem[${i}].ID}]}==0) {
					/break
				}
				/call GetHostilesOnXTarget
				/if (${Macro.Return} > 0 && !${sentFrom3.Find[Heal]} && !${BuffMode}) /return
				|delayremove/delay 1
			}
		}
		/if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${pGem}]}) {
			DEBUGCAST Memspell: Meming ${pGem} in slot ${i} in MemSpell"
			/memspell ${i} "${pGem}"
			/varset memtimer 300
			/while (${memtimer} > 0) {
				/if (${Me.Gem[${i}].Name.Equal[${pGem}]}) {
					DEBUGCAST Memspell: Ok I memed the spell ${pGem} in slot ${i}. We can return from memspell"
					/break
				}
				/call GetHostilesOnXTarget
				/if (${Macro.Return} > 0 && !${sentFrom3.Find[Heal]} && !${BuffMode}) /return
				|delayremove/delay 1
			}
		}
	} else {
		DEBUGCAST Memspell: Could not find the spell ${pGem}"
		/echo Could Not find the spell ${pGem} in your spell book.
	}
	/if (${Me.CombatState.Equal[COMBAT]}) /delay 3
	/if (${Window[SpellBookWnd].Open}) /windowstate spellbookwnd close
	DEBUGCAST Memspell: Leave"
   /return
| -------------------------------------------------------------------------------------
| SUB: Bind Parse
| -------------------------------------------------------------------------------------
    Sub Bind_Parse(TimeToParse)
        /if (!${Defined[ParseDPS]}) /declare ParseDPS     timer       outer       0
        /echo Parsing combat for ${TimeToParse} seconds
        /target npc dummy
        /delay 10 ${Target.ID}
        /varset MyTargetID ${Target.ID}
		/varset MTIDSetAt ${Macro.CurLine}
        /varset MyTargetName ${Target.CleanName}
        /varset ParseDPS ${TimeToParse}s
        /call Combat
        /call CombatReset Parse
		/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
        /squlech /target clear
        /attack off
        /stick off
        /endmacro
    /return
| -------------------------------------------------------------------------------------
| Task Code
| -------------------------------------------------------------------------------------
| SUB: Unmount
| -------------------------------------------------------------------------------------
    Sub Event_KTDismount
	/echo Turning off Mounts.
        /if (${MountOn}) {
		/varset MountOn 0
	}
        /if (${Me.Mount.ID}) /dismount
    /return
|-----------------------------------------------------------------------------
| SUB: Target NPC
| ----------------------------------------------------------------------------        
    Sub Event_KTTarget(Line, NPCName)
        /declare ZDist float local
        /echo Targeting ${NPCName}
        /if (${NPCName.Equal[null]}) {
            /echo NPC Name is Null. Check your variables.
            /return FALSE
        }
        /if (!${Spawn[npc ${NPCName}].ID}) {
            /echo ${NPCName}? You must be in the wrong palce, no one here by that name
            /return FALSE
        }
		/if (${MuleDebug}) /echo Targeting at\agLine#:${Macro.CurLine}
        /target id ${Spawn[${NPCName}].ID}
        /delay 1s ${Target.ID}==${Spawn[${NPCName}].ID}
        /if (${Target.Distance}>15 && ${Target.Distance}<50) {
			DEBUGMOVE Moveto target between 10-100"
			/if (${MuleDebug}) /echo MoveTo at \ag${Macro.CurLine}
            /moveto id  ${Spawn[${NPCName}].ID}
            /delay 250 ${MoveTo.Stopped}
        }
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /call ZAxisCheck ${ZDist} 4.1
        /if (${MuleDebug}) /echo facing ${Target.ID} FaceMobOn = ${FaceMobOn} \agLine#:${Macro.CurLine}
		/face nolook
        /delay 10
        /return TRUE
|-----------------------------------------------------------------------------
| SUB: KTHail
| ----------------------------------------------------------------------------    
    Sub Event_KTHail(Line, KTMobID)
		/if (${MuleDebug}) /echo Targeting a mob 15y
        /target id ${Spawn[npc ${KTMobID}].ID}
		/delay 1s ${Target.ID}==${Spawn[npc ${KTMobID}].ID}
        /delay ${Math.Rand[20]}
        /keypress h
        /doevents flush KTaskSay
    /return            
|-----------------------------------------------------------------------------
| SUB: KTSay
| ----------------------------------------------------------------------------    
    Sub Event_KTSay(Line, KTSayWhat)
        /delay ${Math.Rand[20]}
        /say ${KTSayWhat}
        /delay 10
        /doevents flush KTaskSay
    /return
|-----------------------------------------------------------------------------
| SUB: TaskDoorTarget
| ----------------------------------------------------------------------------    
    Sub Event_KTDoorClick(Line, int KTDoorID)
    /declare KTCDTimer timer local 10s
    /echo DoorID: ${KTDoorID}
        /delay 10
        /keypress FIRST_PERSON_CAMERA hold
        /delay 2
        /keypress FIRST_PERSON_CAMERA
        /delay 10
        /if (${Target.ID}) /squelch /target clear
        /delay 3
        :retrydoortarget
        /echo target door id ${KTDoorID}
        /if (${KTDoorID}) {
            /doortarget id ${KTDoorID}
        } else /doortarget 
        /delay 3
        /echo ${DoorTarget.Name}
        /if (!${Switch.ID}) {
            /if (${KTCDTimer}) /goto :retrydoortarget
        }
	/if (${MuleDebug}) /echo face the door
        /face door
        /delay 3
        :retryopendoor
        /if (${DoorTarget.Distance}<=70)  {
        /echo Moving to Door 
            /if (${DoorTarget.Distance}>15) {
                /keypress forward hold
                /delay 3
                /keypress forward
            } else /if (${DoorTarget.Distance}<10) {
                /keypress back hold   
                /delay 1
                /keypress back
            }
        }
        /if (!${Switch.Open} || ${DoorTarget.Name.Length}) {
			/if (${MuleDebug}) /echo facing a door
            /face door
            /delay 3
            /echo clicking door
            /click left door
            /delay 1s
            /if (${KTCDTimer}) /goto :retryopendoor
        }
        /if (${Window[largedialogwindow].Open}) {
            /notify largedialogwindow LDW_YesButton leftmouseup
        }
        /doevents flush KTDoorClick
    /return
|-----------------------------------------------------------------------------
| SUB: KTInvite
| ----------------------------------------------------------------------------       
    Sub Event_KTInvite
    /declare i int 
    /declare WhoToInvite ${SpawnCount[pc radius 75 guild]}
    /alert clear 6 
    /squelch /alert add 6 ${Me}
    /for i 1 to ${WhoToInvite}
		/if (${MuleDebug}) /echo Targeting a mob 15x
        /target id ${NearestSpawn[radius 75 pc guild noalert 6].ID}
        /delay 10
        /invite
        /delay 20
        /call BCTExec ${Target.CleanName} "/invite"
        /delay 10 
        /squelch /alert add 6 id ${Target.ID}
    /next i
    /return
|-----------------------------------------------------------------------------
| SUB: SetPullAngle
| ----------------------------------------------------------------------------       
    Sub Bind_SetPullArc(float AWidth, string FDir)
        /declare DirDegree string local 0,45,90,135,180,225,270,315
        /declare FDirTemp  string local ${FDir}
        /if (!${AWidth}) {
            /if (${PullArcWidth}) {
                /echo Turning off Directional Pulling.
                /varset PullArcWidth 0
            }
            /return
        } else {
            /varset PullArcWidth ${AWidth}
        }
        /if (!${Bool[${FDir}]}) {
            /varset FDirTemp ${Me.Heading.Degrees}
        } else /if (${Float[${FDir}]} > 0) {
            /varset FDirTemp ${FDir}
        } else {
            /varset FDirTemp ${DirDegree.Arg[${Select[${FDir},n,ne,e,se,s,sw,w,nw]},,]}.00
            /if (!${FDirTemp} && ${FDir.NotEqual[n]}) {
                /echo Invalid Direction. Turning off Directional Pulling.
                /varset PullArcWidth 0
                /return
            }
        }
        /call SetPullAngles ${Float[${FDirTemp}]} ${AWidth} 0
    /return
|-----------------------------------------------------------------------------
| SUB: SetPullAngles
| ----------------------------------------------------------------------------       
    Sub SetPullAngles(float FDir, float AWidth, int IgnoreMessage)
        /if (!${AWidth}) /return
        /if (!${FDir}) /varset FDir 0.00
        | Figure the Degrees for the left side
        /if (${Math.Calc[${FDir}-(${AWidth}*.5)]}<0) {
            /varcalc PullLSide 360-((${AWidth}*.5)-${FDir})
        } else {
            /varcalc PullLSide ${FDir}-(${AWidth}*.5)
        }
        |Figure the Degrees for the right side
        /if (${Math.Calc[${FDir}+(${AWidth}*.5)]} > 360) {
            /varcalc PullRSide ((${AWidth}*.5)+${FDir}-360)
        } else {
            /varcalc PullRSide ${FDir}+(${AWidth}*.5)
        }
		/varset RPullLSide ${Math.Calc[180--${PullLSide}]}
		/if (${RPullLSide} > 360) {
			/varcalc RPullLSide ${RPullLSide} - 360
		}
		/varset RPullRSide ${Math.Calc[180--${PullRSide}]}
		/if (${RPullRSide} > 360) {
			/varcalc RPullRSide ${RPullRSide} - 360
		}
        |Store your current heading
        /varset PullHeading ${FDir}
        /if (!${IgnoreMessage}) /echo Setting Pull Angles. Facing: ${FDir} Left Side: ${PullLSide} Right Side: ${PullRSide} Width: ${AWidth}  
    /return
|-----------------------------------------------------------------------------
| SUB: FigureMobAngle
| ----------------------------------------------------------------------------       
    Sub FigureMobAngle(int aMobID, bool bBehind)
        /if (!${aMobID}) {
			/return 0
		}
        /declare DirectionToMob float local 0
        /declare bRet bool local 1
        /varset DirectionToMob ${Spawn[${aMobID}].HeadingTo[${CampYLoc},${CampXLoc}].Degrees}
        /if (${PullLSide} >= ${PullRSide}) {
            /if (${DirectionToMob} < ${PullLSide} && ${DirectionToMob} > ${PullRSide}) {
				/varset bRet 0
			}
        } else {
            /if (${DirectionToMob} < ${PullLSide} || ${DirectionToMob} > ${PullRSide}) {
				/varset bRet 0
			}
        }
		|Mirror arc, not tested yet work in progress
		|/if (${bBehind} && !${bRet}) {
		|	/echo puller want us to check behind arc as well \agLine#:${Macro.CurLine}
		|	/varset bRet 1
		|	/varset DirectionToMob ${Spawn[${aMobID}].HeadingTo[${CampYLoc},${CampXLoc}].Degrees}
		|	/if (${RPullLSide} >= ${RPullRSide}) {
		|		/if (${DirectionToMob} < ${RPullLSide} && ${DirectionToMob} > ${RPullRSide}) {
		|			/varset bRet 0
		|		}
		|	} else {
		|		/if (${DirectionToMob} < ${RPullLSide} || ${DirectionToMob} > ${RPullRSide}) {
		|			/varset bRet 0
		|		}
		|	}
		|}
    /return ${bRet}
|-----------------------------------------------------------------------------
| SUB: AssignLooter
| ----------------------------------------------------------------------------       
    Sub AssignLooter
        /if (${Select[${Me},${Group.Leader}]}==0) /return
        /if (${LooterAssigned}) /return
        /if (${Group}<=0) /return
        /if (${Group.MasterLooter.ID}>=1) /return
        DEBUGN Sub AssignLooter Enter"
        /declare k int local
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        | If I am group leader set Main Looter Tag for Group
        /if (${Select[${Me},${Group.Leader}]}) { 
            DEBUGN AssignLooter: /echo I am group Leader"
            |Assign myself as MainLooter if LootOn=1
            /if (${LootOn}) {
            DEBUGN AssignLooter: /echo I am the looter"
                /if (${Group.MasterLooter.Name.NotEqual[${Me}]} && ${Group.MasterLooter.Name.Length}) {
                    /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                    /delay 30 !${Group.MasterLooter.Name.Length}
                    /call AssignGroupRole set "${Group.MainAssist.Name}" 5
                    /call BroadCast r "Assigning ${Me} as Master Looter in Group Window"
                    /varset LooterAssigned 1
                    /return
                }
            }
            /if (${LootOn}==0) {
                DEBUGN AssignLooter: Looking for looter"
                /for k 1 to ${IniIDCount}
                    DEBUGN AssignLooter: ${Spawn[${IniIDList.Arg[${k},|]}].ID} ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}  ${Spawn[${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} ${Spawn[id ${IniIDList.Arg[${k},|]} group].ID}"
                    | If toon is not the zone or not a PC skip to next ID
                    /if (!${Spawn[id ${IniIDList.Arg[${k},|]}].ID} || ${Spawn[id ${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} || !${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}) /goto :NextLooterCheck
                    /if (${Spawn[id ${IniIDList.Arg[${k},|]} pc group].ID}) {
                        | If Looter is someone else than who its suppose to be unset Group tag
                        /if (${Group.MasterLooter.Name.Length} && ${Group.MasterLooter.Name.NotEqual[${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}]}) /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                        /delay 30 !${Group.MasterLooter.Name.Length}
                        /call AssignGroupRole set "${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}" 5
                        /call BroadCast r "LOOT: Assigning ${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName} as Master Looter in Group Window"
                        /varset LooterAssigned 1
                        /return
                    }
                :NextLooterCheck
                /next k
            }
        }
        DEBUGN Sub AssignLooter Leave"
    /return    
| ----------------------------------------------------------------------------
| SUB: GmailParse
| ----------------------------------------------------------------------------
    Sub GmailIniParse
    /declare i int local 0
    /declare GMailEventCheck string local
        /for i 1 to ${GMail.Size}
            /varset GMailEventCheck ${Ini[${IniFileName},Gmail,Gmail${i}]}
            /if (${GMailEventCheck.Length} && ${GMailEventCheck.NotEqual[null]}) {
                /if (${Select[${GMailEventCheck},Dead,GM,Level,Named,Leftgroup,Say,Tell]}) {
                    /echo ${i}. ${GMailEventCheck}
                    /if (${GMailEvents.Length}) {
                        /varset GMailEvents ${GMailEvents},${GMailEventCheck}
                    } else {
                        /varset GMailEvents ${GMailEventCheck}
                    }
                }
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend
| ----------------------------------------------------------------------------
    Sub GmailSend(GMessage)
    |Goofy time shit because Gmail fails if any entry has a colon : in it. 
        /declare GTime string local 
        /declare GtimeHour string local ${Time.Hour}
        /declare AMPM string local am
        /if (${Time.Hour}>=13) {
            /varset GtimeHour ${Int[${Math.Calc[${Time.Hour}-12]}]}
            /varset AMPM pm
        }    
        /varset GTime Date.${Time.Date} Time.${GtimeHour}.${Time.Minute} ${AMPM}
        | Ghetto fix for buffer overflow until MQ2GMail is fixed
        /squelch /plugin MQ2Gmail unload 
        /squelch /plugin MQ2Gmail
        /gmail "Mule-${EverQuest.Server}-${Me.CleanName}" "${GTime} - ${GMessage}"
        /echo GMAIL just sent "Mule-${EverQuest.Server}-${Me.CleanName}" "${GTime} - ${GMessage}"
        /varcalc GSent ${GSent}+1
        /if (${GSent}==5) {
            /varset GSent 0
        }
        /delay 10
    /return    
| ----------------------------------------------------------------------------
| SUB: Roguestuff
| ----------------------------------------------------------------------------
    Sub Roguestuff
        /if (${Me.Class.Name.Equal[Rogue]}) {
			/if (!${Me.Combat} && ${AutoHide}) {
				/if (${Me.AbilityReady[hide]} && ${Me.AbilityReady[sneak]}) {
					/doability hide
               		/doability sneak
				}
			}
		}
    /return
| ----------------------------------------------------------------------------
| SUB: LoadSpellSet
| ----------------------------------------------------------------------------
    Sub LoadSpellSet
    
    /declare GemNum      int local
    /declare ValidSpells int local 0
        
    DEBUGN Sub LoadSpellSet LoadSpellSet=(${LoadSpellSet})"
    /if (${LoadSpellSet}==1) {
        DEBUGN Sub LoadSpellSet SpellSetName=(${SpellSetName})"
        /if (${MuleDebug}) /echo Memming spellset (${SpellSetName})
        /memspellset ${SpellSetName}    
    } else {       
        |---Test to see if we have MySpells section defined in INI or not.
        /for GemNum 1 to 13
            /call LoadIni MySpells Gem${GemNum} string NULL
            /if (${Gem${GemNum}.Length} && ${Gem${GemNum}.NotEqual[NULL]}) {
                |-- We have found a good spell defined, one good spell is all it takes to be a valid MySpells config.
                /varset ValidSpells 1
            }
        /next GemNum 
        /if (${LoadSpellSet}==2 && ${ValidSpells}==0) /echo You have no valid spells defined in your ini file [MySpells], load your spells now and do a /writespells command while in MuleAsssist.
        /if (${LoadSpellSet}==2 && ${ValidSpells}==1) /call Bind_MemMySpells ${Me.CleanName}
    }
    |-- If we called this routine, make sure we update values for ReMemMiscGem and ReMemMiscGemLW since they might have changed after spellset load.
    /varset ReMemMiscGem ${Me.Gem[${MiscGem}].Name}
    /varset ReMemMiscGemLW ${Me.Gem[${MiscGemLW}].Name}
    
    /return    
| ----------------------------------------------------------------------------
| SUB: CheckTargetBuffs
| ----------------------------------------------------------------------------
    Sub CheckTargetBuffs(int TWtargetID, Checkbuff)
        /echo ${TWtargetID} ${Checkbuff}
        /if (!${Checkbuff.Length}) /return
        /declare i int local 0
        /declare TWBuff string local
        /declare HasBuff string local
        /if (!${Defined[TWIDTimer${TWtargetID}]}) /declare TWIDTimer${TWtargetID} timer outer 0
        /if (${TWIDTimer${TWtargetID}}==0) {
			/if (${Target.ID}!=${TWtargetID}) {
				/squelch /target clear
				/if (${MuleDebug}) /echo Targeting a mob 14k
				/target id ${TWtargetID}
				/delay 1s ${Target.ID}==${TWtargetID}
			}
			/delay 1s ${Target.BuffsPopulated}
            /for i 0 to 50
                /varset TWBuff ${Target.Buff[${i}].Name} 
                /if (${TWBuff.Length}) {
                    DEBUGBUFF WriteBuffs: ${i}-${TWBuff}"
                    /varset TWbufflist ${TWbufflist}|${TWBuff}
                }
            /next i
        }
        /if (${TWbufflist.Find[${Checkbuff}]}) {
            /varset HasBuff TRUE
        } else {
            /varset HasBuff FALSE
        }        
        /echo ${TWbufflist}
    /return ${HasBuff}    
| ----------------------------------------------------------------------------
| SUB: Set Window Title Buffs
| ----------------------------------------------------------------------------    
    Sub WinTitle
	/if (${TheWinTitle.NotEqual[NULL]}) {
        	/SetWinTitle ${TheWinTitle}
	}
	/return    
        
    Sub AssassinAttack
		/declare Daggergash string local
		/varset Daggergash ${Spell[${RogueTimerEight}].RankName}
        /if (${Me.AbilityReady[hide]} && ${Me.AbilityReady[sneak]} && ${Me.AbilityReady[backstab]} && ${Me.CombatAbilityReady[${Daggergash}]} && ${Spell[${Daggergash}].EnduranceCost} < ${Me.Endurance}) {
            /echo Im going to ${Daggergash} ${Target}!
			/if (${Me.ActiveDisc.ID}) /stopdisc
			/attack off
			/if (${MuleDebug}) /echo Targeting a mob 15z
            /target id ${MyTargetID}
			/delay 1s ${Target.ID}==${MyTargetID}
            /stick 5 id ${MyTargetID} behind
            /delay 10 ${Target.Distance} < 15
            /doability hide
            /doability sneak
            /delay 10
            /call CastDisc "${Daggergash}" 0
            /doability backstab
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs
| ----------------------------------------------------------------------------
    Sub WriteBuffs
        /if (${WriteBuffsTimer} || !${Redguides} || ${AggroTargetID}) /return
		/declare blockedcount int local 40
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
		| Check if it's rof2 or uf?
		/if (${MacroQuest.Build}==4) {
			/varset blockedcount 30
		} else /if (${MacroQuest.Build}==5) {
			/varset blockedcount 20
		}
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Blockedbuffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs
        /ini "KissAssist_Buffs.ini" "${Me.ID}" AmILooting ${LootOn}
        /ini "KissAssist_Buffs.ini" "${Me.ID}" MyRole ${Role}
        | Write all current buffs to KissAssist_Buffs.ini file

        /for i 0 to 41
			|/if (${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Find[(]}) {
            |    /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Arg[1,(].Left[-1]}
            |} else {
            |    /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip}
            |}
			|/echo looking for ( in buffname for ${Me.Buff[${i}].Name}
			/if (${Me.Buff[${i}].Name.Find[(]}) {
                /varset BuffList ${Me.Buff[${i}].Name.Arg[1,(].Left[-1]}
            } else {
                /varset BuffList ${Me.Buff[${i}].Name}
            }
            /if (${BuffList.Length}) {
                DEBUGN WriteBuffs: ${i}-${BuffList}"
                /if (${BuffList.Find[:Permanent]}>1) /varset BuffList ${BuffList.Left[${Math.Calc[${BuffList.Find[:Permanent]}-1]}]}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs "${Writebufflist}"
        |/delay 15
        | Open Blocked Buffs window temporarily to read blocked buffs
        |/if (!${Window[BlockedBuffWnd].Open} && !${BBWindowOpen}) {
        |    /windowstate BlockedBuffWnd open
        |    /varset BBWindowOpen 120m
        |    /delay 10
        |}
        | Write all blocked buffs to KissAssist_Buffs.ini file
        /for k 1 to ${blockedcount}
			|/echo blocked buff ${k} = ${Me.BlockedBuff[${k}].Name}
            |/varset Blockedbuff ${Window[BlockedBuffWnd].Child[BW_BLOCKEDBUFF${k}_Button].Child[BBuff${k}].Tooltip}
            /varset Blockedbuff ${Me.BlockedBuff[${k}].Name}
            /if (${Blockedbuff.Length}) {
                /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
			|/mqp
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs "${Blockedbufflist}"
        |/if (${Window[BlockedBuffWnd].Open}) /windowstate BlockedBuffWnd close
        /varset WriteBuffsTimer 30s
    /return

Sub GetHostilesOnXTarget
	|Lets check a few shits here since this one is called bth out of and in combat.
	/if (${DoMuleHideID}) {
		/call DoMuleHide ${DoMuleHideID}
	}
	DEBUGN Getting Hostiles"
	/if (${DoMassPullString.NotEqual[NULL]}) {
		|/echo ${DoMassPullString.Arg[1]},${DoMassPullString.Arg[2]},${DoMassPullString.Arg[3]},${DoMassPullString.Arg[4]},${DoMassPullString.Arg[5]} \agLine#:${Macro.CurLine}
		/call DoMassPull ${DoMassPullString}
		/varset DoMassPullString NULL
	}
	/if (${RootString.NotEqual[NULL]}) {
		|/echo gonna call DoRootAll because RootString is ${RootString} \agLine#:${Macro.CurLine}
		/call DoRootAll ${RootString}
	}
    /if (${SoWID}) {
		/if (${Group}) {
			/call BCTell ${Group.Leader} "Casting sow on ${Spawn[${SoWID}]}"
		}
		/call SoW ${SoWID}
	}
	/if (${PullOnce}) {
		/varset PullOnce 0
		/call FindMobToPull 3
	}
	/declare hostilecount int local 0
	/declare i int local 0
	/for i 1 to 13
            /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]}) {
                /varcalc hostilecount ${hostilecount}+1 
				/if (${MuleDebug}) /echo Hostiles${i} found, set to ${hostilecount}
            }
       /next i
/return ${hostilecount}

Sub SmartMerc
	/if (!${MercOn}) /return
	/if (${Mercenary.State.Equal[Active]} && ${Mercenary.Class.Name.Equal[Wizard]} && ${Me.Subscription.Equal[GOLD]}) {
		/call GetHostilesOnXTarget
		/if (${Macro.Return}!=0) {
			/if (${Target.ID} && ${Target.Type.Equal[NPC]} && ${Target.PctHPs} <= 90) {
			|/if (${Bool[${Me.GroupAssistTarget.ID}]}==TRUE && ${Spawn[${Me.GroupAssistTarget.ID}].Type.Equal[NPC]} && ${Spawn[${Me.GroupAssistTarget.ID}].PctHPs}<=90) {
				/if (${Mercenary.Stance.NotEqual[Burn]}) {
					/call BroadCast t "I'm using SmartMerc so telling merc to burn"
					/stance burn
				}
			} else /if (${Mercenary.Stance.NotEqual[Balanced]}) {
				/call BroadCast t "I'm using SmartMerc so telling merc to balance (1)"
				/stance balanced
			}
		} else /if (${Mercenary.Stance.NotEqual[Balanced]}) {
				/call BroadCast t "I'm using SmartMerc so telling merc to balance (2)"
				/stance balanced
		}
	}
/return
| ----------------------------------------------------------------------------
| SUB: ZoneMap - Lemons custom stuffs. This will map every new spawn on the #3 label of your in game map to an ini file. However, you have to edit the file yourself cause I'm too lazy to use cmdline.  
|		/lockill kill name   /watchmob name   /varset LocRadius maxradius to move and kill to
| ----------------------------------------------------------------------------
Sub ZoneMap(Hunting,sentFrom)
	/declare i int local
	/declare writeToIni bool local FALSE
	/if (!${Ini[Map_Labels,${Zone.ShortName}_3,Num].Length} && ${writeToIni}) /ini "Lemons_Info" "${Zone.ShortName}_3" "Num" 0
	/if (${LastSpawn[1].ID} != ${LastSpawnID} && ${LastSpawn[1].Type.NotEqual[pet]} && ${LastSpawn[1].Type.NotEqual[pc]}) {
		/if (${writeToIni}) {
		/ini "Lemons_Info" "${Zone.ShortName}_3" "${Math.Calc[${Ini[Map_Labels,${Zone.ShortName}_3,Num]} +1]}" "P ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z},  0, 0, 0,  3,  ${LastSpawn[1].Name.Replace[ ,_]}_${Time}"
		/ini "Lemons_Info" "${Zone.ShortName}_3" "Num" ${Math.Calc[${Ini[Map_Labels,${Zone.ShortName}_3,Num]}+1]}
		}
		/varset LastSpawnID ${LastSpawn[1].ID}
		/if (${LastSpawn[1].Named} && !${MobWatchName1.Length} && !${MobWatchName2.Length}) {
			/echo Added \ag${LastSpawn[1]} \ax a \arNamed \axto spawn list map at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
			/beep
			
		} else /if (${LastSpawn[1].Name.Find[${MobWatchName1}]} || ${LastSpawn[1].Name.Find[${MobWatchName2}]}) {
			/beep
			/echo \aoWatch List Mob \ax \ag${LastSpawn[1]} \ax a \arNamed \axto spawn list map \aoWatch List Mob at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
		} else {
			/echo Added \ag${LastSpawn[1]} \ax to spawn list map  at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
		}
	}
	/if (${LastSpawn[1].ID} != ${LastSpawnID} && ${LastSpawn[1].Type.NotEqual[pet]} && ${LastSpawn[1].Type.NotEqual[pc]}) {
		/if (${writeToIni}) {
		/ini "Lemons_Info" "${Zone.ShortName}_3" "${Math.Calc[${Ini[Map_Labels,${Zone.ShortName}_3,Num]} +1]}" "P ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z},  0, 0, 0,  3,  ${LastSpawn[1].Name.Replace[ ,_]}_${Time}"
		/ini "Lemons_Info" "${Zone.ShortName}_3" "Num" ${Math.Calc[${Ini[Map_Labels,${Zone.ShortName}_3,Num]}+1]}
		}
		/varset LastSpawnID ${LastSpawn[1].ID}
		/if (${LastSpawn[1].Named} && !${MobWatchName1.Length} && !${MobWatchName2.Length}) {
			/echo Added \ag${LastSpawn[1]} \ax a \arNamed \axto spawn list map at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
			/beep
		} else /if (${LastSpawn[1].Name.Find[${MobWatchName1}]} || ${LastSpawn[1].Name.Find[${MobWatchName2}]}) {
			/beep
			/echo \aoWatch List Mob \ax \ag${LastSpawn[1]} \ax a \arNamed \axto spawn list map \aoWatch List Mob at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
		} else {
			/echo Added \ag${LastSpawn[1]} \ax to spawn list map  at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
		}
	}
	/if (${LastSpawn[1].ID} != ${LastSpawnID} && ${LastSpawn[1].Type.NotEqual[pet]} && ${LastSpawn[1].Type.NotEqual[pc]}) {
		/if (${writeToIni}) {
		/ini "Lemons_Info" "${Zone.ShortName}_3" "${Math.Calc[${Ini[Map_Labels,${Zone.ShortName}_3,Num]} +1]}" "P ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z},  0, 0, 0,  3,  ${LastSpawn[1].Name.Replace[ ,_]}_${Time}"
		/ini "Lemons_Info" "${Zone.ShortName}_3" "Num" ${Math.Calc[${Ini[Map_Labels,${Zone.ShortName}_3,Num]}+1]}
		}
		/varset LastSpawnID ${LastSpawn[1].ID}
		/if (${LastSpawn[1].Named} && !${MobWatchName1.Length} && !${MobWatchName2.Length}) {
			/echo Added \ag${LastSpawn[1]} \ax a \arNamed \axto spawn list map at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
			/beep
		} else /if (${LastSpawn[1].Name.Find[${MobWatchName1}]} || ${LastSpawn[1].Name.Find[${MobWatchName2}]}) {
			/beep
			/echo \aoWatch List Mob \ax \ag${LastSpawn[1]} \ax a \arNamed \axto spawn list map \aoWatch List Mob at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
		} else {
			/echo Added \ag${LastSpawn[1]} \ax to spawn list map  at ${If[${LastSpawn[1].X}<0,${Math.Abs[${LastSpawn[1].X}]},-${LastSpawn[1].X}]}, ${If[${LastSpawn[1].Y}<0,${Math.Abs[${LastSpawn[1].Y}]},-${LastSpawn[1].Y}]}, ${LastSpawn[1].Z}_${Time}
		}
	}	
	/if (${MobWatchName1.Length} || ${MobWatchName2.Length}) {
		/for i -5 to 1
		/if ((${LastSpawn[${i}].Name.Find[${MobWatchName1}]} || ${LastSpawn[${i}].Name.Find[${MobWatchName2}]}) && ${Spawn[${LastBeep}].ID} != ${LastSpawn[${i}].ID} && ${Spawn[${LastBeep}].Type.Equal[NPC]} ) {
			/beep
			/echo \aoWatch List Mob \ax \ag${LastSpawn[${i}]} \ax spawned and we may not have caught it found at ${i} \aoWatch List Mob ${Time} LastBeep ${LastBeep}
			/varset LastBeep "${LastSpawn[${i}]}"
		}
		/next i
	}
	/if (${sentFrom.Find[med]}) /return
	|Lemons: This will kill any mob that spawns at your input locs using /lockill.
	|V2: Added in the ability to just do a partial string match on mob name. Mucho dangerous. Enjoy!
	|Turn on hidec alwaysnpc otherwise corpses will cause it to not trigger
	|X is the first entry in the map and Y is the second entry in the map (Lemons_Info.ini)
	/if (((${Spawn[${nameKill1}].ID} && ${Spawn[${nameKill1}].Type.Equal[npc]}) || (${Spawn[${nameKill2}].ID} && ${Spawn[${nameKill2}].Type.Equal[npc]} && !${Spawn[${Spawn[${nameKill2}].AssistName}].ID})) && !${Hunting} && ${Me.CombatState.NotEqual[COMBAT]}) {
		/echo ${nameKill1} or ${nameKill2} is up! Let's try and kill it
		/echo (${Spawn[${nameKill1}].ID} && ${Spawn[${nameKill1}].Type.Equal[npc]} && !${Spawn[${Spawn[${nameKill1}].AssistName}].ID} && ${Spawn[${nameKill1}].Distance} <= ${LocRadius})
		/if (${Spawn[${nameKill1}].ID} && ${Spawn[${nameKill1}].Type.Equal[npc]} && !${Spawn[${Spawn[${nameKill1}].AssistName}].ID} && ${Spawn[${nameKill1}].Distance} <= ${LocRadius}) {
			/if (${Navigation.PathExists[id ${Spawn[${nameKill1}].ID}]}) /call LocKill ${Spawn[${nameKill1}].ID}
		} else /if (!${Spawn[${Spawn[${nameKill2}].AssistName}].ID} && ${Spawn[${nameKill2}].Distance} <= ${LocRadius}) {
			/if (${Navigation.PathExists[id ${Spawn[${nameKill2}].ID}]}) /call LocKill ${Spawn[${nameKill2}].ID}
		}
	}
	|Lemons: This will kill any mob that spawns at your input locs using /lockill.
	|You need to know the exact spawnpoint locs from using MapTheZone
	|X is the first entry in the map and Y is the second entry in the map (Lemons_Info.ini)
	/if ((${LocKillY1} || ${LocKillX1} || ${LocKillY2} || ${LocKillX2}) && !${Hunting} && ${Me.CombatState.NotEqual[COMBAT]}) {
		/for i ${Math.Calc[${Ini[Lemons_Info.ini,${Zone.ShortName}_3,Num]}-10]} to ${Ini[Lemons_Info.ini,${Zone.ShortName}_3,Num]}
		/if (${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Right[-2].Arg[1,,]} == ${LocKillX1} && ${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Right[-2].Arg[2,,].Right[-1]} == ${LocKillY1}) {
			/echo \aoLoc Kill Mob \ax \ag${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Arg[8,,].Left[-9]} \ax found at ${i} 
			/if (${Spawn[${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Arg[8,,].Left[-9]}].ID}) {
				/echo That spawn name is up! Let's try and kill it ${Macro.CurLine}
				/call LocKill ${Spawn[${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Arg[8,,].Left[-9]}].ID}
				/break
			}
		}
		/if (${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Right[-2].Arg[1,,]} == ${LocKillX2} && ${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Right[-2].Arg[2,,].Right[-1]} == ${LocKillY2}) {
			/echo \aoLoc Kill Mob \ax \ag${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Arg[8,,].Left[-9]} \ax found at ${i} 2
			/if (${Spawn[${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Arg[8,,].Left[-9]}].ID}) {
				/echo That spawn name is up! Let's try and kill it
				/call LocKill ${Spawn[${Ini[Lemons_Info.ini,${Zone.ShortName}_3,${i}.00].Arg[8,,].Left[-9].Right[-2]}].ID}
				/break
			}
		}
		/next i
	}
/return
| ----------------------------------------------------------------------------
| SUB: LocKill - Kill stuff that spawned at the input locs
| ----------------------------------------------------------------------------
    Sub LocKill(int mobID)
		/if (${Me.CombatState.NotEqual[Combat]} && ${Spawn[${mobID}].ID} && !${Spawn[${Spawn[${mobID}].AssistName}].ID}) {
			/nav id ${mobID}
			/echo Naving to ${mobID} ${Spawn[${mobID}]}
			||/bardinvis
			/call Empty
			:moving
			|The below lines stop you moving before you get to your target. Use incase of higher level mobs/more dangerous zones
			/if (${Me.CombatState.Equal[Combat]}) {
				/nav stop
				/return
				}
			/call ZoneMap TRUE
			/delay 2
			/if (${Target.ID} != ${mobID}) /tar id ${mobID}
			/if (${Spawn[${Spawn[${nameKill1}].AssistName}].ID} != ${Me.ID} && ${Spawn[${Spawn[${nameKill1}].AssistName}].ID}) /return
			/if (${Spawn[${mobID}].Distance3D} > 10 && ${Spawn[${mobID}].PctHPs} == 100) {
				/if (!${Navigation.Active}) /nav id ${mobID}
				/goto :moving
				}
			/if ((${Me.TargetOfTarget.ID} && ${Me.TargetOfTarget.ID} != ${Me.ID}) || (${Spawn[${mobID}].PctHPs} < 100 && ${Me.TargetOfTarget.ID} != ${Me.ID})) {
				/echo Target is engaged ((${Me.TargetOfTarget.ID} && ${Me.TargetOfTarget.ID} != ${Me.ID}) || (${Spawn[${mobID}].PctHPs} < 100 && ${Me.TargetOfTarget.ID} != ${Me.ID}))
				/return
			}
			:getAgro
			/if (${Target.ID} != ${mobID}) /tar id ${mobID}
			/if (${Target.Distance} < 20) /stick id ${mobID}
			DEBUGCOMBAT Attack on"
			/attack on
			/delay 2
			/if ((${Me.TargetOfTarget.ID} && ${Me.TargetOfTarget.ID} != ${Me.ID}) || (${Spawn[${mobID}].PctHPs} < 100 && ${Me.TargetOfTarget.ID} != ${Me.ID})) {
				/echo Target is engaged ((${Me.TargetOfTarget.ID} && ${Me.TargetOfTarget.ID} != ${Me.ID}) || (${Spawn[${mobID}].PctHPs} < 100 && ${Me.TargetOfTarget.ID} != ${Me.ID}))
				/return
			}
			/if (${Me.TargetOfTarget.ID} != ${Me.ID}) /goto :getAgro
		}
	/return
| -------------------------------------------------------------------------------------	
| SUB: Bind_LocKill - namekill is to hunt spawns by name
| -------------------------------------------------------------------------------------
    Sub Bind_LocKill(action, string locx, string locy)
	/echo ${action},${locx},${locy}
		/if (${action.Equal[clear]}) {
			/echo clearing kill locs
			/varset LocKillX1
			/varset LocKillY1
			/varset LocKillX2
			/varset LocKillY2
			/varset nameKill1
			/varset nameKill2
			/return
		}
		/if (${action.Equal[report]}) {
			/echo X1 Y1 set to ${LocKillX1} ${LocKillY1}
			/echo X2 Y2 set to ${LocKillX2} ${LocKillY2}
			/return
		}
		/if (${action.Find[kill]}) {
			/if (${nameKill1.Length}) {
				/varset nameKill2 ${locx}
			} else {
				/varset nameKill1 ${locx}
			}
			/echo X1 X2 set to ${nameKill1} ${nameKill2}
			/if (${locx.Length}) {
				/varset LocRadius ${locy}
				/echo Radius set to ${LocRadius}
			}
			/return
		}
		/if (!${LocKillX1} && !${LocKillY1}) {
			/varset LocKillX1 ${locx}
			/varset LocKillY1 ${locy}
			/echo X1 Y1 set to ${LocKillX1} ${LocKillY1}
		} else {
			/varset LocKillX2 ${locx}
			/varset LocKillY2 ${locy}
			/echo X2 Y2 set to ${LocKillX2} ${LocKillY2}
		}
	/return	
| ----------------------------------------------------------------------------
| SUB: Empty - To force a #bind call 
| ----------------------------------------------------------------------------
Sub Empty()
/return
| ----------------------------------------------------------------------------
| SUB: BuffGroup 
| ----------------------------------------------------------------------------
    Sub Bind_BuffGroup(int Flag1)
        /if (!${Flag1}) {
            /call BCGExec "/buffgroup 1"
        }
        /if (${BuffsOn}) {
            /varset ReadBuffsTimer 0
            /varset IniNextTimer 0
            /call CheckBuffs 1
        }
        |/echo Leaving BuffGroup Bind.
    /return

| -------------------------------------------------------------------------------------	
| SUB: Bind_TrackMeDown
| -------------------------------------------------------------------------------------
    Sub Bind_TrackMeDown(int StickOff, int UseNavOnly, int IgnoreDistance)
        /if (${DontMoveMe}) {
            /echo WAIT UP! I was told not to move. Leaving TrackMeDown.
            /return
		}
        DEBUGN Bind_TrackMeDown Enter"
        /declare tmdChaseAssist int local ${ChaseAssist}
        /declare tmdReturnToCamp int local ${ReturnToCamp}
        /declare tmdChaseDistance int local ${ChaseDistance}
        /declare tmdCampRadiusExceed int local ${CampRadiusExceed}
        | Check if I am Dead.
        /if (${Me.Hovering} || ${IAmDead}) /return
        | Check if Who to chase character is in the zone.
        /if (${Spawn[pc ${WhoToChase}].ID}==0) /return
        /varset BindActive 1
        | Check if we are to use Navigation and it is loaded with a valid Mesh and Path.
        /if (${UseNavOnly} ) {
            /if (${PullMoveUse.NotEqual[nav]} || !${Navigation.MeshLoaded} && ${UseNav} ) {
                /echo I can't Track Down ${WhoToChase}. Navigation not loaded or bad Mesh.
                /return
            } else {
                /if (${Navigation.PathExists[id ${Spawn[pc ${WhoToChase}].ID}]}==FALSE)
                /echo I can't Track Down ${WhoToChase}. No Valid Path too destination.
                /return
            }
        }
        /varset ChaseAssist 2
        /varset ReturnToCamp 0
        /varset ChaseDistance 20
        /if (${IgnoreDistance}) /varset CampRadiusExceed 100000
        
        /if (${Me.Casting.ID}) /stopcast
        | Go chase them down.
        /call DoWeChase TrackMeDown
        
        | Set things back
        /if (${tmdReturnToCamp}) {
            /varset CampXLoc ${Me.X}
            /varset CampYLoc ${Me.Y}
            /varset CampZLoc ${Me.FloorZ}
            /varset LookForward ${Me.Heading.DegreesCCW}
            /echo >> New camp set ${Me.Y}, ${Me.X}
        }
        /if (${StickOff}) {
            /if (${Stick.Active}) /squelch /stick off
        }
        /varset ChaseAssist ${tmdChaseAssist}
        /varset ReturnToCamp ${tmdReturnToCamp}
        /varset ChaseDistance ${tmdChaseDistance}
        /varset CampRadiusExceed ${tmdCampRadiusExceed}
        /varset BindActive 0
        DEBUGN Bind_TrackMeDown Leave"
    /return

| ----------------------------------------------------------------------------
| SUB: ShakeLoose Section - gets unstuck
| ----------------------------------------------------------------------------
Sub Bind_ShakeLoose(int resetreturn)
	/echo Stopping nav \agLine#:${Macro.CurLine}
	/nav stop
	/if (${resetreturn}) {
		/varset ReturnToCamp 0
		/varset ChaseAssist 0
	}
	/stick off
	/if (${MuleDebug}) /echo Stopping AdVPath at ${Macro.CurLine}
	/play stop
	/keypress back hold
	/delay 3
	/keypress back up
	/tar id ${Group.Leader.ID}
	/face fast away
	/keypress forward hold
	/delay 3
	/keypress forward up
	/keypress JUMP
/return
| ----------------------------------------------------------------------------
| SUB: BuffMode
| ----------------------------------------------------------------------------
Sub Bind_BuffMode(OffOn)
	|/echo Toggling BuffMode from ${BuffMode}
	/if ((!${BuffMode} && !${OffOn.Find[off]}) || ${OffOn.Find[on]}) {
		/varset BuffMode TRUE
		/varset ReadBuffsTimer 0
	} else {
		/varset BuffMode FALSE
	}
	/echo BuffMode is now set to ${BuffMode}
/return
| ----------------------------------------------------------------------------
| SUB: ShareIni
| ----------------------------------------------------------------------------
Sub Bind_ShareIni()
	/declare anonini string local
	/declare OldFile	string	local
	/declare NewFile	string	local
	/echo I'm making an anonymous ini for you to share on the MuleAssist forums on RedGuides!
	/if (!${Plugin[MQ2ShellCmd].Version}) {
		/echo This requires mq2shellcmd plugin. Gonna try to load it. 
		/plugin mq2shellcmd noauto
		/delay 4s
		/if (!${Plugin[MQ2ShellCmd].Version}) {
			/echo You don't have mq2shellcommand. I can't make your anonymous ini without it. 
			/return
		}
	}
	/varset anonini ${IniFileName.Replace[${Me},${Me.Class}_${Me.Level}]}
	/varset anonini ${anonini.Replace[${EverQuest.Server},server]}

	/echo Ini file has been set to >> ${anonini} << (anon)
	/delay 1s
	/echo /exec xcopy "${MacroQuest.Path}\Config\${IniFileName.Replace[""",]}" "${MacroQuest.Path}\Config\${anonini.Replace[""",]}" bg
	/varset OldFile ""${MacroQuest.Path}\Config\${IniFileName.Replace[""",]}""
	/varset NewFile ""${MacroQuest.Path}\Config\${anonini.Replace[""",]}""
	|/if (${NewFile.Find[ ]} || ${OldFile.Find[ ]}) {
	|	/popup I can't handle spaces in the path! Old:${OldFile} New:${NewFile}
	|	/echo  I can't handle spaces in the path! Old:${OldFile} New:${NewFile}
	|	/beep
	|	/return
	|}
	/cmd CopyIni xcopy /y "${OldFile}" "${NewFile}*"
	/delay 6s
	/echo It is saved at \at${MacroQuest.Path.Replace[\,\\]}\Config\${anonini} 
	/cmd OpenFldr start ${MacroQuest.Path}\Config
	/delay 3s
	/echo Now, go upload it!!! Here, I'll open a browser for you: https://www.redguides.com/community/resources/categories/muleassist-ini-library.24/add
	/popup Now, go upload it!!! Here, I'll open a browser for you
	/delay 3s
	/exec https://www.redguides.com/community/resources/categories/muleassist-ini-library.24/add fg

/return
| ----------------------------------------------------------------------------
| SUB: Zombie Mode. Lemons: This will turn your toons into mindless zombies that do nothing but follow you. Also, likely to make them corpses when you leave it on accidentally
| ----------------------------------------------------------------------------
Sub Bind_Zombie(OffOn)
	/if (!${ZombieMode} && !${OffOn.Find[off]}) {
		/varset ZombieMode TRUE
		/call Broadcast r "I've been turned into a mindless Zombie! All I'm gonna do is follow ${MainAssist}"
		/varset ZombieTimer 30s
	} else {
		/varset ZombieMode FALSE
		/varset ZombieTimer 0
		/call Broadcast g "ZombieMode set to ${ZombieMode}"
	}	
	
/return
| ----------------------------------------------------------------------------
| SUB: Toggle MuleDebug
| ----------------------------------------------------------------------------
Sub Bind_MuleDebug(OffOn)
	/echo Toggling MuleDebug
	/if (!${MuleDebug} && !${OffOn.Find[off]}) {
		/varset MuleDebug 1
	} else {
		/varset MuleDebug 0
	}	
/return
| ----------------------------------------------------------------------------
| SUB: Toggle DebugCast
| ----------------------------------------------------------------------------
Sub Bind_CastDebug(OffOn)
	/echo Toggling DebugCast
	/if (!${DebugCast} && !${OffOn.Find[off]}) {
		/varset DebugCast 1
	} else {
		/varset DebugCast 0
	}	
/return
| ----------------------------------------------------------------------------
| SUB: LemonDebug - writes some basic debug info to the MQ2 window and the Debug file
| ----------------------------------------------------------------------------
Sub Bind_LemonDebug(sentFrom)
	/if (${sentFrom.NotEqual[WriteDebug]}) {
		/echo \arLemonDebug info
		/echo \agVersion: \ax${MacroVer} 
		/echo \agStart: \ax${startLine}
		/echo \agModes: \ayRole: \ax${Role} | \ayBuffMode: \ax${BuffMode} | \ayZombie: \ax${ZombieMode}
		/echo \agIni: \ax${IniFileName.Replace[${Me},${Me.Class}].Replace[${EverQuest.Server},Server]}
		/echo \agGroup: \ax${Group} ${Group.Member[1].Class} ${Group.Member[2].Class} ${Group.Member[3].Class} ${Group.Member[4].Class} ${Group.Member[5].Class}
		/echo \agMainAssist: \agID:\ax${Spawn[${MainAssist}].ID} \agType:\ax${Spawn[${MainAssist}].Type} \agClass:\ax${Spawn[${MainAssist}].Class} \agDistance:\ax${Spawn[${MainAssist}].Distance}
		/echo \agName:\ax${Macro.Undeclared} \agMem:\ax${Macro.MemUse} \agRun:\ax${Macro.RunTime} \agStack:\ax${Macro.StackSize} \agLine:\ax${Macro.CurLine}
	}
	/ini "MuleAssistDebug_${Me.CleanName}.ini" "DebugInfo" "L1" "Version: ${MacroVer}"
	/ini "MuleAssistDebug_${Me.CleanName}.ini" "DebugInfo" "L2" "Start: ${startLine}"
	/ini "MuleAssistDebug_${Me.CleanName}.ini" "DebugInfo" "L3" "${IniFileName.Replace[${Me},${Me.Class}].Replace[${EverQuest.Server},Server]}"
	/ini "MuleAssistDebug_${Me.CleanName}.ini" "DebugInfo" "L4" "Modes: Role: ${Role} | BuffMode: ${BuffMode} | Zombie: ${ZombieMode}"
	/ini "MuleAssistDebug_${Me.CleanName}.ini" "DebugInfo" "L5" "Group: ${Group} ${Group.Member[1].Class} ${Group.Member[2].Class} ${Group.Member[3].Class} ${Group.Member[4].Class} ${Group.Member[5].Class}"
	/ini "MuleAssistDebug_${Me.CleanName}.ini" "DebugInfo" "L6" "MainAssist: ID:${Spawn[${MainAssist}].ID} Type:${Spawn[${MainAssist}].Type} Class:${Spawn[${MainAssist}].Class} Distance:${Spawn[${MainAssist}].Distance}"
	/ini "MuleAssistDebug_${Me.CleanName}.ini" "DebugInfo" "L7" "Name:${Macro.Undeclared} Mem:${Macro.MemUse} Run:${Macro.RunTime} Stack:${Macro.StackSize} Line:${Macro.CurLine}"
/return
| ----------------------------------------------------------------------------
| SUB: Collectibles
| ----------------------------------------------------------------------------
Sub Bind_Collectibles()
	/declare Bag int local
	/declare Slot int local
	/declare pack int local
	/echo Claiming all collectibles in your inventory.
	/if (${Cursor.ID}) /autoinv
	/keypress OPEN_INV_BAGS
	/delay 1s ${Window[ContainerWindow]}
	/for Bag 1 to 10
		/if (${InvSlot[pack${Bag}].Item.Container}) {
			/if (!${Window[Pack${Bag}].Open}) /itemnotify pack${Bag} rightmouseup
			/for Slot ${InvSlot[pack${Bag}].Item.Container} downto 1
				/if (${InvSlot[pack${Bag}].Item.Item[${Slot}].Collectible}) {
					/nomodkey /itemnotify in pack${Bag} ${Slot} rightmouseup
					/call BroadCast g "Collecting ${InvSlot[pack${Bag}].Item.Item[${Slot}]}"
					/delay 7 !${InvSlot[pack${Bag}].Item.Item[${Slot}].ID}
				}
			/next Slot
		} else {
			/if (${InvSlot[pack${Bag}].Item.Collectible}) {
				/nomodkey /itemnotify pack${Bag} rightmouseup
				/call BroadCast g "Collecting ${InvSlot[pack${Bag}].Item}"
			}
		}
	/next Bag
	/if (${Cursor.ID}) /autoinv
	/keypress CLOSE_INV_BAGS
/return
| ----------------------------------------------------------------------------
| SUB: Collectibles
| ----------------------------------------------------------------------------
Sub Bind_MapTheZone(setting)
	/if (${MapTheZone}) {
		/varset MapTheZone 0
		/echo MapTheZone is ${MapTheZone}
	} else {
		/varset MapTheZone 1
		/echo MapTheZone is ${MapTheZone}
	}
/return
| ----------------------------------------------------------------------------
| SUB: AddFire - Add a mob to the fire resist list
| ----------------------------------------------------------------------------
Sub Bind_AddFire(zoneadd)
/if (${zoneadd.Find[zone]}) {
	/echo Adding the entire zone of \ar${Zone} - ${Zone.ShortName} \axto the \arFire list
	/ini Lemons_Info.ini FireMobs "${Zone.ShortName}"
} else {
	/echo Adding \ag${Target.CleanName} \axto the \arFire list
	/ini Lemons_Info.ini FireMobs "${Target.CleanName}"
}
/return
| ----------------------------------------------------------------------------
| SUB: AddCold - Add a mob to the cold resist list
| ----------------------------------------------------------------------------
Sub Bind_AddCold(zoneadd)
/if (${zoneadd.Find[zone]}) {
	/echo Adding the entire zone of \ar${Zone} - ${Zone.ShortName} \axto the \auCold list
	/ini Lemons_Info.ini ColdMobs "${Zone.ShortName}"
} else {
	/echo Adding \ag${Target.CleanName} \axto the \au Cold resist list
	/ini Lemons_Info.ini ColdMobs "${Target.CleanName}"
}
/return
| ----------------------------------------------------------------------------
| SUB: AddSlow
| ----------------------------------------------------------------------------
Sub Bind_AddSlow(zoneadd)
/if (${zoneadd.Find[zone]}) {
	/echo Adding the entire zone of \ar${Zone} - ${Zone.ShortName} \axto the \auSlow list
	/ini Lemons_Info.ini SlowMobs "${Zone.ShortName}"
} else {
	/echo Adding \ag${Target.CleanName} \axto the \au Slow resist list
	/ini Lemons_Info.ini SlowMobs "${Target.CleanName}"
}
/return
| ----------------------------------------------------------------------------
| SUB: AddDisease
| ----------------------------------------------------------------------------
Sub Bind_AddDisease(zoneadd)
/if (${zoneadd.Find[zone]}) {
	/echo Adding the entire zone of \ar${Zone} - ${Zone.ShortName} \axto the \auDisease list
	/ini Lemons_Info.ini DiseaseMobs "${Zone.ShortName}"
} else {
	/echo Adding \ag${Target.CleanName} \axto the \au Disease resist list
	/ini Lemons_Info.ini DiseaseMobs "${Target.CleanName}"
}
/return
| ----------------------------------------------------------------------------
| SUB: AddMagic
| ----------------------------------------------------------------------------
Sub Bind_AddMagic(zoneadd)
/if (${zoneadd.Find[zone]}) {
	/echo Adding the entire zone of \ar${Zone} - ${Zone.ShortName} \axto the \auMagic list
	/ini Lemons_Info.ini MagicMobs "${Zone.ShortName}"
} else {
	/echo Adding \ag${Target.CleanName} \axto the \au Magic resist list
	/ini Lemons_Info.ini MagicMobs "${Target.CleanName}"
}
/return
| ----------------------------------------------------------------------------
| SUB: AddPoison
| ----------------------------------------------------------------------------
Sub Bind_AddPoison(zoneadd)
/if (${zoneadd.Find[zone]}) {
	/echo Adding the entire zone of \ar${Zone} - ${Zone.ShortName} \axto the \auPoison list
	/ini Lemons_Info.ini PoisonMobs "${Zone.ShortName}"
} else {
	/echo Adding \ag${Target.CleanName} \axto the \au Poison resist list
	/ini Lemons_Info.ini PoisonMobs "${Target.CleanName}"
}
/return
| ----------------------------------------------------------------------------
| SUB: WatchMob - Set the name fo mob watches for MapTheZone and killing of those mobs, if enabled. Custom Lemon's stuff. Feel free to PM me if you want to know how to use the secret magics. Or figure it out and then PM me. I like that better.
|		/watchmob nameOfMob 
| ----------------------------------------------------------------------------
Sub Bind_WatchMob(nameOfMob)
	/if (!${MapTheZone}) /varset MapTheZone 1
	/if (!${MobWatchName1.Length}) {
		/varset MobWatchName1 ${nameOfMob}
		/echo MobWatchName1 set to \ap${MobWatchName1}
	} else /if (!${MobWatchName2.Length}) {
		/varset MobWatchName2 ${nameOfMob}
		/echo MobWatchName2 set to \ap${MobWatchName2}
	} else /if (!${nameOfMob.Find[clear]}) {
		/echo Already have 2 mobs I'm watching for: ${MobWatchName1} | ${MobWatchName2}
		/echo Send in "Clear#" to clear one of them first
	} else /if (${nameOfMob.Find[clear1]}) {
		/varset MobWatchName1
		/echo Cleared MobWatchName1
	} else /if (${nameOfMob.Find[clear1]}) {
		/varset MobWatchName12
		/echo Cleared MobWatchName2
	}
/return


| ----------------------------------------------------------------------------
| SUB: Setting the AssistID after a tank has picked their target
| ----------------------------------------------------------------------------
Sub Event_TankTarget(string line, string Tanker, int CalledTargetID, string KillName)
	|/echo LemonsDebug: ${Tanker} called to kill ${CalledTargetID} which is ${Spawn[${CalledTargetID}].CleanName}
	/if (${CalledTargetID} == 0) {
		/varset AssistID 0
		/return
		}
	/if (${Tanker.Equal[${MainAssist}]}) /varset AssistID ${CalledTargetID}
	/return

| ----------------------------------------------------------------------------
| SUB: Capturing the charm target for enchanters so it can be referenced in conditions
| ----------------------------------------------------------------------------
Sub Event_Charmed(string line, string CharmedName)
	/if (${Me.Class.Name.NotEqual[Enchanter]} || ${Me.Class.Name.NotEqual[Druid]}) /return
	/declare Same bool local
	/echo CharmedEvent triggered with ${CharmedNamed}
	/if (${Spawn[${CharmPetID}].CleanName.Equal[${CharmedName}]}) /varset Same TRUE
	/if (${Spawn[${CharmedName}].Type.Equal[pet]} && ${Spawn[${CharmedName}].Distance} < 100) {
		/if (${Spawn[${CharmedName}].ID} == ${Me.Pet.ID}) {
			/call BroadCast g "${CharmedName} is my new pet and his ID is ${Me.Pet.ID}"  
			/varset CharmPetID ${Spawn[${CharmedName}].ID}
			/echo The group's new charm pet id is ${Spawn[${CharmedName}].ID}. My CharmPetID is ${CharmPetID}
			}
	}
	/if (!${Same}) /call Bind_CharmThis ${Me.Pet.ID} event event
	/call CombatReset "Charmed"
/return

| -------------------------------------------------------------------------------------
| SUB: Chat. Captures all chat types that are sent via the #chat channels. Needed for BuffBeg. I might also sneak in some other functionality. 
| -------------------------------------------------------------------------------------
Sub Event_Chat(ChatType,Sender,ChatText)
	/call BegBuff "${ChatType}" "${Sender}" "${ChatText}"
/return

| -------------------------------------------------------------------------------------
| SUB: BegBuff. Watches for text in your approved channels and casts the buffs associated with your alias
| -------------------------------------------------------------------------------------
Sub BegBuff(Medium,Begger,FullChatText))
	/if (!${BegOn} || (${Me.CombatState.Equal[COMBAT]} && ${BegOn} != 2) || ${Me.Invis} || ${Me.Hovering}) {
		DEBUGBUFF Beg Buffs is off or I'm in combat or invis or dead. Returning from chat (!${BegOn} || ${Me.CombatState.Equal[COMBAT]} || ${Me.Invis} || ${Me.Hovering})${Macro.CurLine}"
		/return
		}
	/if (${ChaseAssist} && !${BuffWhileChasing}) {
		DEBUGBUFF Beg Buffs: Not going to check if they wanted a buff cause I'm following and BuffWhileChasing ${BuffWhileChasing}\agLine#:${Macro.CurLine}"
		/return
	}
	/declare i int local 0
	/declare j int local 0
	/declare m int local 0
	/declare BuffSpell string local 0
	/declare BegID int local ${Spawn[pc ${Begger}].ID}
	/declare ApprovedBeg bool local FALSE
	/declare AllAliases string local
	/declare BuffSelf bool local FALSE
	/declare isTele bool local FALSE
	
	/for i 1 to ${Beg.Size}
		/if (${Math.Calc[${Beg[${i}].Arg[2,|].Count[,]} + 1]} > ${m}) {
		/varset m ${Math.Calc[${Beg[${i}].Arg[2,|].Count[,]} + 1]}
		}
	/next i
	/declare AliasArray[${m}] string local
	DEBUGBUFF BegBuff: BegArray created with ${m} entries\agLine#:${Macro.CurLine}"
	DEBUGBUFF BegBuff: Begger: ${Begger}, ${BegID} Medium: ${Medium} FullText:${FullChatText}\agLine#:${Macro.CurLine}"
	DEBUGBUFF BegBuff: Do we have a matching entry ${BegSize}\agLine#:${Macro.CurLine}"
	/for i 1 to ${BegSize}
		/varset AllAliases ${Beg[${i}].Arg[2,|]} 
		|/mqp
		DEBUGBUFF BegBuff: AllAliases set as ${AllAliases} on i:${i}\agLine#:${Macro.CurLine}"
		|Lets see if FullChatText matches one of our aliases, buff by buff
		/for m 1 to ${AliasArray.Size}
			/if (${FullChatText.Find[${AllAliases.Arg[${m},,]}]} && ${AllAliases.Arg[${m},,].Length}) {
				DEBUGBUFF BegBuff: Found ${AllAliases.Arg[${m},,]} on #${m} and BuffSpell set to ${Beg[${i}].Arg[1,|]}\agLine#:${Macro.CurLine}"
					/echo ${Begger} just said asked for a beg and we have a match on ${m}
					/varset BuffSpell ${Beg[${i}].Arg[1,|]}
					/break
				} else {
					DEBUGBUFF BegBuff: No match from FullChatText on ${AllAliases.Arg[${m},,]} #${m}\agLine#:${Macro.CurLine}"
					/goto :nextAlias
				}
		:nextAlias
		/next m
		
		/if (${BuffSpell.Length} < 2) {
			DEBUGBUFF BegBuff: We couldn't match (${FullChatText}) to any aliases in buff#${i} ${Beg[${i}].Arg[1,|]}\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}
		
		DEBUGBUFF BegBuff: Do we actually have the spell ${BuffSpell}\agLine#:${Macro.CurLine}
		/if (${Me.Book[${BuffSpell}]}) {
			DEBUGBUFF BegBuff: It's a spell and I have it"
			/goto :wehaveit
		}
		/if (${AltAbility[${BuffSpell}].Rank} >0) {
			DEBUGBUFF BegBuff: It's an aa and I have it"
			/goto :wehaveit
		}
		/if (${Me.CombatAbility[${BuffSpell}]}) {
			DEBUGBUFF BegBuff: It's a CombatAbility so I guess we're gonna do that? WTF are you people doing"
			/goto :wehaveit
		}
		/if (${FindItem[${BuffSpell}].ID}) {
			DEBUGBUFF BegBuff: It's an item and we have it."
			/goto :wehaveit
		}
		/goto :nextBuff

		:wehaveit
		DEBUGBUFF BegBuff: Is the target here and in range?\agLine#:${Macro.CurLine}"
		/if (!${Spawn[${BegID}].ID} || ((${Spawn[${BegID}].Distance} >= ${Spell[${BuffSpell}].Range} && ${Spawn[${BegID}].Distance} >= ${Spell[${BuffSpell}].AERange}) && ${Me.Book[${BuffSpell}]})) {
			DEBUGBUFF BegBuff: ${BegID} isn't here or they are out of range of spell ${Spell[${BuffSpell}].Range}\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}
		/if ((${Spawn[${BegID}].Distance} >= ${AltAbility[${BuffSpell}].Spell.AERange} && ${Spawn[${BegID}].Distance} >= ${AltAbility[${BuffSpell}].Spell.MyRange}) && ${AltAbility[${BuffSpell}].Rank} >0) {
			DEBUGBUFF BegBuff: ${BegID} isn't here or they are out of range of AA ${Spawn[${BegID}].Distance} >= ${AltAbility[${BuffSpell}].Spell.AERange}, ${AltAbility[${BuffSpell}].Spell.MyRange}\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}
		/if ((${Spawn[${BegID}].Distance} >= ${FindItem[${BuffSpell}].Spell.Range} && ${Spawn[${BegID}].Distance} >= ${FindItem[${BuffSpell}].Spell.AERange}) && ${FindItem[${BuffSpell}].ID} && !${Me.Book[${BuffSpell}]}) {
			DEBUGBUFF BegBuff: ${BegID} isn't here or they are out of range of item ${BuffSpell} ${Spawn[${BegID}].Distance} >= ${FindItem[${BuffSpell}].Spell.Range}, ${FindItem[${BuffSpell}].Spell.AERange}\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}		
		|Lemons: Had to add this cause MQ2 BuffCache is broken. It's probably good to have here anyways
		/call CacheBuffs ${BegID} OOG
		DEBUGBUFF BegBuff: Will it stack? (!${Spell[${BuffSpell}].StacksSpawn[${BegID}]} && ${Me.Book[${BuffSpell}]})\agLine#:${Macro.CurLine}"
		/for j 1 to ${Spell[${BuffSpell}].NumEffects}
			/if (${Spell[${BuffSpell}].Attrib[${j}]} == 146) {
				/varset isTele True
				/break
			}
		/next j
		/if (!${Spell[${BuffSpell}].StacksSpawn[${BegID}]} && ${Me.Book[${BuffSpell}]} && !${isTele}) {
			DEBUGBUFF BegBuff: ${BuffSpell} won't stack on ${BegID}\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}
		/if (!${AltAbility[${BuffSpell}].Spell.StacksSpawn[${BegID}]} && ${AltAbility[${BuffSpell}].Rank} >0 && !${isTele}) {
			DEBUGBUFF BegBuff: ${BuffSpell} won't stack on ${BegID}\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}
		/if (!${FindItem[${BuffSpell}].Spell.StacksSpawn[${BegID}]} && ${FindItem[${BuffSpell}].ID} && !${isTele}) {
			DEBUGBUFF BegBuff: ${BuffSpell} won't stack on ${BegID}\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}		
		DEBUGBUFF BegBuff: Do I have the mana to cast it and am I in combat?\agLine#:${Macro.CurLine}"
		/if (${Spell[${BuffSpell}].Mana} > ${Me.CurrentMana}) {
			DEBUGBUFF BegBuff: Not enough mana\agLine#:${Macro.CurLine}"
			/goto :nextBuff
		}
		
		DEBUGBUFF BegBuff: Are they on the whitelist ${BegPermission}\agLine#:${Macro.CurLine}"
		|Whitelist checks
		/if (${BegPermission.Find[all]}) {
			/varset ApprovedBeg TRUE
			DEBUGBUFF BegBuff: All begs are accepted, moving on\agLine#:${Macro.CurLine}"
			} else /if (${Raid.Member[${Spawn[${BegID}].CleanName}].ID} && ${BegPermission.Find[raid]}) {
			/varset ApprovedBeg TRUE
			DEBUGBUFF BegBuff: They are a raid member and raid begs are on, moving on\agLine#:${Macro.CurLine}"
			} else /if (${Spawn[${BegID}].Guild.Equal[${Me.Guild}]} && ${BegPermission.Find[guild]}) {
			/varset ApprovedBeg TRUE
			DEBUGBUFF BegBuff: They are a guild member and guild begs are on, moving on\agLine#:${Macro.CurLine}"
			} else /if (${Spawn[${BegID} fellowship].ID} && ${BegPermission.Find[fellowship]}) {
			/varset ApprovedBeg TRUE
			DEBUGBUFF BegBuff: They are a fellowship member and fellowship begs are on, moving on\agLine#:${Macro.CurLine}"
			} else /if (${Spawn[${BegID}].ID} && ${BegPermission.Find[tell]} && ${Medium.Equal[tell]}) {
			/varset ApprovedBeg TRUE
			DEBUGBUFF BegBuff: They sent a tell and tell begs are on, moving on\agLine#:${Macro.CurLine}"
			} else /if (${Group.Member[${Spawn[${BegID}].CleanName}].ID} && ${BegPermission.Find[group]}) {
			/varset ApprovedBeg TRUE
			DEBUGBUFF BegBuff: They are in my group, moving on\agLine#:${Macro.CurLine}"
			}
		DEBUGBUFF BegBuff: ApprovedBeg set to ${ApprovedBeg} for ${BegID} ${Spawn[${BegID}]} with ${BegPermission}"
		/if (${FullChatText.Find[selfbuff]} && ${ApprovedBeg}) {
			/varset BuffSelf TRUE
			DEBUGBUFF BegBuff: Told I should also cast it on myself"
			/goto :buffThyself
		}
		/if (!${ApprovedBeg}) /goto :nextBuff
		
		:buffTheSupplicant
		/echo BegBuff: Going to cast ${BuffSpell} on ${BegID}\agLine#:${Macro.CurLine}
		/if (${ApprovedBeg}) {
			DEBUGBUFF BegBuff: Calling CastWhat "${BuffSpell}" ${BegID} BuffBeg 1 0\agLine#:${Macro.CurLine}"
			/if (${Beg[${i}].Arg[3,|].Equal[item]}) {
				/call CastWhat "${BuffSpell}" ${BegID} BuffBeg 1 0 item
			} else {
				|Lemons: This is honestly a lazy way around longer recasts on spells. To really address this without freezing the macro we would need to create a timer system that uses a queue or requested buffs.
				/delay 10s ${Me.SpellReady[${BuffSpell}]} || !${Me.Gem[${BuffSpell}]}
				/call CastWhat "${BuffSpell}" ${BegID} BuffBeg 1 0
			}
			/break
		}
		:buffThyself
		/if (${BuffSelf} && !${Me.Buff[${BuffSpell}].ID}) {
				DEBUGBUFF BegBuff: Calling CastWhat on me "${BuffSpell}" ${Me.ID} BuffBeg 1 0\agLine#:${Macro.CurLine}"
				/call CastWhat "${BuffSpell}" ${Me.ID} BuffBeg 1 0
				/if (${BuffSelf} && ${Me.Buff[${BuffSpell}].ID}) {
					DEBUGBUFF BegBuff: I've already got #${i} ${BuffSpell} on me and you wanted me to cast it on myself.Ending BuffBeg.(${BuffSelf} && !${Me.Buff[${BuffSpell}].ID})\agLine#:${Macro.CurLine}"
					/break
				}
			/break
			}
	:nextBuff
	/next i
	/return
| -------------------------------------------------------------------------------------
| SUB: For making everyone on the entire server feel special. <3 Redbot
| -------------------------------------------------------------------------------------	
Sub Event_Cheerleader(DMob, DKiller)
	/if (!${CheerPeople}) /return
	/delay 3s
	/delay ${Math.Rand[10]}s
	/tell ${DKiller} Grats on killing ${DMob}
/return	
| -------------------------------------------------------------------------------------
| SUB: Captures when a mob is uncharmable
| -------------------------------------------------------------------------------------
Sub Event_CannotCharm
	/echo ${Target} cannot be charmed
	/charmthis clear
/return
| -------------------------------------------------------------------------------------
| SUB: When invis is wearing off
| -------------------------------------------------------------------------------------
Sub Event_Appear
	/if (${Me.Invis}) {
		/call BroadCast r "${Me} invis is going to fall!"
	} else {
		/call BroadCast r "${Me} No longer invised!"
	}
/return
| -------------------------------------------------------------------------------------
| SUB: Locked Door detection and use lock pick if available
| -------------------------------------------------------------------------------------
Sub Event_LockedDoor
	/declare lockItem string local
	/if (${FindItem[=lockpicks].ID}) {
		/varset lockItem lockpicks
	} else /if (${FindItem[=mechanized lockpicks].ID}) {
		/varset lockItem mechanized lockpicks
	} else /if (${FindItem[=fine lockpicks].ID}) {
		/varset lockItem fine lockpicks
	}
	
	/echo Door is locked
	/if (${lockItem.Length}) {
		/echo I have lockpicks ${lockItem}. Gonna try to open the door!
		/nomodkey /itemnotify "${lockItem}" leftmouseup
		/delay 2s ${Cursor.ID}
		/doortarget
		/delay 1s ${DoorTarget.Name.Length}
		/click left door
		/delay 2
		/click left door
		/varset CursorIDTimer 2s		
	}
/return
| -------------------------------------------------------------------------------------
| SUB: TooFar check on abilities because we can't see ability ranges
| -------------------------------------------------------------------------------------
Sub Event_TooFarAbility
	DEBUGCOMBAT I was too far for an ability"
	/doevents Flush TooFarAbility 
/return TooFar

| -------------------------------------------------------------------------------------
| SUB: ConCheck Creates a list of "rare" mobs after you consider a rare mob.
| -------------------------------------------------------------------------------------
Sub Event_ConCheck(line, MobName)
/echo Con Check |${MobName}|
/declare i int local
/if (!${Ini[Map_Labels,RareMobs,Num].Length}) /ini "Map_Labels" "RareMobs" "Num" 0
/for i 1 to ${Ini[Map_Labels,RareMobs].Count[|]}
	/if (${Ini[Map_Labels,RareMobs].Arg[${i},|].Equal[${MobName}]}) {
		/echo ${MobName} is already on the list of Rare mobs
		/return
	}
/next i

/ini "Map_Labels" "RareMobs" "Num" ${Math.Calc[${Ini[Map_Labels,RareMobs,Num]}+1]}
/ini "Map_Labels" "RareMobs" "${MobName}" "${Zone}"
/return